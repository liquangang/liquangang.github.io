---
title: 数字货币私钥保存方案设计
date: 2022-02-08 16:25:55
tags: 区块链
categories:
- [区块链使用]
---

### 方案设计描述（此处只讨论保存到互联网中）
* 保存私钥：
  1、使用RSA方案对钱包私钥进行加密获得钱包私钥密文
  2、将RSA私钥和钱包私钥密文对应的文件压缩成zip文件，并设置密码
  3、然后将RSA私钥和钱包私钥密文分别保存到不用的地方
* 获取私钥：
  1、找到RSA私钥和钱包私钥密文
  2、找到解zip密码，解压获得两个文件
  3、将解密后的文件地址复制到代码中，运行获得明文

### RSA加解密示例代码
```
from binascii import b2a_hex, a2b_hex

import rsa as rsa
from Crypto.Cipher import AES

"""
AES加密部分
使用AES ECB模式，16位AES_KEY
"""

class AESUtil(object):
    AES_KEY = "XewGlSGidrB+REgf"

    def add_to_16(self, text):
        if len(text.encode('utf-8')) % 16:
            add = 16 - (len(text.encode('utf-8')) % 16)
        else:
            add = 0
        text = text + ('\0' * add)
        return text.encode('utf-8')

    # 加密函数
    def encrypt(self, text, aes_key):

        cryptos = AES.new(aes_key.encode('utf-8'), AES.MODE_ECB)
        cipher_text = cryptos.encrypt(self.add_to_16(text))
        # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串
        return b2a_hex(cipher_text)

    # 解密后，去掉补足的空格用strip() 去掉
    def decrypt(self, text, aes_key):
        cryptos = AES.new(aes_key.encode('utf-8'), AES.MODE_ECB)
        plain_text = cryptos.decrypt(a2b_hex(text))
        return bytes.decode(plain_text).rstrip('\0')

    # 生成随机密钥
    def get_random_aes_key(self, n=16):
        """
        获取密钥 n 密钥长度
        :return:
        """
        c_length = int(n)
        source = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        length = len(source) - 1
        result = ''
        for i in range(c_length):
            import random
            result += source[random.randint(0, length)]
        return result

def test_aes():
    print("aes加解密测试")
    aesUtil = AESUtil()
    aes_key = aesUtil.get_random_aes_key()
    print("随机aeskey", aes_key)
    encrypt_text = aesUtil.encrypt("aes加解密测试", aes_key)
    print("aes加密：", encrypt_text)
    decrypt_text = aesUtil.decrypt(encrypt_text, aes_key)
    print("aes解密：", decrypt_text)

"""
RSA加密部分
"""

PUBLIC_KEY_PATH = './rsa_public_key.pem'  # 公钥
PRIVATE_KEY_PATH = './rsa_private_key.pem'  # 私钥

class RSAUtil(object):

    def create_rsa_pri_pub_key(self):
        (public_key, private_key) = rsa.newkeys(1024)
        public_key = public_key.save_pkcs1()
        private_key = private_key.save_pkcs1()
        return (public_key, private_key)

    def encrypt(self, public_key, text):
        return rsa.encrypt(text.encode('utf8'), public_key)

    def decrypt(self, private_key, text):
        return rsa.decrypt(text, private_key).decode()

    """
    传入多个path，将加密数据保存到对应path，并保存秘钥到对应path
    """
    def encrypt_save_text_with_path(self, text, private_key_path, text_path):
        (public_key, private_key) = self.create_rsa_pri_pub_key()
        with open(private_key_path, "wb") as f:
            f.write(private_key)

        tmp_rsa_public_key_path = "./rsa_public.pem"
        with open(tmp_rsa_public_key_path, "wb") as f:
            f.write(public_key)

        public_key = rsa.PublicKey.load_pkcs1(open(tmp_rsa_public_key_path).read())

        encrypt_text = self.encrypt(public_key, text)

        with open(text_path, "wb") as f:
            f.write(encrypt_text)



    """
    传入多个path，将加密数据解密获得明文
    """
    def decrypt_text_with_path(self, private_key_path, text_path):
        private_key = rsa.PrivateKey.load_pkcs1(open(private_key_path).read())

        with open(text_path, "rb") as f:
            encrypt_text = f.read()

        return self.decrypt(private_key, encrypt_text)


"""
rsa+aes
"""

class RSAAESUtil(object):

    def get_rsa_aes_key(self):
        aes_util = AESUtil()
        rsa_util = RSAUtil()

        aes_key = aes_util.get_random_aes_key()
        (rsa_public_key, rsa_private_key) = rsa_util.get_rsa_pub_pri_key(PUBLIC_KEY_PATH, PRIVATE_KEY_PATH)
        return (aes_key, rsa_public_key, rsa_private_key)


    def encrypt(self, text, aes_key, rsa_public_key):
        aes_util = AESUtil()
        rsa_util = RSAUtil()

        # 加密
        encrypt_text = aes_util.encrypt(text, aes_key)
        encrypt_aes_key = rsa_util.encrypt(rsa_public_key, aes_key)
        return (encrypt_text, encrypt_aes_key)

    def decrypty(self, rsa_private_key, encrypt_text, encrypt_aes_key):
        aes_util = AESUtil()
        rsa_util = RSAUtil()
        aes_key = rsa_util.decrypt(rsa_private_key, encrypt_aes_key)
        return aes_util.decrypt(encrypt_text, aes_key)

def test_rsa_aes():
    print("rsa_aes加解密测试")
    rsa_aes_util = RSAAESUtil()

    # 生成秘钥
    (aes_key, rsa_public_key, rsa_private_key) = rsa_aes_util.get_rsa_aes_key()

    # 加密
    (encrypt_text, encrypt_aes_key) = rsa_aes_util.encrypt("rsa_aes加解密测试", aes_key, rsa_public_key)
    print("rsa_aes加密：", encrypt_text)
    print("rsa_aes加密后的aes_key", encrypt_aes_key)

    # 解密
    decrypt_text = rsa_aes_util.decrypty(rsa_private_key, encrypt_text, encrypt_aes_key)
    print("rsa_aes解密：", decrypt_text)

BTC_RSA_PRIVATE_KEY_PATH = "./btc_rsa_private_key.pem"
BTC_RSA_PUBLIC_KEY_PATH = "./btc_rsa_public_key.pem"

ETH_RSA_PRIVATE_KEY_PATH = "./eth_rsa_private_key.pem"
ETH_RSA_PUBLIC_KEY_PATH = "./eth_rsa_public_key.pem"

BTC_ENCRYPT_TEXT_PATH = "./btc_encrypt_text.txt"
ETH_ENCRYPT_TEXT_PATH = "./eth_encrypt_text.txt"

def test_rsa_solution():
    rsa_util = RSAUtil()

    btc_text = "我是比特币私钥"
    eth_text = "我是以太坊私钥"

    rsa_util.encrypt_save_text_with_path(btc_text, BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)
    print(rsa_util.decrypt_text_with_path(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH))

    rsa_util.encrypt_save_text_with_path(eth_text, ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH)
    print(rsa_util.decrypt_text_with_path(ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH))



if __name__ == '__main__':
    test_rsa_solution()
```
