---
title: 设计模式
date: 2022-04-14 16:46:21
tags: Q&A
categories:
- [Q&A, Q&A-java]
---

## 说一下你熟悉的设计模式？
### 参考文章
* [参考文章](https://refactoringguru.cn/design-patterns/java)

### 设计模式介绍
#### 创建型模式
|设计模式名称|简介|优点|缺点|应用场景|
|----|----|---|----|----|
|抽象工厂模式|创建一系列对象时，无需指定具体类，工厂方法模式的改良|同一工厂生产的产品互相匹配；避免与某一具体产品的耦合；符合单一职责原则，代码易于维护；符合开闭原则，增加新产品变体时无需修改代码|需要编写的类较多，代码复杂度较高|同一类对象，但是表现不同时，比如同一个button，在不同系统上不一样|
|生成器模式|能够分步骤创建对象，该模式允许使用相同代码创建不同类型和形式的对象，是工厂方法模式的改良|可以分布创建对象，可以暂缓创建或者递归创建；生成不同对象也可以复用部分创建代码；符合单一职责原则，可以从业务逻辑中抽离创建部分|需要创建多个类，代码复杂度提升|适合构造具有众多参数的复杂对象，避免构造函数重叠|
|工厂方法模式|父类中提供创建对象方法，子类决定实例化对象类型|降低耦合；单一职责原则，只负责创建；开闭原则，拓展新产品容易|代码复杂度提高|无法预知对象具体类型及其依赖关系时；给他人提供拓展能力；复用现有对象节省资源|
|原型模式|复制已有对象，而无需使代码依赖他们所属的类|耦合度低；可以克隆预生成模型，避免反复初始化；更方便生成复杂对象；可以处理复杂对象的不同配置|如果有循环引用的话，会比较麻烦|复制对象，但代码独立于被复制对象所属类；提供一堆原型，方便其他逻辑进行克隆时|
|单例模式|一个类只有一个实例|一个类只有一个实例：全局访问方便；仅初始化创建一次|违反了单一职责原则；可能会导致不同部分耦合度较大；多线程环境容易出现问题|某个类只需要一个可用实例即可；控制全局变量|
#### 结构型模式
|设计模式名称|简介|优点|缺点|应用场景|
|----|----|---|----|----|
|适配器模式|使接口不兼容的对象能够互相协作，实现方式就是在中间做一层转化|单一职责原则，中间层与其他部分没有耦合；开闭原则，不影响其他适配器、两头的逻辑|代码复杂度增加|接口不兼容时|
|桥接模式|将一个大类或一系列紧密相关的类拆分成抽象和实现两个层次，从而实现分别使用|开闭原则，新增部分对原有没有影响；单一职责原则，抽象部分负责定义功能，实现部分负责功能实现|不适合高内聚的类，使用该模式会使其更加复杂|拆分功能复杂的类；拓展类功能；运行时切换不同实现方法|
|组合模式|使用该模式可以将对象组合成树状结构，该方式就是定义一个功能接口，然后希望具备这些功能的就实现一下|利用多态和递归可以方便的使用复杂树结构；开闭原则，无需更改已有代码|对于功能差异较大额类，实现某些接口难度较高|希望不同类型的类，有相同功能|
|装饰模式|允许通过将对象放入包含行为的特殊封装对象中来为原始对象提供新功能，由接口、原始类、装饰基类、装饰实现类|无需创建子类即可扩充功能；可以在运行时添加删除对象功能；单一职责原则，每个装饰类可以只实现一小部分功能|代码复杂度提升|无需修改某个类即可为其增加功能；替代继承方式给对象增加功能|
|外观模式|能为复杂模块提供简单接口|让自己的代码独立于复杂子系统|耦合度提高|需要使用复杂模块的一个简单功能；需要将子系统组织成多层结构|
|享元模式|共享多个对象的所共有的相同状态，让内存中可以载入更多对象，即众多对象引用了众多相同对象|节约内存|代码复杂度高|程序需要大量对象且内存吃紧|
|代理模式|提供对象的替代品，通过代理对对象进行控制访问处理|开闭原则，原始代码无需修改；原始代码运行无影响|代码复杂度提升|虚拟代理、保护代理、远程代理、日志代理、缓存代理等|
#### 行为模式
|设计模式名称|简介|优点|缺点|应用场景|
|----|----|---|----|----|
|责任链模式|允许将请求沿着处理者链进行发送，每个处理者都可以处理或者发送给下一个处理者|可以控制处理顺序； <br />单一这则原则，每个处理者的工作内容可以隔离以解耦；<br />开闭原则，新的处理者不影响已有处理者|部分请求可能未被处理|程序需要使用不同方式处理不同类型的请求，并且不知道这些请求的顺序时；<br />当一个事务需要多个处理者时；所需处理者和顺序在运行时会改变时|
|迭代器模式|能够在不知道集合底层数据结构（列表、栈、树）的情况下，对集合进行遍历|单一职责原则，迭代类与其他业务代码没有没有耦合；<br />开闭原则，新增集合和迭代器时，不需要更改已有代码；<br />可以方便的控制遍历状态|不适合简单遍历；<br />对于某些特殊集合，简单遍历会比迭代器遍历效率更高|当需要隐藏集合复杂性或者保证安全性时；<br />需要减少重复遍历代码时；<br />希望遍历不同的甚至无法预知的数据结构时|
|备忘录模式|允许在不暴露对象细节的情况下保存和回复对象状态|在不破坏对象封装的前提下，创建对象快照；<br />原发器状态记录维护的好的话，可以简化原发器代码|备忘录多会消耗更多内存；<br />负责人必须跟踪完整的原发器生命周期才能正确销毁弃用的备忘录；<br />大部分动态编程语言（PHP、Python等）不能保证备忘录状态不被修改|当需要创建对象状态快照来回复对象之前的状态时；<br />当访问对象会导致封装被突破时|
|状态模式|对象内部状态变化时能改变其行为，看上去就像是对象所属类发生变化一样|单一职责原则，特定状态的代码在特定类中；<br />开闭原则，新增状态不影响已有状态；<br />可以消除臃肿的条件语句|不适合状态机比较少的情况|对象在不同状态下有不同行为，同时状态多且频繁切换；<br />当相似状态和机遇条件的状态机转换中存在许多重复代码时|
|模板方法模式|超类中定义算法框架，子类在框架下可以重写算法的特定步骤|允许重写算法的某个部分；<br />可以将重复的算法步骤整合到超类中|维护困难；<br />如果子类抑制父类默认步骤，会违反里式替换原则（子类可拓展父类功能，但不能替换父类原有功能）|只调整算法的某个特定步骤时；<br />多个算法只有细微之处不一样时|
|命令模式|可以将请求装换为一个包含请求信息的独立对象·，然后利用该对象可以实现各种操作|单一职责原则，解耦触发和执行的代码；<br />开闭原则，不修改客户端代码的情况下创建新的命令；<br />可以实现操作的撤销、恢复、延迟执行、组合等需求|代码复杂度增加|通过操作来参数化对象；<br />将操作进行队列化管理、远程执行等擦搜做时；<br />实现操作回滚功能|
|中介者模式|使用中介者将对象之间的合作进行管理|单一职责原则，可以将耦合关系集中到中介者当中；<br />开闭原则，无需更改组建即可增加新中中介者；<br />减轻耦合；<br />更方便的复用组件|随着中介者内部逻辑的增多，可能会变得难以管理且功能过多|当一些对象与其他对象紧密结合以至难以修改时；<br />当某个对象由于与其他对象耦合度过高导致无法复用时；<br />替代一些仅具备简单功能的子类|
|观察者模式|定义一种订阅机制，当被订阅的内容发生变化时，会通知订阅该内容的对象|开闭原则，新订阅类不影响被订阅类；<br />在运行时建立对象之间的联系|订阅者通知顺序时随机的|当一个对象的某些行为需要收到监控时；<br />当某些逻辑需要依赖某个对象的一些内容的变化时|
|策略模式|定义一系列算法，并将其放入独立的类中，以使算法的对象可以相互替换|可以在运行时切换算法；<br />可以将算法的实现与使用剥离开；<br />可以使用组合代替继承；<br />开闭原则，新增策略不需要修改原有策略|不适合算法不变的情况；<br />代码复杂度提升|类中有多个算法变体，并能够在运行时切换算法时；<br />有许多尽在执行某些行为时略有不同的相似类时；<br />算法在上下文的实现中不失特别重要，可以使用该模式剥离业务逻辑与算法；<br />当类中使用了复杂的条件运算符以在同一算法的不同变体中切换时|
|访问者模式|将算法与访问者隔离开|开闭原则，不影响已有行为；<br />单一职责原则，可以将同一行为的不用版本放到同一个类中；<br />访问者对象可以在访问时可以收集一些有用的信息|每次在元素层次中添加或者移除时一个类时，都需要更新所有访问者；<br />访问者可能无法访问对象的私有变量、方法|对一个复杂对象结构的所有元素进行访问时；<br />清理辅助行为的业务逻辑；<br />当某个行为仅在类层次结构中有意义，在其他类中没有意义时|

## 简单工厂和抽象工厂有什么区别？
### 三种模式介绍：
* 工厂模式；有实体类、创建对应实体的工厂类（一个实体类对应一个工厂类）组成，当增加新实体时，需要增加新的实体类和新的该实体类对应的工厂类即可
* 简单工厂模式：由实体类和一个工厂类组成，当新增实体类时，需要增加一个实体类，并且在唯一的工厂类里面进行修改，增加新实体的创建逻辑
* 抽象工厂模式：将一个产品进行更细致的划分，将该产品的共同点抽象成一个类，然后其细分特点单独实现实体类，且实现该实体类对应的工厂类
### 三者特点
* 常用简单工厂模式，工厂模式代码量较大，抽象工厂模式适合业务复杂、较大的情况
