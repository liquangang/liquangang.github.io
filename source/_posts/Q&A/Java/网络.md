---
title: 网络
date: 2022-04-12 19:43:00
tags: Q&A
categories:
- [Q&A, Q&A-java]
---

### 常见的http响应码
* 分类：
|类型|取值范围|
|---|----|
|信息响应	|100-199|
|成功响应	|200-299|
|重定向|300-399|
|客户端错误|400-499|
|服务器错误|500-599|

* 常见http状态码：
|取值|英文名称|含义|
|---|----|----|
|100|Continue|表示当前内容可行，可以继续执行请求|
|101|Switching protocol|响应客户端Upgrade，表示服务端正在切换协议|
|102|Processing|表示服务端已经收到病正在处理请求，但没有响应可用|
|103|Early Hints|用于与link链接头一起使用，以允许用户代理在服务器准备响应阶段开始预加载preloading资源|
|200|OK|请求成功，一般用于GET和POST请求|
|201|Created|请求成功，并因此创建资源成功，通常应用于post、put请求|
|202|Accepted|请求已收到，还未响应，没有结果。意味着不会有一个异步响应回复请求，可能会有另外的进程或者服务去处理该请求，通常用于批处理或者转发请求给其他进程或服务处理|
|203|Non-Authoritative_Informatioin|服务器已经成功处理请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或第三方的拷贝。当前信息可能是原始版本的子集或者超集。即代理服务器对原始数组做了修改之后返回的状态码|
|204|No_Content|即成功响应，但是客户端当前状态不需要更新，比如put请求中进行资源更新，资源在服务端更新完成，但是客户端不需要更新页面的情况|
|205|Reset_Content|告诉客户端重置文档视图，比如清空表单内容、重置canvas状态或者刷新用户界面|
|206|Partial Content|请求某一部分资源，比如服务器成功响应了get请求，响应报文中包含由Content-Range制定范围内的内容|
|301|Moved_Permanently|永久性重定向。请求的资源已经被永久移动到新的URI，返回的信息包括新的URI，浏览器会自动定向到新的URI，今后任何新的请求都应使用新的URI请求|
|302|Found|临时性重定向|与301类似，但资源只是临时被移动，客户端应继续使用原有URI|
|303|See Other|查看其他地址。与302类似，使用GET请求查看|
|304|Not Modified|未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源，客户端会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在制定日期修改后的资源，即该状态码时服务端对客户端有缓存且该缓存有效时的一种返回|
|307|Temporary_Redirect|临时重定向，与302类似，使用get请求重定向，会按照浏览器标准，不会从post变成get（302会），即使用同样的请求方法和请求内容向新的URI发起请求，为了区分开302|
|400|Bad_Request|客户端报文中存在语法错误，服务端无法理解，浏览器会像200一样处理该状态码|
|401|Unauthorized|请求要求用户的身份认证，通过http认证（BASIC认证，DIGEST认证）的认证信息，若之前进行过一次请求，则表示用户认证失败|
|402|Payment_Required|保留，将来使用|
|403|Forbidden|服务器理解客户端的请求，但是拒绝处理该请求|
|404|Not_Found|服务端无法根据客户端请求找到资源|
|500|Internal_Server_Error|服务器内部错误，无法完成请求|
|501|Not_Implemented|服务器不支持请求的功能，无法完成请求|
|503|Service_Unavailable|由于超载或系统维护，服务器暂时无法响应客户端请求|


### http|响应码 301 和 302 代表的是什么？有什么区别？
* 定义：301代表永久性重定向，302代表临时重定向
* 区别：301应该永久替换使用新的URI，302需要继续使用原有URI

### forward 和 redirect 的区别？
||forward|redirect|
|---|---|----|
|简介|转发，服务端转发给另外的服务，服务端直接请求新的URL|重定向，即客户端访问新的URL|
|重新发请求对象|服务端|客户端|
|浏览器区别|浏览器地址无变化，浏览器不知道新的URL，此时是正向代理，浏览器啥也不知道，以为是正常的|浏览器会显示新的URL|
|请求次数|转发对于客户端来说只有一次请求|重定向需要客户端发两次请求|

### 简述 tcp 和 udp的区别？
||tcp|udp|
|---|---|---|
|简介|tcp（Transmission Control Protocol）是面向连接的、可靠的字节流传输通信协议|udp（User Datagram Protocol）是一种无需连接就可以发送数据包的无连接传输协议|
|优点|可靠性高|速度快，操作简单，资源占用少|
|缺点|资源占用高、速度慢、操作复杂|不可靠|
|特点|注重可靠性，管发也尽量保证让对方收到|注重简单和速度，不注重可靠性，只管发，不管收|

### tcp 为什么要三次握手，两次不行吗？为什么？
* 两次不行，两次无法确定两端同时具备发送和接受数据的能力
* 三次握手的目的：
  * client发送数据给server：client证明自己具备发送数据能力
  * server发送数据给client：server证明自己具备接收和发送数据能力
  * client发送数据给server：client证明自己具备接收数据能力
* 四次挥手目的：
  * client告诉server要关闭连接
  * server告诉client自己知道了，并等待数据传输完成
  * server主动告诉client，可以关闭了
  * client告诉server知道了，过一会就关闭


### 说一下 tcp 粘包是怎么产生的？
* 粘包定义：tcp在传输数据时会将数据拆分成多个数据报依次发送，当接收方收到之后解析完数据包之后的数据跟发送法发出的原始数据不一致的问题，解析的时候出现的数据包首尾连到一起导致的解析出错的问题，有可能消息解析出来后多了其他请求的消息的内容或者本身请求消息内容混乱
* 产生原因：
  * 发送方原因：TCP默认使用Nagle算法（作用是减少网络中数据段数量），Nagle的两种策略（收到确认发送下一个；收集多个数据段，收到确认后一起发出），Nagle会导致粘包问题，即一起发出的时候
  * 接收方原因：没有即使从缓存中读取数据段
* 产生的根本原因：消息边界的不确定
* 解决方法：
  * 加入特殊标志，标志消息头尾
  * 加入消息长度信息
* UDP是直接发送完整消息，太长分片，所以不会有粘包问题

### OSI 的七层模型都有哪些？
* [参考文章](https://blog.csdn.net/qq_39521554/article/details/79894501)
* OSI（Open System Interconnect），即开放式系统互联
* 七层模型介绍：
|层级|功能|TCP/IP四层概念模型|对应协议|
|---|---|---|---|
|应用层|为应用软件提供接口，以实现与另一应用的通信|应用层|HTTP、FTP、DHCP|
|表示层|数据格式转化、数据加密|应用层|LPP、XDP、NBSSN|
|会话层|建立、管理、维护会话|应用层|SSL、TLS、RPC|
|传输层|建立、管理、维护端到端的连接|传输层|TCP、UDP|
|网络层|IP选址及路由选择|网络层|IP、ICMP、IGMP|
|数据链路层|提供网络成与物理层之间的通信|数据链路层|PPTP、L2TP、RARP|
|物理层|比特流传输，即各种实体设备，网线、路由器、交换机等|数据链路层|IEEE 802.2|

### get 和 post 请求有哪些区别？
* 综述：两个本质上没有差别，由于浏览器与服务器的限制，导致产生了差别，不携带参数的时候几乎一样
||get|post|
|---|---|---|
|定义|http的一种请求方法，用于请求一个制定资源|http的一种请求方法，用于将实体提交到制定的资源|
|参数位置|http本身无限制，约定放在URL中，其实也可以有body|http本身无限制，约定放在body中，也可以放到URL中|
|参数长度|http本身无限制，浏览器会限制URL整个长度在2K左右|body理论上无限制，取决于浏览器限制|
|安全|较差，参数地址栏可见|较好，参数在body中，实际仅使用HTTP时都不安全，需要使用加解密才更安全|
|数据包|一个数据包|可能是两个数据包，也可能是一个，看浏览器|
|编码方式|只能进行URL编码|支持多种编码|


### 如何实现跨域？
* 跨域：浏览器为了保证安全（比如防止XSS、CSRF攻击等），会限制仅能请求同一个域名地址下的服务
* 如何实现：
  * JSONP：需要浏览器和服务都支持，
  * CORS：需要浏览器和服务都支持
  * postMessage
  * Websocket
  * Node中间件代理（两次跨域）
  * nginx反向代理（正反向代理如何判断，一方不知道另一方的存在，比如VPN，就是服务器不知道真实客户端的存在，就是正向代理，Nginx让客户端不知道真实服务器的存在，就是反向代理）
  * window.name + iframe
  * location.hash + iframe
  * document.domain + iframe

### 说一下 JSONP 实现原理？
* 利用在\<script\>的漏洞，本质支持跨域，然后用回调接收json进行处理

### 浏览器输入链接请求的详细过程
* URL输入
* DNS解析
* 建立TCP连接
* 发送HTTP请求
* 服务器响应请求
* 浏览器解析渲染页面
* HTTP请求结束，断开TCP连接
