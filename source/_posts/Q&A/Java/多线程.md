---
title: 多线程
date: 2022-01-17 20:40:20
tags: Q&A
categories:
- [Q&A, Q&A-java]
---

### 并行和并发有什么区别？
#### 并发：
* 在操作系统中，一个时间段内在同一个处理机上处于开始到结束之间的多个任务之间的状态，window的时间片分时调度即并发，实际是串行，但是多个任务在不停地切换，每个任务运行一小会，以实现多个任务的同时运行即并发

#### 并行：
* 互不抢占资源的两个任务同时运行时，即并行

#### 区别：
* 并发实际上是串行
* 并发需要共享运算资源，并行不需要
* 单cpu可以实现并发，但不能实现并行
* 并行是真正的同时运行


### 线程和进程的区别？
#### 线程：
* 是进程的子任务
* 是操作系统可识别的最小执行和调度单位
* 是CPU调度和分配的基本单位

#### 进程：
* 是对运行时程序的封装
* 是系统进行资源调度和分配的基本单位

#### 区别：
* 一个线程只能属于一个进程，一个进程可以包含多个线程，且至少有一个线程
* 进程用友独立的内存单元，多个线程共享这部分内存
* 进程是资源分配的最小单位，线程是cpu调度的最小单位
* 创建、撤销、切换等操作，进程的开销要远大于线程
* 线程间可以使用共享内存进行通信，实现起来较简单，进程间通信实现较复杂，进程间通信依赖线程
* 进程间互相不会影响，线程挂掉时会导致整个进程挂掉

### 进程间通信方式？
* 管道：
  * 匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系
  * 高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
  * 有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
* 消息队列
* 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
* 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
* 共享内存：
* 套接字

### 线程间通信方式？
* 各种锁：互斥锁
* 信号量：
* 信号：
* 进程间通信也能用于线程间通信，进程间通信本质上都是线程在干活

### 守护线程是什么？
#### 定义:
* 为其他线程服务的线程，比如垃圾回收线程

#### 特点：
* JVM结束进程时，不关心守护线程，但是用户线程存在的话，JVM不会结束进程
* 守护线程不能持有任何需要关闭的资源，进程结束时会导致该资源出错
* 守护线程优先级低，守护线程中创建的新线程同样是守护线程，用户线程同样，其中创建的新线程也是用户线程

### 线程分类?
#### 按照是否为用户自定义来区分
* 守护线程
* 用户线程

### 创建线程有哪几种方式？
* 本质上都是一样的，都需要new thread
* 继承Thread类，重写run方法
* 通过实现Runnable接口中的run方法
* 通过实现Callable接口中的call方法，然后使用FutureTask进行调用
```
    @Test
    public void testCode() throws ExecutionException, InterruptedException {
        FutureTask<Integer> futureTask = new FutureTask<>(new TestThread());
        new Thread(futureTask).start();
        Integer result = futureTask.get();
        System.out.println(result);
    }

    class TestThread implements Callable<Integer> {

        @Override
        public Integer call() throws Exception {
            System.out.println("啦啦啦啦");
            return 1;
        }
    }
```
* 通过线程池创建线程：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式
  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限
  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限
  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务
  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程


### 说一下 runnable 和 callable 有什么区别？
* 相同点：
  * 都是接口
  * 都可以实现多线程
  * 都采用thread.start启动
* 不同：
  * Runnable的run方法没有返回值，Callable的call方法可以自定义返回值
  * Runnable的run方法只能抛出运行时一场，且无法捕获，Callable的run方法允许抛出异常，且可以捕获
  * Executor使用Runnable使用execute方法，使用Callable时使用submit方法

### 线程有哪些状态？
* new：创建
* Runnable：运行中，正在执行run方法
* Blocked： 运行中，因被阻塞而挂起
* Waiting：运行中，因为某些操作在等待中，join方法会阻塞当前线程，等待该线程对象执行完成，如果已完成，就立即返回
* Timed Waiting：运行中，因为执行sleep，在计时等待
* Terminated：终止，run方法执行完毕或调用Thread的stop

### sleep() 和 wait() 有什么区别？
* 调用方面：
  * sleep是静态方法，wait是实例方法
  * wait只能在同步情况下调用，sleep不需要
  * wait是用于线程间通信的，sleep是用于当前线程
* 锁及资源：
  * 线程进入wait状态时会释放持有的对象锁，但sleep不会
  * 进入wait状态的线程使用notify和notifyAll可以再次唤醒，进入sleep状态的线程不能被唤醒
* 异常捕获：
  * sleep需要捕获或者抛出异常，wait/notify/notifyAll不需要

### notify()和 notifyAll()有什么区别？
* notify唤醒对象的等待池中的一个线程进入锁池，notifyAll唤醒等待池中的所有线程进入锁池
* 等待池：线程A调用了对象o的wait方法，A就会释放o的锁，进入o的等待池，等待池中的线程不会竞争o的锁
* 锁池：获取了对象o的锁，才能执行synchronized代码，同一时间内，只有一个线程可以获得该锁，其他线程只能在锁池中等待，锁池中的线程会竞争对象锁，等待池中的线程不会

### 线程的 run()和 start()有什么区别？
* run里面是线程需要计算的内容，start就是创建新线程然后调用一下run，基于此区别自己说就好了

### 创建线程池有哪几种方式？
* 使用Executors创建线程池：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式
  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限
  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限
  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务
  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程
* 通过ThreadPoolExecutor创建自定义线程池

### 线程池都有哪些状态？
* running：接收新任务，处理队列任务
* shutdown：停止接收新任务，处理队列任务
* stop：停止接收新任务，停止处理队列任务，停止正在处理的任务
* tidying：所有任务被终结，有效线程为0，会触发terminated方法
* terminated：当terminated执行结束，销毁状态

### 线程池中 submit()和 execute()方法有什么区别？
* 同
  * 都是线程池的方法
* 异
  * execute只能传入Runnable任务，submit可以传入Runnable和Callable任务
  * execute会直接抛出异常，submit会吃掉异常，但是可以通过future的get方法将异常重新抛出
  * execute所属顶层接口是Executor，submit所属顶层接口是ExecutorService

### 在 java 程序中怎么保证多线程的运行安全？
* 保证安全需要遵守的特性：
  * 原子性：一个或者多个操作在CPU执行的过程中不被中断的特性
  * 可见性：一个线程对共享变量的修改，另一个线程能立刻看到
  * 有序性：程序按照代码顺序进行执行
* 安全隐患：
  * 缓存对可见性的影响
  * 线程切换导致CPU执行终端，对原子性的影响
  * 编译优化带来的有序性问题
* 解决方案：
  * JDK Atomic开头的原子类、synchronized、lock，可解决原子性问题
  * synchronized、volatile、lock可以解决可见性问题
  * Happen-before可解决有序性问题
* Happen-before：
  * 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作发生早于后面的操作
  * 管道锁定规则：unlock操作发生遭遇后面对同一个锁的lock操作
  * volatile规则：对一个变量的写操作早于后面的读操作
  * 线程启动规则：Thread的start操作早于线程的任何其他行为
  * 线程终止规则：Thread的销毁操作发生与线程的所有其他行为之后
  * 线程中断规则：对线程的interrupt的调用发生于被中断线程的代码检测到中断之前
  * 对象销毁规则：对象的初始化完成、构造完成早于销毁

### 多线程锁的升级原理是什么？
* [参考文章](https://www.cnblogs.com/jxxblogs/p/11890563.html)
* 锁分级原因：降低资源消耗，没有优化之前，synchronized是重量级锁（悲观锁），wait、notify、notifyAll切换线程状态非常消耗资源，而线程的挂起和唤醒时间很短，这样会导致浪费资源，影响应能，所以JVM对synchronized进行了优化，把锁分成了无锁、偏向锁、轻量级锁、重量级锁
  * 切换原因：当JVM检测到不同的竞争状态时，会根据需要自动切换到合适的锁
  * 特点：只能从低到高，不能从高到低
  * 位置：对象头的Mark Word里


* CAS：compareAndSwap，比较并替换
  * CAS包含三个操作数：内存地址V、预期值A、即将更新的目标值B
  * 使用场景：当一个线程要修改某个变量的值时，发现被其他线程修改过了，此时就会放弃修改，实现逻辑加锁
  * 特点：逻辑上避免加锁
  * 作用：比较并替换


* 锁级别从低到高：无锁->偏向锁->轻量级锁->重量级锁
  * 无锁：不对资源进行锁定，所有线程都可以同时读写同一资源、但只有一个线程可以成功，其他线程需要不断重试才能成功
  * 偏向锁：对象代码一致被同一线程执行，不存在多个线程竞争，该线程在后续执行中自动获取锁，降低获取锁带来的性能开销。偏向指的就是偏向第一个加锁线程，该线程不会主动释放锁，当其他线程尝试竞争偏向锁时才会被释放。
    * 撤销：在没有字节码执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否被锁定，如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，如果线程处于活跃状态，就升级为轻量级锁
  * 轻量级锁：当对象锁时偏向锁，且对象被第二个线程访问时，此时偏向锁会升级为轻量级锁，第二个线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。
    * 升级重量级锁1：当只有一个等待线程时，该线程会通过自旋进行等待，但是当自旋超过一定次数时，轻量级锁会升级成重量级锁
    * 升级重量级锁2：当一个线程持有锁，另一个线程在自旋等待，此时再有一个线程来访问时，轻量级锁会升级为重量级锁
  * 重量级锁：当一个线程获取锁之后，其余所有等待线程都处于阻塞状态
    * 实现：重量级锁通过对象内的监视器（monitor）实现，monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户状态切换为内核态，切换成本很高
  * synchronized优化之锁消除：编译时对上线文进行扫描，去除不可能存在共享资源竞争的锁，消除没必要的锁，节约资源


* 锁升级过程：

|  |  | |
| -------- | --------- | ----------- |
| 默认无锁，当程序执行到同步块时，***判断对象头中保存的threadId是否是当前线程*** |
| 是：该线程获得偏向锁，此时不需要CAS来加、撤销锁，偏向锁是最简单的线程锁，适合某线程频繁访问同一对象场景 | 否：***判断偏向锁标识*** |
| | 0：即无锁状态，此时需使用CAS竞争锁 | 1：即偏向锁状态，使用CAS将对象头中的锁信息指向当前线程，并触发偏向锁撤销（有竞争才会有偏向锁撤销）|
| 当其它线程尝试竞争偏向锁，且程序到达全局安全点（即无正在运行代码），此时JVM会***判断对象头中记录的线程是否存活*** |
| 未存活：对象被重置为无锁状态，其他线程可竞争偏向锁 | 存活：查找该线程栈帧信息，***判断是否需要继续持有该对象*** |
|| 需要：暂停该线程，撤销偏向锁，升级为轻量级锁 | 不需要：将该对象设置为无锁状态，其他线程可竞争偏向锁 |
|| 轻量级锁：当有多个线程竞争一个偏向锁时，会频繁产生偏向锁撤销，此时JVM会将对象头中的锁标识升级为轻量级锁，多个线程通过自旋来继续获取锁 |
|| 重量级锁：有多个线程通过自旋获取锁，进入到非常激烈状态时，会非常消耗cpu资源，当自旋达到一定次数时（轻量级切换重量级的判断逻辑），JVM会将轻量级锁升级为重量级锁，重量级锁当获取锁失败时会让线程阻塞，重量级锁缺点是线程会频繁进行上下文切换 |




* 锁比较：


  |         | 偏向锁       | 轻量级锁         | 重量级锁            |
  | ------------ | ----------- | -------------- | ------------------ |
  | 使用场景      | 一个同步代码块只有一个线程频繁访问 | 多条线程进入同步块，线程进入时间错开因而并未争抢 | 发生了争抢，多个线程进入同步块并竞争锁 |
  | 本质 | 取消同步操作 | CAS操作代替互斥同步 | 互斥同步 |
  | 优点 | 不阻塞，执行效率高 (不需要使用CAS来获取锁和撤销锁，只需要对比threadId，效率高) | 不会阻塞 | 不会空耗cpu |
  | 缺点 | 使用场景局限，若竞争产生，会有偏向锁撤销的消耗 | 长时间获取不到会空耗cpu | 阻塞，上下文切换，重量级操作，消耗系统资源 |



### 什么是死锁？
#### 线程死锁
* 定义：两个及以上的线程因为互相等待而被阻塞的现象即死锁
* 死锁示例：两个线程互相等待对方持有的锁，即死锁
  ```
  public void add(int m) {
    synchronized(lockA) { // 获得lockA的锁
        this.value += m;
        synchronized(lockB) { // 获得lockB的锁
            this.another += m;
        } // 释放lockB的锁
    } // 释放lockA的锁
}

public void dec(int m) {
    synchronized(lockB) { // 获得lockB的锁
        this.another -= m;
        synchronized(lockA) { // 获得lockA的锁
            this.value -= m;
        } // 释放lockA的锁
    } // 释放lockB的锁
}
  ```
* 导致死锁的原因：
  * 已持有锁的线程请求新锁
  * 两个及以上的线程同时发出新锁请求
  * 两个及以上的线程形成一个新锁申请循环链，每个线程都在等待链中下一个线程持有的锁
* 分类：
  * 潜在死锁：不一定发生，但可能在程序运行的任何阶段发生
  * 实际死锁：程序执行过程中的死锁，实际死锁会导致线程挂起，但进程不一定挂起
* java线程锁是可重入锁，即同一个锁可以被同一线程多次获取到，线程对锁有记录，获取到加1，完成代码块减一，减到0时，释放锁
  * 例：
  ```
  public class Counter {
    private int count = 0;

    public synchronized void add(int n) {
        if (n < 0) {
            dec(-n);
        } else {
            count += n;
        }
    }

    public synchronized void dec(int n) {
        count += n;
    }
}
  ```
#### 进程死锁
* 定义：进程竞争共享资源时出现的无线循环等待问题
* 产生进程死锁必要条件：
  * 互斥条件：共享资源单位时间内只能被一个进程占有
  * 不可抢占条件：某进程占有的资源未使用完之前，其他进程不得抢夺
  * 占有且申请条件：进程已占用的资源，在申请新资源时，仍继续占有已占有资源
  * 循环等待条件：存在一个循环等待环，第一个依赖第二个，第n个依赖第1个
* 预防死锁：打破产生的四个条件之中的一个或多个

### 怎么防止死锁？
* 规避四个产生条件来设计代码，以避免


#### 避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁
* [参考文章1](https://blog.csdn.net/qq_33414271/article/details/80245715)
[参考文章2](https://baike.baidu.com/item/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1679781)
* 安全状态：某一时刻，某进程序列中的进程都可以顺利完成，则此时状态为安全状态，系统中安全状态与不安全状态是共存的，安全状态一定不死锁，不安全状态不一定会死锁
* 安全状态检测：系统先尝试分配资源给申请进程，然后使用剩余资源计算是否能满足进程队列中的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态，如果有进程都可以执行完毕，然后假设回收资源后，也可以让其他所有进程队列中的进程都执行完毕，则系统处于安全状态，然后会根据分配顺序生成安全序列，然后执行
* 判断某个状态是否安全：根据安全性算法进行计算，如果可以找到某种安全序列即安全
* 判断某个请求系统是否可满足：根据安全性算法进行检查，如果分配后剩余的资源无法满足进程队列中的任一进程需求的话，即不能分配，否则可分配

### ThreadLocal 是什么？有哪些使用场景？
* ThreadLocal：线程本地存储，每个线程中都会有一个ThreadLcoalMap对象，用来保存各种数据
* 作用：避免资源在多线程中共享时产生各种异常，所以每个线程自己独立存储一份进行使用
* 使用场景:
  * 比如JDBC的链接，每个线程可独立对数据库进行操作，某个线程进行close操作时不会对其他线程造成影响
  * session管理等
* 实现：这个Map是Thread的属性，而ThreadLocal是一个代理工具类，用来持有这个map并对其进行操作
* 注意点：使用时需要手动调用ThreadLocal的remove方法，尤其是当使用到线程池时，线程可能会一直存在，所以会导致内存泄漏

### 说一下 synchronized 底层实现原理？
* 特性：
  * 原子性
  * 可见性
  * 有序性
  * 可重入性：同一线程可以多次申请同一锁
* 使用场景：
  * 修饰静态方法、成员函数、代码块
  * 真正可以锁的资源：对象
* 通过在对象头当中增加线程标记、锁标记等记录，然后三种锁（偏向锁、轻量级锁、重量级锁）根据程序运行情况使用来实现

### synchronized 和 volatile 的区别是什么？
|| synchronized | volatitle |
|----|----|-----|
| 本质 | 锁定对象只能由一个线程访问 | 告诉jvm某个变量值时不确定的，需要实时读取 |
| 修饰内容 | 变量、方法、类、代码块 | 变量 |
| 可见性、原子性 | 只能保证可见性 | 可见性、原子性 |
| 会不会造成线程阻塞 | 会 | 不会 |
| 编译器优化 | 会 | 不会 |

### synchronized 和 Lock 有什么区别？
|| synchronized | lock |
|----|----|-----|
| 使用场景 | 简单场景使用，并发情况简单 | 并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断 |
| 存在层次 | 是java关键字，可修饰变量、方法、类、代码块 | 一个类，使用时需要主动调用上锁和解锁 |
| 锁实现 | JVM实现 | 自己写代码调用lock API实现 |
| 释放锁 | jvm自动释放(获取锁线程执行完；程序执行异常) | 手动unlock，不释放会造成死锁 |
| 获取锁 | jvm自己获取，根据锁升级规则来获取 | trylock，可以设置等待时间 |
| 锁状态 | 无法判断 | 可以获取 |
| 锁类型 | 可重入、不可中断、非公平 | 可重入、可中断、可公平（不公平皆可） |
| 阻塞性 | 少量阻塞 | 大量阻塞 |
| 性能 | 简单场景两者相似，复杂场景lock好 |

### synchronized 和 ReentrantLock 区别是什么？
|| synchronized | ReentrantLock |
|----|----|-----|
| 使用场景 | 简单场景使用，并发情况简单 | 并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断 |
| 存在层次 | 是java关键字，可修饰变量、方法、类、代码块 | 一个类，使用时需要主动调用上锁和解锁 |
| 锁实现 | JVM实现 | 自己写代码调用lock API实现 |
| 释放锁 | jvm自动释放(获取锁线程执行完；程序执行异常) | 手动unlock，不释放会造成死锁 |
| 获取锁 | jvm自己获取，根据锁升级规则来获取 | trylock，可以设置等待时间 |
| 锁状态 | 无法判断 | 可以获取 |
| 锁类型 | 可重入、不可中断、非公平 | 可重入、可中断、可公平（不公平皆可） |
| 阻塞性 | 少量阻塞 | 大量阻塞 |
| 性能 | 简单场景两者相似，复杂场景lock好 |
| 特点 | 使用简单 | 可以制定公平锁、非公平锁；提供Condition类来精细控制；提供等待获取锁功能 |  
