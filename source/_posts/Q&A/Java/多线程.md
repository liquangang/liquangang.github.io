---
title: 多线程
date: 2022-01-17 20:40:20
tags: Q&A
categories:
- [Q&A, Q&A-java]
---

## 并行、并发区别
||并行|并发|
|---|---|---|
|简介|同时运行，特制多个事件同时执行|同时发生，特制多个事件在某一时间段内同时发生（执行）|
|是否一定同时运行|一定|一定不|
|占用核心|有几个事件就占用几颗核心|小于事件总数|
|特点|倾向于让处理器所有核心都发挥作用|倾向于压榨单颗核心的全部运算性能|

## 线程、进程区别
||线程|进程|
|---|---|---|
|简介|cpu调度和分派的基本单位，进程的子任务|系统调度和分派的基本单位，是对程序的封装|
|归属|一个进程可以包含多个线程|一个线程只能属于一个进程|
|内存|线程使用系统给进程分配的内存|有独立的内存单元|
|开销|线程创建开销相对较小|进程创建开销相对较大|
|通信|线程可以使用所有进程间通信的方式，还包括信号量等手段|各种网络通讯协议都可以；读写同一个文件；共享内存等|
|异常影响|会导致进程及内部线程死掉|会导致内部线程死掉，但对其他进程没影响|

## 守护进程是什么？
服务其他进程的一个进程

## 创建线程方式
* 继承Thread创建线程类
* 实现Runable接口创建线程类
* 通过Callable的Future创建线程

## Runable、Callable区别
||Runable|Callable|
|---|---|----|
|返回值区别|void，无返回值|泛型，用来异步获取运行结果|
|异常|只能抛出运行时异常|call方法允许抛出异常|

## 线程状态
|状态|声明周期范围||
|---|---|---|
|创建状态|生成线程对象-调用start方法之前|
|就绪状态|调用start方法、等待或者睡眠中恢复时|
|运行状态|运行run函数中的代码|
|阻塞状态|线程正在运行的时候暂停，sleep、wait等都可以|
|死亡状态|run执行结束，或者stop|

## sleep()、wait()区别
||sleep|wait|
|---|---|----|
|所属类|Thread类的静态方法|Object类的对象方法|
|区别|不会释放锁，所以会继续占用锁定的资源|会进入线程等待池中，会释放锁，所以会释放锁定的资源|

## notify()、notifyAll()区别
notify随机从线程等待池中唤醒一个wait线程，然后将其放入锁池；notifyAll唤醒线程等待池中的全部线程，将这些线程全部放入锁池中

## run()、start()区别
start是让线程进入就绪状态，即一种可以执行run方法的状态，run方法即线程需要执行的事件内容

## 创建线程池方式
|创建方式|简介|
|---|---|
|使用Executors工厂类提供的方法|newFixedThreadPool(int nThreads):创建固定线程数的线程池，超出需求就进入队列等待<br/>newCachedThreadPool:可缓存线程池，线程数不够会创建新线程<br/>newScheduledThreadPool(int corePoolSize):创建一个固定线程数的可周期或定时执行任务的线程池<br/>newSingleThreadExecutor():创建一个单线程的可按指定顺序执行任务的线程池|
|使用ThreadPoolExector自定义线程池|可自定义核心线程数、最大线程数、存活时间等|

## 线程池有哪些状态
|状态|特点|切换|
|---|---|---|
|RUNNING|1、接收新任务<br/>2、处理任务|线程池初始化状态即RUNNING，调用shutdown方法，可以从RUNNING转化成SHOWDOWN状态|
|SHUTDOWN|1、处理任务<br/>2、不接收新任务|RUNNING状态下，调用shutdown方法可以切换到该状态|
|STOP|1、不接收新任务<br/>2、停止处理任务<br/>3、中断正在处理的任务|RUNNING或者SHUTDOWN状态下，调用shutdwonNow方法，可以切换到STOP状态|
|TIDYING|1、啥都不干|1、SHUTDOWN状态时，任务队列为空且线程池中的任务为空，会从SHUTDOWN切换到TIDYING<br/>2、STOP状态时，线程池中的任务为空，会从STOP状态切换到TIDYING|
|TERMINATED|线程彻底终止|TIDYING状态时，执行完terminated方法（线程池终止前的回调方法，执行完之后就终止线程池）后，会从TIDYING切换到TERMINATED|

## 线程池中submit和execute方法区别
||submit|execute|
|---|---|---|
|参数|1、Runnable<br/>2、Callable|Runnable|
|异常捕获|通过Future的get方法从submit返回值中获取|只能抛出运行时异常|
|返回值|有返回值|无返回值|

## 如何保证多线程运行安全？
|需要遵循的方面|简介|
|---|---|
|原子性|互斥操作，同一时间只有一个线程操作数据，比如atomic、synchronized|
|可见性|一个线程对共享内存区域的修改可以及时被其他线程看到，使用synchronized、volatile|
|有序性|程序按照代码顺序执行|

## 多线程线程锁升级原理
|锁级别|存在情况|
|---|---|
|无锁|没有线程申请锁|
|偏向锁|只有一个线程申请锁|
|轻量级锁|有多个线程竞争锁且获取锁时间较短|
|重量级锁|有多个线程竞争锁且获取锁时间较长|

## 什么是死锁？
多个线程进入互相等待彼此释放锁，而彼此又不释放锁的状态，即死锁

## 防止死锁
1、按合适顺序获取锁
2、设置获取锁有限等待时间

## ThreadLocal 是什么？使用场景？
|||
|---|---|
|简介|线程私有化存储管理类
|使用场景|希望线程能私有化访问操作的数据|

## synchronized 底层实现原理？
通过对象头中锁标记、线程标记等记录，JVM根据竞争锁的情况来回切换四种锁状态实现的

## synchronized 和 volatile 区别
||synchronized|volatile|
|---|---|---|
|作用|锁定对象只能由一个线程访问操作|告诉JVM读取变量值时需要实时从主内存中读取|
|作用对象|变量、类、方法、代码块|变量|
|可见性、原子性|可见性、原子性|可见性|
|编译器优化|有|无|

## synchronized 和 Lock 区别
||synchronized|Lock|
|---|---|---|
|作用|锁定对象只能由一个线程读写|
|核心区别|简单同步操作，实现简单，功能简单，锁操作由JVM本身完成，使用位置更多，全自动|提供更多锁相关功能，赋予程序员有更多管理锁能力，适合复杂情况，只能在方法内使用，半自动|

## synchronized 和 ReentrantLock 区别
||synchronized|ReentrantLock|
|---|---|---|
|作用|锁定对象只能由一个线程读写|
|核心区别|使用简单，适合简单场景，由JVM完成锁操作，全自动|使用复杂，适合复杂场景，开放更多自定义与管理锁能力，半自动，是Lock接口的一个实现|

## atomic 原理
|||
|---|---|
|作用|多线程环境中同时只允许一个线程写被修饰变量|
|实现原理|基于CAS操作，即写变量时，会先创建两个变量，且赋值为该变量值，一份用作一会比对，一份用于执行写计算，当执行完写计算后，将用来比对的部分与原始变量值比对，若值未变化，则将计算后的值赋给原始变量|
