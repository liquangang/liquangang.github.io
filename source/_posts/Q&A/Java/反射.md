---
title: 反射
date: 2022-03-24 19:17:28
tags: Q&A
categories:
- [Q&A, Q&A-java]
---

### 什么是反射？
* 定义：即Reflection，意思是在程序运行期间拿到对象的所有信息
* 作用：为了解决在运行期间，对某个对象一无所知的情况下，调用其方法

### 什么是 java 序列化？什么情况下需要序列化？
* 名词定义：
  * 序列化：将java对象转换成字节流的过程
  * 反序列化：将字节流转换成java对象的过程
* 序列化场景：
  * 将java对象持久化
  * 在网络中传输java对象

### 动态代理是什么？有哪些应用？
* [参考文章](https://www.yukx.com/jing/article/details/1453.html)
* 代理：代理类与委托类具有相同接口，即代理类需要实现委托类规定的接口，跟OC delegate一样，代理类按照委托类的规定做一些预处理，事后处理等操作
* 代理分类：
  * 静态代理：使用自己创建的特定代理类，即需要实际编写代理类，在编译器就确定好代理类的情况
  * 动态代理：运行时动态创建代理类，实现只需要编写好某个被代理方法的处理逻辑即可
* 应用场景：
  * 编写一些三方工具库，比如spring AOP、RPC
  * 想在已有行为执行前后添加逻辑


### 怎么实现动态代理？
* 实现过程（以示例举例）：
  1、创建接口类（Person接口）、被代理类（Student）、被代理方法处理类（StuInvocationHandler<T>，该类中加入新增逻辑），
  2、创建一个被代理对象，创建被代理方法处理类的对象，然后使用该对象创建一个代理对象，然后使用代理对象调用代理方法即可


* 代码示例：
```
import org.junit.jupiter.api.Test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class MyTest {


    /** * 创建Person接口
     * @author Gonjan
     */
    public interface Person {
        //上交班费
        void giveMoney();
    }

    public class Student implements Person {
        private String name;
        public Student(String name) {
            this.name = name;
        }
        @Override
        public void giveMoney() {
            System.out.println(name + "上交班费50元");
        }
    }

    public class StuInvocationHandler<T> implements InvocationHandler {
        //invocationHandler持有的被代理对象
        T target;
        public StuInvocationHandler(T target) {
            this.target = target;
        }
        /**
         * proxy:代表动态代理对象
         * method：代表正在执行的方法
         * args：代表调用目标方法时传入的实参
         */
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("代理执行" +method.getName() + "方法");
            //代理过程中插入监测方法,计算该方法耗时
            System.out.println("我是在被代理方法执行前的部分");
            Object result = method.invoke(target, args);
            System.out.println("我是在被代理方法执行后的部分");
            return result;
        }
    }


    @Test
    public void testMyCode() {
        //创建一个实例对象，这个对象是被代理的对象
        Person zhangsan = new Student("张三");
        //创建一个与代理对象相关联的InvocationHandler
        InvocationHandler stuHandler = new StuInvocationHandler<Person>(zhangsan);
        //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法
        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),
                new Class<?>[]{Person.class}, stuHandler);
        //代理执行上交班费的方法
        stuProxy.giveMoney();
    }
}

```
