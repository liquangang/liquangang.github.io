---
title: 反射
date: 2022-03-24 19:17:28
tags: Q&A
categories:
- [Q&A, Q&A-java]
---

## 什么是反射
|||
|---|---|
|反射定义|运行时程序可以拿到对象的所有信息|
|Java反射应用|运行时，对对象一无所知情况下，调用对象属性、方法|

## 什么是java序列化？什么情况下需要序列化？
|||
|---|---|
|序列化定义|对象转换成字节流过程|
|序列化使用场景|1、持久化对象<br/>2、在网络中传输对象|

## 动态代理是什么？使用场景
|||
|---|---|
|代理作用|在已有行为前后增加额外操作|
|代理类|代理类按照委托类实现一些既定接口|
|静态代理、动态代理区别|1、程序员编写内容不同，静态代理需要编写代理类，动态代理不需要编写代理类，但是需要编写代理方法执行前后的操作内容，即InvocationHandler<br/>2、内部实现不同，静态代理的代理对象就是程序员定义的代理类的实例，动态代理是代理接口的实例，静态代理对象调用方法时是直接调用到代理方法，然后再调用被代理对象中的方法，而动态代理是先转发给handler方法，然后再handler方法中使用反射调用被代理方法<br/>3、两种方式代码可维护性、可复用程度不同，静态代理比较简单，但可复用程度不高，动态代理同一个handler可以实现代理多个被代理方法，可复用程度高|
|静态代理定义|编译期即确定代理类，所以需要提前由程序员编写好代理类|
|动态代理定义|运行时确定代理类，程序员只需要编写好被代理方法执行前后的操作即可，即不需要编写代理类|
|使用场景|各种三方库、日志模块等较多采用该技术实现|

## 动态代理如何实现
### 实现过程
1、定义委托类、委托方法、动态代理类的新增操作（即InvocationHandler）
2、构造委托对象，构造新增操作对象，构造代理对象并关联委托对象和新增操作对象，然后使用代理对象调用委托方法

### 代码示例
```
import org.junit.jupiter.api.Test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class MyTest {

    /** * 创建Person接口
    * @author Gonjan
    */
    public interface Person {
       //上交班费
       void giveMoney();
       void getSchool();
    }

    public class Student implements Person {
       private String name;
       public Student(String name) {
           this.name = name;
       }
       @Override
       public void giveMoney() {
           System.out.println(name + "上交班费50元");
       }

       @Override
       public void getSchool() {
           System.out.println(name + "是北大的");
       }
    }

    /**
    * 静态代理类实现
    */
    public class StudentProxy implements Person {
       private Student student;

       public StudentProxy(Student student) {
           this.student = student;
       }

       @Override
       public void giveMoney() {
           System.out.println("我是在被代理方法执行前的部分");
           this.student.giveMoney();
           System.out.println("我是在被代理方法执行后的部分");
       }

       @Override
       public void getSchool() {
           System.out.println("我是在被代理方法执行前的部分");
           this.student.getSchool();
           System.out.println("我是在被代理方法执行后的部分");
       }
    }

    @Test
    public void testStaticProxy() {
       Student student = new Student("小明");
       StudentProxy studentProxy = new StudentProxy(student);
       studentProxy.getSchool();
       studentProxy.giveMoney();
    }


    /**
    * 动态代理
    */
    public class StuInvocationHandler<T> implements InvocationHandler {
       //invocationHandler持有的被代理对象
       T target;

       public StuInvocationHandler(T target) {
           this.target = target;
       }

       /**
        * proxy:代表动态代理对象
        * method：代表正在执行的方法
        * args：代表调用目标方法时传入的实参
        */
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("代理执行" + method.getName() + "方法");
           //代理过程中插入监测方法,计算该方法耗时
           System.out.println("我是在被代理方法执行前的部分");
           Object result = method.invoke(target, args);
           System.out.println("我是在被代理方法执行后的部分");
           return result;
       }
    }


    @Test
    public void testMyCode() {
       //创建一个实例对象，这个对象是委托对象
       Person zhangsan = new Student("张三");
       //创建一个与代理对象相关联的InvocationHandler
       InvocationHandler stuHandler = new StuInvocationHandler<Person>(zhangsan);
       //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法
       Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),
               new Class<?>[]{Person.class}, stuHandler);
       //代理执行上交班费的方法
       stuProxy.giveMoney();
       stuProxy.getSchool();
    }
}

```
