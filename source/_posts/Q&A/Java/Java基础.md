---
title: Java基础
date: 2022-05-19 20:24:10
tags: Q&A
categories:
- [Q&A, Q&A-java]
---

## 解释下什么是面向对象？面向对象和面向过程的区别？
|||
|---|---|
|什么是面向对象|把现实中需要解决的问题，抽象成类的属性和行为的一种编程思想|
|面向过程、面向对象区别|都是编程思想，面向过程是直接编写解决问题的所有流程细节，面向对象是将问题抽象成类的属性或行为，然后调用对象的属性或行为来解决问题|

## 面向对象三大特性，分别解释下
|||
|---|---|
|继承|子类拥有父类的非private属性与行为，继承实现方式继承extens父类、实现implement接口|
|封装|将现实问题抽象封装成类的属性与行为|
|多态|不同对象的同一方法对应的行为不同，多态实现三个条件：继承、子类重写父类方法、父类引用指向子类对象|

## JDK、JRE、JVM
||JDK|JRE|JVM|
|---|---|---|---|
|全称|Java Developer Kit：Java开发工具包|Java Runtime Environment：Java运行时环境|Java Virtual Machine: java虚拟机|
|作用|提供Java开发环境，开发工具，用于开发java程序|提供java运行环境，用于运行java程序|用于解释执行java代码|
|联系|JDK=JRE+开发工具|JRE=JVM+Java se标准库||

## 重载、重写区别
|||
|---|---|
|重载|同类中相同函数名，形参不同|
|重写|子类重写父类同名方法|

## Java 中是否可以重写一个 private 或者 static 方法？
|||
|---|---|
|是否可以|不可以|
|private不能重写原因|该方法只能在当前类中使用|
|static不能重写原因|static在编译期已经确定，是绑定到类对象上的，不能绑定到类的实例对象上，重写也没用|

## 构造方法有哪些特性？
1、与类名相同
2、返回值为该类的对象，写代码时不需要声明返回值
3、不重写会有默认的无参构造方法

## 在 Java 中定义一个不做事且没有参数的构造方法有什么作用？
如果当前类和父类中没有任何构造函数的话，肯定会编译不过的，对象new不出来

## Java 中创建对象的几种方式？
1、new
2、反射
3、clone
4、序列化

## 静态变量、实例变量区别
|||
|---|---|
|静态变量|绑定到类对象上，使用static修饰，使用方式类名.静态变量名|
|实例变量|绑定到实例对象上，无特殊修饰词，使用方式实例对象名.实例变量名|

## short s1 = 1；s1 = s1 + 1；有什么错？那么 short s1 = 1; s1 += 1；呢？有没有错误？
|||
|---|---|
|short s1 = 1；s1 = s1 + 1；有什么错？|1默认是int，没有强转|
|short s1 = 1; s1 += 1；呢？有没有错误？|自带强转，不报错|

## Integer 和 int 的区别？
|||
|---|---|
|Integer|是int包装类，需要new才能使用，是一个引用类型，默认值null|
|int|基本数据类型，默认值0|

## 装箱和拆箱的区别
|||
|---|---|
|拆箱|把引用类型转成值类型，比如Integer->int|
|装箱|把值类型转成引用类型，比如int->Integer|

## switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？
|||
|---|---|
|回答|byte、string可以，long不可以|
|原理|能强转成int的以及string可以，其他不可以|

## final、finally、finalize 的区别
|||
|---|---|
|final|被修饰对象不变，修饰值类型，值不变，修饰引用，引用地址不变|
|finally|异常处理语句的一部分|
|finalize|对象销毁前的回调|

## == 和 equals 区别
||==|equals|
|---|---|---|
|作用|1、判断基本数据类型值是否相等<br/>2、判断引用类型引用是否相同|1、与==相同，判断基本数据类型值是否相等<br/>2、如果引用类型数据对应的类或者父类重写了equals方法，就执行重写的equals方法，否则与==相同，即判断引用是否相同|
|相同点|基本数据类型使用时都是判断值是否相等|
|不同点|引用类型==是判断引用是否相同，如果引用类型对应的类或者父类重写了equals方法，那么执行重写的equals，否则与==相同|

## hashcode相等，equals一定为true吗
不一定，不同字符串的hashcode存在相等情况，但equals是false，哈希算法决定，存在不同值的hash值相等的可能性

## 为什么重写 equals() 就一定要重写 hashCode() 方法？
Object规范决定的，对于同时会使用这两个方法的类，就必须要进行同时重写，比如hashMap等类，如果重写了equals，没有重写hashcode的话，会出现两个不equals的对象的hashcode相等，导致对象无法存入hashmap的现象发生

## & 和 && 的区别？
|||
|---|---|
|&|按位与，非短路运算符，两边都计算结果，最终确定结果|
|&&|逻辑与，短路运算符，左侧能给出最终结果的话，就不执行右侧计算|

## Java 中的参数传递时传值呢？还是传引用？
|||
|---|---|
|答案|值传递|
|原理|拷贝一份参数在内存中的值传递过去，基本数据类型就是它的值的拷贝，引用类型就是内存中的地址的拷贝|

## 如何实现对象的克隆？
1、clone方法
2、序列化反序列化

## 深克隆和浅克隆的区别？
|||
|---|---|
|浅拷贝|只拷贝一个引用|
|深拷贝|拷贝一个引用以及内存中的全部数据|

## 什么是 Java 的序列化，如何实现 Java 的序列化？什么情况下需要序列化？
|||
|----|---|
|什么是java序列化|内存中的对象转换成字节流的过程|
|如何实现序列化|实现序列化接口|
|序列化用途|1、持久化内存中的对象<br/>2、内存中的对象在网络中传输|

## Java 的泛型是如何工作的 ? 什么是类型擦除 ?
|||
|---|---|
|泛型如何工作|泛型是一种参数化类型，包含泛型类、泛型方法、泛型接口，类型擦除即编译期将变量类型擦除，保证编译通过，运行时确定类型|
|泛型目的|提高代码重用度|

## 什么是泛型中的限定通配符和非限定通配符 ?
|||
|---|---|
|这俩是什么玩意|描述泛型类型限制|
|限定通配符|<T>：必须是T|
|非限定通配符|<? extens T>：T或T的子类<br/><? super T>：T或T的父类|

## Java 中的反射是什么意思？有哪些应用场景？
|||
|---|---|
|反射定义|运行时获取对象信息的一种方式|
|应用|运行时获取对象信息，比如Spring中的ioc能力、mvc模块，jdbc与mysql建立链接等，总之就是另一种使用类功能的方式|

## 反射的优缺点？
|||
|---|---|
|优点|增加灵活性、拓展性，降低耦合，方便编写各种框架|
|缺点|1、性能较差<br/>2、可读性较差<br/>3、可能存在安全问题|

## Java 中的动态代理是什么？有哪些应用？
|||
|---|---|
|代理|在不改动已有代码情况下，在其前后增加功能|
|动态代理|不需要提前编写代理类，运行时确定代理类的一种形式|
|应用|AOP、注解、事务、日志等框架|

## 实现动态代理
1、定义委托类、委托方法、Invocationhandler
2、构造委托对象，构造Invocationhandler对象并绑定委托对象，构造代理对象并绑定Invocationhandler，使用代理对象调用委托方法即可

## static 关键字的作用？
被修饰对象在编译期即可确定，被修饰对象只能使用类对象调用

## super 关键字的作用？
用于在子类中使用父类功能

## 字节和字符的区别？
|||
|---|---|
|字节|存储单位，1字节=8位|
|字符|描述信息的符号|

## String 为什么要设计为不可变类？
1、线程安全
2、符合常量池设计
3、hashcode保持唯一

## final作用
|||
|---|---|
|总结|final即最终的意思，即被修饰的内容不能变，如果被修饰的是一个引用，那就是引用不能变，但引用的对象可以变|
|类|不能被继承|
|方法|不能被重写|
|变量|必须初始化，之后不能修改，基本数据类型会变成常量，引用类型引用不能变，但引用对象属性可以变|

## Math.round(-1.5) 结果
Math.round()作用是四舍五入取整，所以结果-1

## String属于基础数据类型吗？
不属于，string是引用类型，是对象，基础数据类型是byte、boolean、char、short、int、long、float、double

## java中操作字符串的类，它们的区别
||String|StringBuffer|StringBuilder|
|---|---|---|---|
|是否可变|不可变|可变|可变|
|线程安全|安全|安全|不安全|
|性能|高|较低|较高|
|使用场景|使用字符串常量时|多线程编辑字符串|单线程编辑字符串|

## String str = "i" 和String str = new String("i") 一样吗？
不一样，String str = "i" str指向的是常量池中的某块内存，String str = new String("i") 中的str指向的堆内存的某块区域

## String 字符串修改实现的原理？
引用指向新字符串

## final 修饰 StringBuffer 后还可以 append 吗？
可以，final的是引用，引用指向的内容随便改

## 字符串反转
1、倒序遍历向另一个字符串中写
2、使用StringBuffer和StringBuilder中的reverse方法

## String类常用方法
|常用方法|作用|
|---|---|
|indexOf()|返回指定字符索引|
|charAt()|返回指定索引处字符|
|replace()|替换字符串|
|trim()|去除字符串两端空白|
|split()|分割字符串|
|getBytes()|返回字符数组|
|length()|字符串长度|
|toLowerCase()|转换小写字母|
|toUpperCase()|转换大写字母|
|subString()|截取字符串|
|equals()|判断字符串内容是否相同|

## 什么是抽象类
|||
|---|---|
|简介|包含抽象方法或者被abstract修饰的类，由于抽象方法没有方法体，所以没有足够信息描述类属性的类|
|作用|把一些列关联的必须实现的抽象方法集合到一个抽象类中，用来让子类实现相关的方法体，保证所有子类具有相同的功能|
|特点|1、被abstract修饰<br/>2、不一定包含抽象方法<br/>3、不能被实例化<br/>4、只能通过使用实现子类来使用<br/>5、非抽象子类必须实现全部抽象方法|

## 什么是抽象方法
|||
|---|---|
|简介|被abstract修饰的方法，不包含方法实现的|
|作用|为了被子类继承后自己实现方法体|
|特点|1、只能被public或者protected修饰，默认public<br/>2、对应的类一定是抽象类<br/>3、不能声明构造方法为抽象方法<br/>4、没有方法体|

## 抽象类必须要有抽象方法吗？
抽象类不必须有抽象方法，但是有抽象方法的类一定是抽象类

## 普通类、抽象类区别？
||普通类|抽象类|
|---|---|---|
|是否包含抽象方法|不能|可能包含，不要求一定包含|
|是否可以实例化|可以|不能|

## 抽象类能使用 final 修饰吗？
不能，final修饰的类不能被继承，而抽象类本身不能被实例化，必须要被子类继承才能实例化使用，被final修饰之后就没用了，按照关键字的要求的话，就无法使用该抽象类了，所以final跟抽象类本身就存在矛盾

## 接口、抽象类区别
||接口|抽象类|
|---|---|---|
|实现关键字|implement|extentds|
|构造函数|不能包含|可以有，注意抽象方法不能写实现|
|main方法|不能有|可以有|
|其他类实现区别|可以实现多个接口|只能继承一个抽象类|
|方法默认访问权限|默认与允许public，不允许private、protected|默认protected，允许protected和public，非抽象方法与正常类相同，抽象方法不允许private|
|方法是否需要实现|不需要全部实现|如果子类的不想当抽象类，就必须实现全部抽象方法|

## Java 中的 IO 流的分类？说出几个你熟悉的实现类？
|分类标准|分类|
|---|---|
|按流向分|输入流（InputStream）、输出流（OutputStream）|
|按类型分|字节流（InputStream、OutputStream）、字符流（Reader、Writer）|
|按功能分|缓冲流（BufferInputStream、BufferOutputStream）、打印流（PrintStream）、转换流（InputStreamReader、OutputStreamWriter）|刘

## 字节流和字符流有什么区别？
|||
|---|---|
|字节流|不需要缓冲区，读写单位是一个字节|
|字符流|需要缓冲区，读写单位是一个unicode码|

## BIO、NIO、AIO 有什么区别？
||BIO|NIO|AIO|
|---|---|---|---|
|全称|Block IO，同步阻塞式IO|New IO，同步非阻塞式IO|Asynchronous IO，NIO升级版，异步非阻塞IO|
|特点|模式简单，使用方便，并发能力低|多路复用|适合高并发|
|使用场景|并发要求低，连接数少且架构稳定的情况|适合高负载、高并发、连接数多、时间短|适合高负载、高并发、连接数多、时间长|

## Files常用方法
* exists(): 判断文件是否存在
* createFile(): 创建文件
* createDirectory(): 创建文件夹
* delete(): 删除文件或者文件夹
* copy(): 复制文件
* move(): 移动文件
* size()：文件夹文件数量
* read()：读取文件
* write(): 写入文件
