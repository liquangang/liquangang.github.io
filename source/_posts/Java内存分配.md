---
title: Java内存分配
date: 2021-08-31 11:14:46
tags: 编程
categories:
- [Java, Java基础]
---

### 内存区域、内存模型
* 内存区域：即运行时数据区域，指JVM对于不同类型数据在内存中的存储方式
* 内存模型（JMM：Java Memory Model）：定义了线程与主内存之间的抽象关系，即JVM在内存中的工作方式，即JVM使用内存区域中的数据的方式

### JDK8之后的内存区域：
```
* Native Method Stacks（本地方法栈）
* Program Counter Register（程序计数器）
* Java Virtual Machine Stacks（JVM Stacks，即虚拟机栈）
    * Stack Frame（栈帧）
        * 局部变量表
        * 操作栈
        * 动态连接
        * 方法返回地址
    * Stack Frame（栈帧）
        * 局部变量表
        * 操作栈
        * 动态连接
        * 方法返回地址
* Heap（堆区）
    * Young区（新生代）
        * Eden
        * S0
        * S1
    * Old区（老年代）
* Metaspace（元数据区）
    * Runtime Constant Pool（运行时常量池）
    * Method Area（方法元信息）
    * klass类元信息
* CodeCache（JIT编译产物） 
```

### Program Counter Register (程序计数器)
* 作用：当前线程所执行的字节码的行号指示器，当多线程切换时，使线程恢复后找到正确的执行位置
* 特点：
    * 内存占用少
    * 线程私有
    * 当前线程执行Java方法，计数器保存虚拟机中字节码指令地址；执行Native方法，记录null
    * 唯一一个在JVM规范中没有规定OutOfMemoryError的区域
   
### JVM Stacks
* 概念：
    * 活动线程：当前正在执行的线程
    * 当前帧：正在执行的方法对应的栈帧，由于只有栈顶帧有效，所以当前帧也是栈顶帧
    * 当前方法：正在执行的方法
* 简介：描述了Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame：栈中的一个元素，方法运行时的基础数据结构），存储局部变量表，操作数栈、动态连接、方法出口等。每一个方法从调用到执行完的过程，对应一个栈帧入栈出栈过程
* 作用：保存Java方法执行的时候需要的各种数据、参数
* 特点：
    * 线程私有
    * 生命周期与线程相同
    * 执行引擎运行时，所有指令都只能对当前帧操作
    * 一个方法对应一个栈帧
* 组成：
    * #### Stack Frame（栈帧）：
        * 介绍：一个栈帧对应一个方法执行需要的数据
        * JVM规定的与栈帧相关异常：
            * 线程请求的栈深度大于JVM允许的深度，抛出StackOverflowError
            * 对于当前大多数可以拓展的JVM栈，在拓展时申请不到足够内存，抛出OutOfMemoryError
        * 组成：
            * #### 局部变量表
                * 作用：存放方法参数和局部变量，字节码指令中的STORE指令就是将操作栈中计算完成局部变量写到当前帧的局部变量表中
                * 特点：
                    * 必须显示初始化，才能使用
                    * 如果是非静态方法，会在index[0]位置存储方法所属对象的实例引用，占用4字节，后面存储方法参数和局部变量
            * #### 操作栈
                * 作用：用于方法执行过程中信息的存取
                * 简介：JVM的执行引擎是基于栈的执行引擎，其中的栈即操作栈，方法执行时，使用操作栈进行存取信息
                * 关联：
                    * 字节码指令集即基于栈类型，栈深度保存在方法元信息的栈属性中
                    * 例：
                        * ++i：总体思路是按顺序执行，先将局部变量表中的i执行加1操作（load memory&add&store memory），然后放到操作栈中(load memory)，此时从操作栈栈顶取出的i就是加1之后的
                        * i++：按照按顺序执行的思路，先将i放到操作栈中(load memory)，然后执行加1的操作(add memory)，加1之后的值更新到局部变量表中(store memory)，此时从栈顶读取到的i未加1，所以如果多线程操作i的时候，可能从局部变量表读到的i比预期的小
                * 特点：
                    * 初始状态为空桶式结构栈
            * #### 动态连接
                * 介绍：每个栈帧中包含一个在常量池中对当前方法的引用，目的是为了支持方法调用过程的动态连接
            * #### 方法返回地址：
                * 方法执行退出情况：
                    * 正常退出，遇到返回字节码指令，比如return、ireturn、areturn
                    * 异常退出
                * 介绍：即方法调用完成返回的位置，方法调用完成后会弹出当前栈帧
                * 退出后行为：
                    * 返回值压入上层调用栈帧 
                    * 异常抛给能处理的栈帧
                    * 程序计数器指向方法调用后的下一条指令    
        
### Native Method Stacks(本地方法栈)
* 介绍：与JVM Stacks类似，但保存的是Native方法对应的栈帧
* 特点：
    * 也会抛出StackOverFlowError和OutOfMemoryError
    * 线程调用本地方法时，不受JVM约束
    * 本地方法通过JNI(Java Native Interface)来访问JVM的数据，可以调用寄存器，具有JVM相同的能力、权限
    * 大量本地方法运行时，会削弱JVM对系统控制力，本地方法出错信息比较黑盒
    * 本地方法栈会在内存不足时抛出NativeHeapOutOfMemory

### Heap（堆）
* 介绍：存放对象实例，几乎所有的对象实例都在这里分配内存
* 特点：
    * 对大多数应用来说，Heap是JVM管理内存中最大的一块
    * 被所有线程共享
    * 虚拟机启动时创建
    * GC管理的主要区域，有时候也成Heap为GC Heap
    * 内部可能包含多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）
    * 可以由物理上不连续的内存空间组成，只要逻辑上连续即可
    * 当堆中无内存完成实例分配，并且无法拓展时，会抛出OutOfMemoryError
* 按照GC中的分代回收算法分类：
    * 新生代
        * Eden
        * S0
        * S1
    * 老年代 
            
### Metaspace（元数据区）
* 组成：
    * #### Method Area（方法区）
        * 特点：
            * 线程共享
            * 存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
            * JVM对该区域限制非常松，可选择不实现垃圾回收
            * 垃圾回收在该区域出现少，主要是回收运行时常量池和类元信息
            * 当方法区无法满足内存分配需求时，抛出OutOfMemoryError
            
    

