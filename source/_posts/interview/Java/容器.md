---
title: 容器
date: 2021-12-06 16:34:38
tags: 面试
categories:
- [interview, interview-java]
---

## 容器简介
* 作用：持有和增删对象
* 分类：
  * Collection：一个独立元素组成的队列，这些元素都遵守一个或多个相同的规则
  * Map：一组由成对的“键值对”组成的对象

## Collection：一个接口，定义了对集合对象操作的通用方法
### 介绍：
* java.util.Collection是一个接口，定义了对集合对象操作的一些通用方法
* java本身没有直接提供Collection的实现类，而是提供了Collection的接口子类，比如List和Set
* 关联类：Collections，一个都是静态方法的工具类，且该类不能被实例化（构造方法私有了）


### 组成类：
  * List
    * LinkedList
    * ArrayList
    * Vector
      * Stack
  * Set
    * HashSet
    * TreeSet
    * LinkedHashSet

### Collection主要方法：
  * boolean addObject(Object o): 添加元素到集合
  * boolean removeObject(Object o): 从集合中删除某个元素
  * int size(): 集合中元素数量
  * boolean contains(Object o): 查找集合中是否包含某个元素
  * boolean isEmpty：判断集合中是否为空
  * Iterator iterator(): 返回一个迭代器
  * boolean containsAll(Collection c): 判断是否包含另一个集合中的全部元素
  * boolean addAll(Collection c)：将另一个集合里面的所有元素添加到当前集合中
  * void clear(): 删除集合中所有元素
  * void removeAll(Collection c)：从当前集合中删除c中的所有元素
  * void retainAll(Collection c)：从当前集合中删除c中没有的元素


### List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组
  * 数组和list区别：
    * 数组是静态的，即长度固定，且所有元素保存在一块连续的内存区域中，list的长度可变
    * 数组是多维，list的实现类ArrayList是一维
    * 数组是java中最基本的数据结构，没有类对应，list本身是一个接口类，list有实现类ArrayList等，即ArrayList功能比Array多
    * list的实现类ArrayList即基于数组实现
  * 实现类：ArrayList、LinkedList、Vector、Stack
  * LinkedList（链表）：即java的链表，有单向和双向链表
    * 特点：相比ArrayList，适合增删操作，不适合修改和查找
    * 使用场景：适合通过循环迭代使用某些元素，适合在表中任意位置增删元素
    * 注意：LinkedList没有同步方法，多线程访问时需要自己实现访问同步，使用Collections.synchronizedList可以创建一个同步list解决
  * ArrayList（可变数组）：即java的可变数组
    * 特点：非同步，跟LinkedList一样
    * 使用场景：适合快速访问任一元素，适合在表尾执行增删操作
  * Vector：类似ArrayList，但是是同步的
  * Stack：继承Vector，即现金后出的堆

### Set：不包含重复元素的Collection，最多有一个null元素
* 实现类：HashSet、LinkedHashSet、TreeSet
* HashSet：基于HashMap实现，一个不包含重复元素的无序集合，非线程安全
* TreeSet：基于TreeMap实现，一个有序不包含重复元素的集合
* LinkedHashSet：继承于HashSet，一个按照插入顺序排序的有序且不包含重复元素的集合



## Map：一组key-value集合
### 组成类
  * HashMap
  * TreeMap
  * HashTable
  * WeakHashMap
  * ConcurrentHashMap
  * LinkedHashMap

### 主要方法
* boolean equals(Object o)：比较两个对象是否相等
* boolean remove(Object o)：删除对象
* put: 向map中添加key-value
* size：map中key-value个数

### ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap

### HashMap: 非同步，无序，允许key、value为null的map

### WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收

### TreeMap：依据比较规则对key进行排序的map

### LinkedHashMap：一个有序的HashMap

## 相关面试题
### Collection 和 Collections 有什么区别
* Collection是一个接口，给集合操作提供一些基础功能方法，Collections是一个均为静态方法的集合工具类，两者均不能实例化

### List、Set、Map 之间的区别是什么？
* List和Set是集合，是一堆元素按照一定规则或者无规则的容器，Map内部的元素形式是Key-value
* List内部元素是可以重复的，Set内部元素不能重复，Map内部Key不能重复，value可以重复
* List和Set都继承Collection，Map没有父接口类

### HashMap 和 HashTable 有什么区别？
* HashTable官方已经淘汰，使用非常相似的ConcurrentHashMap替代
* HashTable是线程安全，支持同步访问，HashMap不支持同步访问，其他方面就比较像

### 如何决定使用 HashMap 还是 TreeMap？
* 需要根据key进行排序的情况下使用TreeMap，其余情况下建议HashMap，HashMap性能较好


### HashMap 的实现原理？

#### JDK7和JDK8中HashMap实现的差别
  * 1.7采用的是数组+链表，1.8采用的是数组+链表/红黑树
  * 1.7扩容时需要重新计算哈希值和索引位置，1.8不需要重新计算哈希值，巧妙的采用和扩容后容量进行&操作来计算新的索引位置
  * 1.7是采用表头插入法插入链表，1.8采用是尾部插入法
  * 1.7中采用表头插入法，在扩容时会改变链表中元素顺序，以至于在并发场景下会导致链表成环问题，在1.8中采用的尾部插入法，在扩容时不会改变链表中元素顺序，所以就没有该问题

#### HashMap组成?
* hashMap使用数组+链表的方式来存储数据，数组元素为Entry组成的链表，当链表长度大于8的时候，JDK1.8会将链表转成红黑树

#### Hash冲突如何解决?
* 当两个不同的key进行hash后取得的下标相同时，就会将这两个key-value放到对应的数组下标中的链表中

#### HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用?
* 使用LinkedList替换数组实现HashMap是否可行，然后为什么不会用：当然可行
* 数组的查找效率比LinkedList高，LinkedList是使用链表实现的
* ArrayList底层也是使用数组实现，但是由于扩容机制问题，不利于HashMap的取模运算，HashMap中的数组扩容时2倍扩容，ArrayList是1.5倍扩容

#### HashMap查找key的位置
* 首先对key进行hashCode，同时使用HashMap对应的数组长度进行取余等操作找到对应的数组下标之后，再在这个下标对应的链表中查找

#### HashMap扩容
* 创建一个2倍容量的数组，将原数组的元素散列后放到新数组中
