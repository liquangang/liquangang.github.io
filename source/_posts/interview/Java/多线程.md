---
title: 多线程
date: 2022-01-17 20:40:20
tags: 面试
categories:
- [interview, interview-java]
---

### 并行和并发有什么区别？
#### 并发：
* 在操作系统中，一个时间段内在同一个处理机上处于开始到结束之间的多个任务之间的状态，window的时间片分时调度即并发，实际是串行，但是多个任务在不停地切换，每个任务运行一小会，以实现多个任务的同时运行即并发

#### 并行：
* 互不抢占资源的两个任务同时运行时，即并行

#### 区别：
* 并发实际上是串行
* 并发需要共享运算资源，并行不需要
* 单cpu可以实现并发，但不能实现并行
* 并行是真正的同时运行


### 线程和进程的区别？
#### 线程：
* 是进程的子任务
* 是操作系统可识别的最小执行和调度单位
* 是CPU调度和分配的基本单位

#### 进程：
* 是对运行时程序的封装
* 是系统进行资源调度和分配的基本单位

#### 区别：
* 一个线程只能属于一个进程，一个进程可以包含多个线程，且至少有一个线程
* 进程用友独立的内存单元，多个线程共享这部分内存
* 进程是资源分配的最小单位，线程是cpu调度的最小单位
* 创建、撤销、切换等操作，进程的开销要远大于线程
* 线程间可以使用共享内存进行通信，实现起来较简单，进程间通信实现较复杂，进程间通信依赖线程
* 进程间互相不会影响，线程挂掉时会导致整个进程挂掉

### 进程间通信方式？
* 管道：
  * 匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系
  * 高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
  * 有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
* 消息队列
* 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
* 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
* 共享内存：
* 套接字

### 线程间通信方式？
* 各种锁：互斥锁
* 信号量：
* 信号：
* 进程间通信也能用于线程间通信，进程间通信本质上都是线程在干活

### 守护线程是什么？
#### 定义:
* 为其他线程服务的线程，比如垃圾回收线程

#### 特点：
* JVM结束进程时，不关心守护线程，但是用户线程存在的话，JVM不会结束进程
* 守护线程不能持有任何需要关闭的资源，进程结束时会导致该资源出错
* 守护线程优先级低，守护线程中创建的新线程同样是守护线程，用户线程同样，其中创建的新线程也是用户线程

### 线程分类?
#### 按照是否为用户自定义来区分
* 守护线程
* 用户线程

### 创建线程有哪几种方式？
* 本质上都是一样的，都需要new thread
* 继承Thread类，重写run方法
* 通过实现Runnable接口中的run方法
* 通过实现Callable接口中的call方法，然后使用FutureTask进行调用
```
    @Test
    public void testCode() throws ExecutionException, InterruptedException {
        FutureTask<Integer> futureTask = new FutureTask<>(new TestThread());
        new Thread(futureTask).start();
        Integer result = futureTask.get();
        System.out.println(result);
    }

    class TestThread implements Callable<Integer> {

        @Override
        public Integer call() throws Exception {
            System.out.println("啦啦啦啦");
            return 1;
        }
    }
```
* 通过线程池创建线程：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式
  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限
  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限
  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务
  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程


### 说一下 runnable 和 callable 有什么区别？
* 相同点：
  * 都是接口
  * 都可以实现多线程
  * 都采用thread.start启动
* 不同：
  * Runnable的run方法没有返回值，Callable的call方法可以自定义返回值
  * Runnable的run方法只能抛出运行时一场，且无法捕获，Callable的run方法允许抛出异常，且可以捕获
  * Executor使用Runnable使用execute方法，使用Callable时使用submit方法

### 线程有哪些状态？
* new：创建
* Runnable：运行中，正在执行run方法
* Blocked： 运行中，因被阻塞而挂起
* Waiting：运行中，因为某些操作在等待中，join方法会阻塞当前线程，等待该线程对象执行完成，如果已完成，就立即返回
* Timed Waiting：运行中，因为执行sleep，在计时等待
* Terminated：终止，run方法执行完毕或调用Thread的stop

### sleep() 和 wait() 有什么区别？
* 调用方面：
  * sleep是静态方法，wait是实例方法
  * wait只能在同步情况下调用，sleep不需要
  * wait是用于线程间通信的，sleep是用于当前线程
* 锁及资源：
  * 线程进入wait状态时会释放持有的对象锁，但sleep不会
  * 进入wait状态的线程使用notify和notifyAll可以再次唤醒，进入sleep状态的线程不能被唤醒
* 异常捕获：
  * sleep需要捕获或者抛出异常，wait/notify/notifyAll不需要

### notify()和 notifyAll()有什么区别？
* notify唤醒对象的等待池中的一个线程进入锁池，notifyAll唤醒等待池中的所有线程进入锁池
* 等待池：线程A调用了对象o的wait方法，A就会释放o的锁，进入o的等待池，等待池中的线程不会竞争o的锁
* 锁池：获取了对象o的锁，才能执行synchronized代码，同一时间内，只有一个线程可以获得该锁，其他线程只能在锁池中等待，锁池中的线程会竞争对象锁，等待池中的线程不会

### 线程的 run()和 start()有什么区别？
* run里面是线程需要计算的内容，start就是创建新线程然后调用一下run，基于此区别自己说就好了

### 创建线程池有哪几种方式？
* 使用Executors创建线程池：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式
  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限
  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限
  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务
  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程
* 通过ThreadPoolExecutor创建自定义线程池

### 线程池都有哪些状态？
* running：接收新任务，处理队列任务
* shutdown：停止接收新任务，处理队列任务
* stop：停止接收新任务，停止处理队列任务，停止正在处理的任务
* tidying：所有任务被终结，有效线程为0，会触发terminated方法
* terminated：当terminated执行结束，销毁状态

### 线程池中 submit()和 execute()方法有什么区别？
* 同
  * 都是线程池的方法
* 异
  * execute只能传入Runnable任务，submit可以传入Runnable和Callable任务
  * execute会直接抛出异常，submit会吃掉异常，但是可以通过future的get方法将异常重新抛出
  * execute所属顶层接口是Executor，submit所属顶层接口是ExecutorService 

### 在 java 程序中怎么保证多线程的运行安全？

### 多线程锁的升级原理是什么？

### 什么是死锁？

### 怎么防止死锁？

### ThreadLocal 是什么？有哪些使用场景？

### 说一下 synchronized 底层实现原理？

### synchronized 和 volatile 的区别是什么？

### synchronized 和 Lock 有什么区别？

### synchronized 和 ReentrantLock 区别是什么？
