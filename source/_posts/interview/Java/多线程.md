---
title: 多线程
date: 2022-01-17 20:40:20
tags: 面试
categories:
- [interview, interview-java]
---

### 并行和并发有什么区别？
#### 并发：
* 在操作系统中，一个时间段内在同一个处理机上处于开始到结束之间的多个任务之间的状态，window的时间片分时调度即并发，实际是串行，但是多个任务在不停地切换，每个任务运行一小会，以实现多个任务的同时运行即并发

#### 并行：
* 互不抢占资源的两个任务同时运行时，即并行

#### 区别：
* 并发实际上是串行
* 并发需要共享运算资源，并行不需要
* 单cpu可以实现并发，但不能实现并行
* 并行是真正的同时运行


### 线程和进程的区别？
#### 线程：
* 是进程的子任务
* 是操作系统可识别的最小执行和调度单位
* 是CPU调度和分配的基本单位

#### 进程：
* 是对运行时程序的封装
* 是系统进行资源调度和分配的基本单位

#### 区别：
* 一个线程只能属于一个进程，一个进程可以包含多个线程，且至少有一个线程
* 进程用友独立的内存单元，多个线程共享这部分内存
* 进程是资源分配的最小单位，线程是cpu调度的最小单位
* 创建、撤销、切换等操作，进程的开销要远大于线程
* 线程间可以使用共享内存进行通信，实现起来较简单，进程间通信实现较复杂，进程间通信依赖线程
* 进程间互相不会影响，线程挂掉时会导致整个进程挂掉

### 进程间通信方式？
* 管道：
  * 匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系
  * 高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
  * 有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
* 消息队列
* 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
* 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
* 共享内存：
* 套接字

### 线程间通信方式？
* 各种锁：互斥锁
* 信号量：
* 信号：
* 进程间通信也能用于线程间通信，进程间通信本质上都是线程在干活

### 守护线程是什么？
#### 定义:
* 为其他线程服务的线程，比如垃圾回收线程

#### 特点：
* JVM结束进程时，不关心守护线程，但是用户线程存在的话，JVM不会结束进程
* 守护线程不能持有任何需要关闭的资源，进程结束时会导致该资源出错
* 守护线程优先级低，守护线程中创建的新线程同样是守护线程，用户线程同样，其中创建的新线程也是用户线程

### 线程分类?
#### 按照是否为用户自定义来区分
* 守护线程
* 用户线程

### 创建线程有哪几种方式？
* 本质上都是一样的，都需要new thread
* 继承Thread类，重写run方法
* 通过实现Runnable接口中的run方法
* 通过实现Callable接口中的call方法，然后使用FutureTask进行调用
```
    @Test
    public void testCode() throws ExecutionException, InterruptedException {
        FutureTask<Integer> futureTask = new FutureTask<>(new TestThread());
        new Thread(futureTask).start();
        Integer result = futureTask.get();
        System.out.println(result);
    }

    class TestThread implements Callable<Integer> {

        @Override
        public Integer call() throws Exception {
            System.out.println("啦啦啦啦");
            return 1;
        }
    }
```
* 通过线程池创建线程：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式
  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限
  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限
  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务
  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程


### 说一下 runnable 和 callable 有什么区别？
* 相同点：
  * 都是接口
  * 都可以实现多线程
  * 都采用thread.start启动
* 不同：
  * Runnable的run方法没有返回值，Callable的call方法可以自定义返回值
  * Runnable的run方法只能抛出运行时一场，且无法捕获，Callable的run方法允许抛出异常，且可以捕获
  * Executor使用Runnable使用execute方法，使用Callable时使用submit方法

### 线程有哪些状态？
* new：创建
* Runnable：运行中，正在执行run方法
* Blocked： 运行中，因被阻塞而挂起
* Waiting：运行中，因为某些操作在等待中
* Timed Waiting：运行中，因为执行sleep，在计时等待
* Terminated：终止，run方法执行完毕或调用Thread的stop
* join：阻塞当前线程，等待该线程对象执行完成，如果已完成，就立即返回
