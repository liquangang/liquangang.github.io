{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/Java/JDK-JRE-JVM.md","hash":"98d4a30deed4e6c6fa83ba81a49b95874b4b6125","modified":1649754046005},{"_id":"source/_posts/Java/Java-String.md","hash":"92947c846189d1d6b7505f1f05fb137992410f64","modified":1649754046005},{"_id":"source/_posts/Java/Java概述.md","hash":"6fcede31375ff9b0ffa5c8d9142260bf431cd9d2","modified":1649754046006},{"_id":"source/_posts/Java/Java内存.md","hash":"1de40549d7607b6001660831c7307dc2541f44f1","modified":1649754046005},{"_id":"source/_posts/Java/Java注释.md","hash":"7a7e995013722df2f25bee9c5e32595c27ede6d1","modified":1649754046006},{"_id":"source/_posts/Java/Java程序运行流程.md","hash":"2fb8d5aa1375b7d06ccaf4a152fb03a1b8241166","modified":1649754046006},{"_id":"source/_posts/Java/Java类.md","hash":"75d36c5e05375677c42acb7cba3a0f725cbef56a","modified":1649754046006},{"_id":"source/_posts/Java/java-package.md","hash":"55921d4b52ade10abf52387e6d11513c4a1a26bf","modified":1649754046007},{"_id":"source/_posts/Java/Java跨平台原理.md","hash":"b234ba46d9f298dcdaa8235fe2f06c8120e7f366","modified":1649754046006},{"_id":"source/_posts/Java/json.md","hash":"5ff3b382a084606871f9276872b96ae0c9881c6b","modified":1649754046007},{"_id":"source/_posts/Java/关键字、标识符.md","hash":"162dd6e2987c64848b8f4e4f306cf70bd96a24de","modified":1649754046007},{"_id":"source/_posts/Java/数据类型.md","hash":"abc8356d9ccc6125feee70ce2bebdc629073f1a8","modified":1649754046007},{"_id":"source/_posts/Java/多态.md","hash":"9b788e5d2c292ad6631f3d94be0f445057084b0e","modified":1649754046007},{"_id":"source/_posts/Java/流程控制.md","hash":"55310ece867d3b87abaec2edf6f9f90a4ee06f37","modified":1649754046008},{"_id":"source/_posts/Java/多线程.md","hash":"5016f8e87a272da4794f3e1343f168ea8a50abfe","modified":1649754046007},{"_id":"source/_posts/Java/数组.md","hash":"9d2b4403d1124f7103e42424ce958d93311cf53c","modified":1649754046007},{"_id":"source/_posts/Java/继承.md","hash":"82ffded7120188128c9c423a53794c364e1e7e60","modified":1649754046008},{"_id":"source/_posts/Java/运算符.md","hash":"292ec6a26de9343065fffee3bd6ec443df2eaf5f","modified":1649754046008},{"_id":"source/_posts/Linux/Linux常用命令总结.md","hash":"d0809b875144252245dc283ebac94d5111f8e9e7","modified":1649754046008},{"_id":"source/_posts/blockchain/数字货币私钥保存方案设计.md","hash":"55be041f40bbcd4fa66988b6fb48fde3e2780345","modified":1649754046011},{"_id":"source/_posts/blogTutorial/Markdown指南.md","hash":"2143f56140c592a315ab58fe98f85610b1e546a6","modified":1649754046012},{"_id":"source/_posts/dataStructure/栈.md","hash":"3d320d03e8f62b41c6dd681f5e9cfffc598eeef2","modified":1649754046012},{"_id":"source/_posts/blogTutorial/博客搭建.md","hash":"89ab84b37aa0fa3f26774e93b8fc68ba456fe63a","modified":1649754046012},{"_id":"source/_posts/dataStructure/队列.md","hash":"b991a377290a7585299b532d8ccf577666ee6ca4","modified":1649754046012},{"_id":"source/_posts/codeStyle/代码规范.md","hash":"3b084d2cfa9a08aa0a36e78a1b5770504bbceaf1","modified":1649754046012},{"_id":"source/_posts/module/redis.md","hash":"3922fd997864b1dbfef52896b3a518bfe865f910","modified":1649754046013},{"_id":"source/_posts/toolApplication/IDEA指南.md","hash":"47a2866ac70ee1d9d08c8ed1136ab9c7d95f249d","modified":1649754046013},{"_id":"source/_posts/toolApplication/PyCharm指南.md","hash":"454bf92a49bfa3a5972d17337e7673ef219f5ef7","modified":1649754046013},{"_id":"source/_posts/toolApplication/git指南.md","hash":"4b944865772d91bc64e6efd89935cba2796bd5c8","modified":1649754046013},{"_id":"source/_posts/toolApplication/mac使用记录.md","hash":"ca07f0f811e58f8a51cdead804d68967bb27f974","modified":1649754046013},{"_id":"source/_posts/toolScript/上传图书到kindle.md","hash":"8a93805d9baf982be08a732a36b6bce9f950c211","modified":1649754046014},{"_id":"source/_posts/Q&A/Java/IO流.md","hash":"a9c6d095119ca37924c1178f632758dc6d77617b","modified":1649754046008},{"_id":"source/_posts/Q&A/Java/Math静态方法.md","hash":"1d630214df02e8e362809dfc897c3cdc15a81610","modified":1649754046009},{"_id":"source/_posts/Q&A/Java/JDK、JRE、JVM.md","hash":"df973aff569c80248b8a728a13c2434950b4d84f","modified":1649754046009},{"_id":"source/_posts/Q&A/Java/final.md","hash":"236e3dc865c9baa69d280529e460953bea9555ee","modified":1649754046009},{"_id":"source/_posts/Q&A/Java/javaWeb.md","hash":"6bf8f4212c24bf014c6e6b4c55bdcc9d3ba9ec97","modified":1649754046009},{"_id":"source/_posts/Q&A/Java/双等号、equals、hashCode区别.md","hash":"7aea2adec8a650d3df604c26c5a7fa16b7704e8c","modified":1649754046009},{"_id":"source/_posts/Q&A/Java/多线程.md","hash":"10fcd79b4ad19faf5168f49b8f85d41a1a479d53","modified":1649754046010},{"_id":"source/_posts/Q&A/Java/反射.md","hash":"525629ff94a32674d7e7177249c0f82700f1e943","modified":1649754046010},{"_id":"source/_posts/Q&A/Java/容器.md","hash":"e93bd18edb7d329307b55b810b13010282722ae9","modified":1649754046010},{"_id":"source/_posts/Q&A/Java/对象拷贝.md","hash":"90b711ac539881c2e9af4ad283fa2d37c0cfbbbe","modified":1649754046010},{"_id":"source/_posts/Q&A/Java/异常.md","hash":"73a3fa4ad52d4cfe261f6b396f8e5d86fa970904","modified":1649754046011},{"_id":"source/_posts/Q&A/Java/抽象类、抽象方法.md","hash":"c1d0a724487a4f1c329c18155effd1a30c21e847","modified":1649754046011},{"_id":"source/_posts/Q&A/Java/重写、重载.md","hash":"d7bac21b202c4910d51e51bc73650f382793ebba","modified":1649754046011},{"_id":"source/_posts/Q&A/Java/String、StringBuffer、StringBuilder.md","hash":"6eaf9cf6f9fb65facfc7e0936b649f54b5830448","modified":1649754046009},{"_id":"source/_posts/Q&A/Java/接口.md","hash":"088fb2be2041546e80d66fe99b7407bdde7b7cd8","modified":1649754046011},{"_id":"source/_posts/Q&A/Java/面向对象、面向过程.md","hash":"f787db3735fed38b10672f3595b8c2c5b1e502b4","modified":1649754046011}],"Category":[{"name":"Java","_id":"cl1vwz0ab0004wgtthuss535w"},{"name":"Linux","_id":"cl1vwz0az001kwgtt72y7fziz"},{"name":"区块链使用","_id":"cl1vwz0b2001twgtt9hkb9npv"},{"name":"博客搭建","_id":"cl1vwz0b40021wgtt6x802a1h"},{"name":"数据结构","_id":"cl1vwz0bf002bwgtt5ecz9di5"},{"name":"codeStyle","_id":"cl1vwz0bi002hwgtt8y5fg92c"},{"name":"组件","_id":"cl1vwz0bj002jwgtt5h5hhux9"},{"name":"工具应用","_id":"cl1vwz0bo002rwgttcsew2b8a"},{"name":"mac使用技巧","_id":"cl1vwz0bv0036wgtt84ir3uo1"},{"name":"工具脚本","_id":"cl1vwz0by003cwgttenblg690"},{"name":"Q&A","_id":"cl1vwz0c0003jwgttats70fr5"},{"name":"Q&A-java","parent":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0c9004iwgttfdp968qa"}],"Data":[],"Page":[],"Post":[{"title":"JDK&JRE&JVM","date":"2021-08-21T10:03:06.000Z","_content":"\n* JDK（Java Development Kit：开发Java程序）：\n  * JRE（Java Runtime Environment：运行Java程序）：\n    * JVM（Java Virtual Machine：实现Java程序跨平台运行）\n    * 运行时需要的核心类库\n  * 开发人员工具\n    * 编译工具（javac.exe）\n    * 运行工具（java.exe）\n","source":"_posts/Java/JDK-JRE-JVM.md","raw":"---\ntitle: JDK&JRE&JVM\ndate: 2021-08-21 18:03:06\ntags: 编程\ncategories:\n- [Java]\n---\n\n* JDK（Java Development Kit：开发Java程序）：\n  * JRE（Java Runtime Environment：运行Java程序）：\n    * JVM（Java Virtual Machine：实现Java程序跨平台运行）\n    * 运行时需要的核心类库\n  * 开发人员工具\n    * 编译工具（javac.exe）\n    * 运行工具（java.exe）\n","slug":"Java/JDK-JRE-JVM","published":1,"updated":"2022-04-12T09:00:46.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz09u0000wgtt9okrfjgy","content":"<ul>\n<li>JDK（Java Development Kit：开发Java程序）：<ul>\n<li>JRE（Java Runtime Environment：运行Java程序）：<ul>\n<li>JVM（Java Virtual Machine：实现Java程序跨平台运行）</li>\n<li>运行时需要的核心类库</li>\n</ul>\n</li>\n<li>开发人员工具<ul>\n<li>编译工具（javac.exe）</li>\n<li>运行工具（java.exe）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>JDK（Java Development Kit：开发Java程序）：<ul>\n<li>JRE（Java Runtime Environment：运行Java程序）：<ul>\n<li>JVM（Java Virtual Machine：实现Java程序跨平台运行）</li>\n<li>运行时需要的核心类库</li>\n</ul>\n</li>\n<li>开发人员工具<ul>\n<li>编译工具（javac.exe）</li>\n<li>运行工具（java.exe）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Java-String","date":"2021-09-25T09:26:30.000Z","_content":"\n## String\n* 特点：\n    * 效果上相当于字符数组（char[]），实际上底层原理是字节数组（byte[]）\n\n## 构造方法        \n* 不同构造方法特点\n    * 使用\"\"方法创建的对象实际指向的是同一个内存地址\n    * 使用new创建的对象即时字符换内容相同，对象指向的内存地址也不同\n    \n## 字符串比较\n* ==（实际都是比较变量保存的值是否相同）\n    * 基本数据类型是比较值\n    * 引用类型比较的是地址值\n    \n## StringBuilder\n* 特点：\n    * 去掉字符串拼接过程中构造新对象的行为（解决浪费内存空间且耗时的问题）\n    * 内容可变\n    ","source":"_posts/Java/Java-String.md","raw":"---\ntitle: Java-String\ndate: 2021-09-25 17:26:30\ntags: 编程\ncategories:\n- [Java]\n---\n\n## String\n* 特点：\n    * 效果上相当于字符数组（char[]），实际上底层原理是字节数组（byte[]）\n\n## 构造方法        \n* 不同构造方法特点\n    * 使用\"\"方法创建的对象实际指向的是同一个内存地址\n    * 使用new创建的对象即时字符换内容相同，对象指向的内存地址也不同\n    \n## 字符串比较\n* ==（实际都是比较变量保存的值是否相同）\n    * 基本数据类型是比较值\n    * 引用类型比较的是地址值\n    \n## StringBuilder\n* 特点：\n    * 去掉字符串拼接过程中构造新对象的行为（解决浪费内存空间且耗时的问题）\n    * 内容可变\n    ","slug":"Java/Java-String","published":1,"updated":"2022-04-12T09:00:46.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0a30001wgttgi7f2qg2","content":"<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><ul>\n<li>特点：<ul>\n<li>效果上相当于字符数组（char[]），实际上底层原理是字节数组（byte[]）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><ul>\n<li>不同构造方法特点<ul>\n<li>使用””方法创建的对象实际指向的是同一个内存地址</li>\n<li>使用new创建的对象即时字符换内容相同，对象指向的内存地址也不同</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><ul>\n<li>==（实际都是比较变量保存的值是否相同）<ul>\n<li>基本数据类型是比较值</li>\n<li>引用类型比较的是地址值</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><ul>\n<li>特点：<ul>\n<li>去掉字符串拼接过程中构造新对象的行为（解决浪费内存空间且耗时的问题）</li>\n<li>内容可变</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><ul>\n<li>特点：<ul>\n<li>效果上相当于字符数组（char[]），实际上底层原理是字节数组（byte[]）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><ul>\n<li>不同构造方法特点<ul>\n<li>使用””方法创建的对象实际指向的是同一个内存地址</li>\n<li>使用new创建的对象即时字符换内容相同，对象指向的内存地址也不同</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><ul>\n<li>==（实际都是比较变量保存的值是否相同）<ul>\n<li>基本数据类型是比较值</li>\n<li>引用类型比较的是地址值</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><ul>\n<li>特点：<ul>\n<li>去掉字符串拼接过程中构造新对象的行为（解决浪费内存空间且耗时的问题）</li>\n<li>内容可变</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Java内存详解","date":"2021-08-31T03:14:46.000Z","_content":"\n## 内存区域、内存模型\n* 内存区域：即运行时数据区域，指JVM对于不同类型数据在内存中的存储方式\n* 内存模型（JMM：Java Memory Model）：定义了线程与主内存之间的抽象关系，即JVM在内存中的工作方式，即JVM使用内存区域中的数据的方式\n\n## JDK8之后的内存区域：\n```\n* Native Method Stacks（本地方法栈）\n* Program Counter Register（程序计数器）\n* Java Virtual Machine Stacks（JVM Stacks，即虚拟机栈）\n    * Stack Frame（栈帧）\n        * 局部变量表\n        * 操作栈\n        * 动态连接\n        * 方法返回地址\n    * Stack Frame（栈帧）\n        * 局部变量表\n        * 操作栈\n        * 动态连接\n        * 方法返回地址\n* Heap（堆区）\n    * Young区（新生代）\n        * Eden\n        * S0\n        * S1\n    * Old区（老年代）\n* Method Area（方法区）\n    * Runtime Constant Pool（运行时常量池）\n    * 方法元信息\n    * klass类元信息\n* CodeCache（JIT编译产物） \n```\n\n### Program Counter Register (程序计数器)\n* 作用：当前线程所执行的字节码的行号指示器，当多线程切换时，使线程恢复后找到正确的执行位置\n* 特点：\n    * 内存占用少\n    * 线程私有\n    * 当前线程执行Java方法，计数器保存虚拟机中字节码指令地址；执行Native方法，记录null\n    * 唯一一个在JVM规范中没有规定OutOfMemoryError的区域\n   \n### JVM Stacks\n* 概念：\n    * 活动线程：当前正在执行的线程\n    * 当前帧：正在执行的方法对应的栈帧，由于只有栈顶帧有效，所以当前帧也是栈顶帧\n    * 当前方法：正在执行的方法\n* 简介：描述了Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame：栈中的一个元素，方法运行时的基础数据结构），存储局部变量表，操作数栈、动态连接、方法出口等。每一个方法从调用到执行完的过程，对应一个栈帧入栈出栈过程\n* 作用：保存Java方法执行的时候需要的各种数据、参数\n* 特点：\n    * 线程私有\n    * 生命周期与线程相同\n    * 执行引擎运行时，所有指令都只能对当前帧操作\n    * 一个方法对应一个栈帧\n* 组成：\n    * #### Stack Frame（栈帧）：\n        * 介绍：一个栈帧对应一个方法执行需要的数据\n        * JVM规定的与栈帧相关异常：\n            * 线程请求的栈深度大于JVM允许的深度，抛出StackOverflowError\n            * 对于当前大多数可以拓展的JVM栈，在拓展时申请不到足够内存，抛出OutOfMemoryError\n        * 组成：\n            * #### 局部变量表\n                * 作用：存放方法参数和局部变量，字节码指令中的STORE指令就是将操作栈中计算完成局部变量写到当前帧的局部变量表中\n                * 特点：\n                    * 必须显示初始化，才能使用\n                    * 如果是非静态方法，会在index[0]位置存储方法所属对象的实例引用，占用4字节，后面存储方法参数和局部变量\n            * #### 操作栈\n                * 作用：用于方法执行过程中信息的存取\n                * 简介：JVM的执行引擎是基于栈的执行引擎，其中的栈即操作栈，方法执行时，使用操作栈进行存取信息\n                * 关联：\n                    * 字节码指令集即基于栈类型，栈深度保存在方法元信息的栈属性中\n                    * 例：\n                        * ++i：总体思路是按顺序执行，先将局部变量表中的i执行加1操作（load memory&add&store memory），然后放到操作栈中(load memory)，此时从操作栈栈顶取出的i就是加1之后的\n                        * i++：按照按顺序执行的思路，先将i放到操作栈中(load memory)，然后执行加1的操作(add memory)，加1之后的值更新到局部变量表中(store memory)，此时从栈顶读取到的i未加1，所以如果多线程操作i的时候，可能从局部变量表读到的i比预期的小\n                * 特点：\n                    * 初始状态为空桶式结构栈\n            * #### 动态连接\n                * 介绍：每个栈帧中包含一个在常量池中对当前方法的引用，目的是为了支持方法调用过程的动态连接\n            * #### 方法返回地址：\n                * 方法执行退出情况：\n                    * 正常退出，遇到返回字节码指令，比如return、ireturn、areturn\n                    * 异常退出\n                * 介绍：即方法调用完成返回的位置，方法调用完成后会弹出当前栈帧\n                * 退出后行为：\n                    * 返回值压入上层调用栈帧 \n                    * 异常抛给能处理的栈帧\n                    * 程序计数器指向方法调用后的下一条指令    \n        \n### Native Method Stacks(本地方法栈)\n* 介绍：与JVM Stacks类似，但保存的是Native方法对应的栈帧\n* 特点：\n    * 也会抛出StackOverFlowError和OutOfMemoryError\n    * 线程调用本地方法时，不受JVM约束\n    * 本地方法通过JNI(Java Native Interface)来访问JVM的数据，可以调用寄存器，具有JVM相同的能力、权限\n    * 大量本地方法运行时，会削弱JVM对系统控制力，本地方法出错信息比较黑盒\n    * 本地方法栈会在内存不足时抛出NativeHeapOutOfMemory\n\n### Heap（堆）\n* 介绍：存放对象实例，几乎所有的对象实例都在这里分配内存\n* 特点：\n    * 对大多数应用来说，Heap是JVM管理内存中最大的一块\n    * 被所有线程共享\n    * 虚拟机启动时创建\n    * GC管理的主要区域，有时候也成Heap为GC Heap\n    * 内部可能包含多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）\n    * 可以由物理上不连续的内存空间组成，只要逻辑上连续即可\n    * 当堆中无内存完成实例分配，并且无法拓展时，会抛出OutOfMemoryError\n* 按照GC中的分代回收算法分类：\n    * 新生代\n        * Eden\n        * S0\n        * S1\n    * 老年代 \n            \n### Metaspace（元数据区）\n* 组成：\n    * #### Method Area（方法区）\n        * 特点：\n            * 线程共享\n            * 存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n            * JVM对该区域限制非常松，可选择不实现垃圾回收\n            * 垃圾回收在该区域出现少，主要是回收运行时常量池和类元信息\n            * 当方法区无法满足内存分配需求时，抛出OutOfMemoryError\n    * #### Runtime Constant Pool（运行时常量池）\n        * 作用：\n            * 用于存放编译器生成的各种字面量、符号引用、翻译出来的直接引用\n        * 特点：\n            * 具备动态性，非编译期也可以产生常量，运行期间可以将常量放入池中，例如String的intern() 方法\n            * 当申请不到新内存时，抛出OutOfMemoryError\n            \n### 直接内存\n* 作用：\n    * 用于避免Java堆与native对来回复制数据，提高某些场景的性能\n* 特点：\n    * 非虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域\n    * 基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用来操作\n    * 动态拓展时申请不到足够内存会抛出OutOfMemoryError\n    \n## Java Memory Model（java内存模型）\n* 作用：\n    * 控制线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见\n    * 定义程序中各个变量的访问规则\n* 特点：\n    * 共享内存的并发模型，线程之间通过读写共享变量（堆内存中的实例域、静态域、数组元素）来完成隐式通信\n    * 所有变量都存储在主内存中，每条线程有自己的私有内存，也叫工作内存，线程对变量的操作必须在工作内存中进行，不能直接操作主内存中的变量，工作内存中存储了变量副本\n    * 属于语言级的内存模型，在不同的编译器、处理器上，通过禁止特定类型的编译器重排序和处理器重排序（指令级并行重排序、内存系统重排序），确保为程序员提供一致的内存可见性\n\n## 重排序\n* 作用：\n    * 编译器和处理器为了提高性能，会对指令重排序\n* 分类：\n    * 编译器优化的重排序：\n        * 编译器在不改变程序语义的情况下，可以重排语句执行顺序\n    * 指令级并行的重排序：\n        * 现代处理器提供了指令级并行技术来将多条指令并行执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序\n    * 内存系统的重排序：\n        * 由于处理器使用了缓存和读写缓冲区，使加载和存储操作看上去是在乱序执行\n* 从Java源代码到执行指令序列：\n    * 源代码 > 编译器优化重排序 > 指令级重排序 > 内存系统重排序 > 最终执行的指令序列        \n* Java进制处理器重排序方式：\n    * 生成指令序列的内存屏障，即重排序时不能把内存屏障指令重排到之前来实现的\n \n## happens-before\n* 作用：\n    * 描述操作之间的内存可见性（可见性：指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的）\n* 特点：\n    * JDK5出现\n    * 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间\n* 重要的 happens-before 规则如下：\n    * 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。\n    * 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。\n    * volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。\n    * 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。\n   \n## volatile\n* 作用：\n    * 保持变量的修改在多个线程间是同步的\n* 特点：\n    * 保证变量对所有线程都是可见的\n    * volatile变量在并发情况下由于Java的非原子化操作导致线程不安全，synchronized由于统一时间内只能由一个线程操作，所以是线程安全的\n    * 禁止指令重排序优化\n    \n\n    \n\n","source":"_posts/Java/Java内存.md","raw":"---\ntitle: Java内存详解\ndate: 2021-08-31 11:14:46\ntags: 编程\ncategories:\n- [Java]\n---\n\n## 内存区域、内存模型\n* 内存区域：即运行时数据区域，指JVM对于不同类型数据在内存中的存储方式\n* 内存模型（JMM：Java Memory Model）：定义了线程与主内存之间的抽象关系，即JVM在内存中的工作方式，即JVM使用内存区域中的数据的方式\n\n## JDK8之后的内存区域：\n```\n* Native Method Stacks（本地方法栈）\n* Program Counter Register（程序计数器）\n* Java Virtual Machine Stacks（JVM Stacks，即虚拟机栈）\n    * Stack Frame（栈帧）\n        * 局部变量表\n        * 操作栈\n        * 动态连接\n        * 方法返回地址\n    * Stack Frame（栈帧）\n        * 局部变量表\n        * 操作栈\n        * 动态连接\n        * 方法返回地址\n* Heap（堆区）\n    * Young区（新生代）\n        * Eden\n        * S0\n        * S1\n    * Old区（老年代）\n* Method Area（方法区）\n    * Runtime Constant Pool（运行时常量池）\n    * 方法元信息\n    * klass类元信息\n* CodeCache（JIT编译产物） \n```\n\n### Program Counter Register (程序计数器)\n* 作用：当前线程所执行的字节码的行号指示器，当多线程切换时，使线程恢复后找到正确的执行位置\n* 特点：\n    * 内存占用少\n    * 线程私有\n    * 当前线程执行Java方法，计数器保存虚拟机中字节码指令地址；执行Native方法，记录null\n    * 唯一一个在JVM规范中没有规定OutOfMemoryError的区域\n   \n### JVM Stacks\n* 概念：\n    * 活动线程：当前正在执行的线程\n    * 当前帧：正在执行的方法对应的栈帧，由于只有栈顶帧有效，所以当前帧也是栈顶帧\n    * 当前方法：正在执行的方法\n* 简介：描述了Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame：栈中的一个元素，方法运行时的基础数据结构），存储局部变量表，操作数栈、动态连接、方法出口等。每一个方法从调用到执行完的过程，对应一个栈帧入栈出栈过程\n* 作用：保存Java方法执行的时候需要的各种数据、参数\n* 特点：\n    * 线程私有\n    * 生命周期与线程相同\n    * 执行引擎运行时，所有指令都只能对当前帧操作\n    * 一个方法对应一个栈帧\n* 组成：\n    * #### Stack Frame（栈帧）：\n        * 介绍：一个栈帧对应一个方法执行需要的数据\n        * JVM规定的与栈帧相关异常：\n            * 线程请求的栈深度大于JVM允许的深度，抛出StackOverflowError\n            * 对于当前大多数可以拓展的JVM栈，在拓展时申请不到足够内存，抛出OutOfMemoryError\n        * 组成：\n            * #### 局部变量表\n                * 作用：存放方法参数和局部变量，字节码指令中的STORE指令就是将操作栈中计算完成局部变量写到当前帧的局部变量表中\n                * 特点：\n                    * 必须显示初始化，才能使用\n                    * 如果是非静态方法，会在index[0]位置存储方法所属对象的实例引用，占用4字节，后面存储方法参数和局部变量\n            * #### 操作栈\n                * 作用：用于方法执行过程中信息的存取\n                * 简介：JVM的执行引擎是基于栈的执行引擎，其中的栈即操作栈，方法执行时，使用操作栈进行存取信息\n                * 关联：\n                    * 字节码指令集即基于栈类型，栈深度保存在方法元信息的栈属性中\n                    * 例：\n                        * ++i：总体思路是按顺序执行，先将局部变量表中的i执行加1操作（load memory&add&store memory），然后放到操作栈中(load memory)，此时从操作栈栈顶取出的i就是加1之后的\n                        * i++：按照按顺序执行的思路，先将i放到操作栈中(load memory)，然后执行加1的操作(add memory)，加1之后的值更新到局部变量表中(store memory)，此时从栈顶读取到的i未加1，所以如果多线程操作i的时候，可能从局部变量表读到的i比预期的小\n                * 特点：\n                    * 初始状态为空桶式结构栈\n            * #### 动态连接\n                * 介绍：每个栈帧中包含一个在常量池中对当前方法的引用，目的是为了支持方法调用过程的动态连接\n            * #### 方法返回地址：\n                * 方法执行退出情况：\n                    * 正常退出，遇到返回字节码指令，比如return、ireturn、areturn\n                    * 异常退出\n                * 介绍：即方法调用完成返回的位置，方法调用完成后会弹出当前栈帧\n                * 退出后行为：\n                    * 返回值压入上层调用栈帧 \n                    * 异常抛给能处理的栈帧\n                    * 程序计数器指向方法调用后的下一条指令    \n        \n### Native Method Stacks(本地方法栈)\n* 介绍：与JVM Stacks类似，但保存的是Native方法对应的栈帧\n* 特点：\n    * 也会抛出StackOverFlowError和OutOfMemoryError\n    * 线程调用本地方法时，不受JVM约束\n    * 本地方法通过JNI(Java Native Interface)来访问JVM的数据，可以调用寄存器，具有JVM相同的能力、权限\n    * 大量本地方法运行时，会削弱JVM对系统控制力，本地方法出错信息比较黑盒\n    * 本地方法栈会在内存不足时抛出NativeHeapOutOfMemory\n\n### Heap（堆）\n* 介绍：存放对象实例，几乎所有的对象实例都在这里分配内存\n* 特点：\n    * 对大多数应用来说，Heap是JVM管理内存中最大的一块\n    * 被所有线程共享\n    * 虚拟机启动时创建\n    * GC管理的主要区域，有时候也成Heap为GC Heap\n    * 内部可能包含多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）\n    * 可以由物理上不连续的内存空间组成，只要逻辑上连续即可\n    * 当堆中无内存完成实例分配，并且无法拓展时，会抛出OutOfMemoryError\n* 按照GC中的分代回收算法分类：\n    * 新生代\n        * Eden\n        * S0\n        * S1\n    * 老年代 \n            \n### Metaspace（元数据区）\n* 组成：\n    * #### Method Area（方法区）\n        * 特点：\n            * 线程共享\n            * 存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n            * JVM对该区域限制非常松，可选择不实现垃圾回收\n            * 垃圾回收在该区域出现少，主要是回收运行时常量池和类元信息\n            * 当方法区无法满足内存分配需求时，抛出OutOfMemoryError\n    * #### Runtime Constant Pool（运行时常量池）\n        * 作用：\n            * 用于存放编译器生成的各种字面量、符号引用、翻译出来的直接引用\n        * 特点：\n            * 具备动态性，非编译期也可以产生常量，运行期间可以将常量放入池中，例如String的intern() 方法\n            * 当申请不到新内存时，抛出OutOfMemoryError\n            \n### 直接内存\n* 作用：\n    * 用于避免Java堆与native对来回复制数据，提高某些场景的性能\n* 特点：\n    * 非虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域\n    * 基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用来操作\n    * 动态拓展时申请不到足够内存会抛出OutOfMemoryError\n    \n## Java Memory Model（java内存模型）\n* 作用：\n    * 控制线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见\n    * 定义程序中各个变量的访问规则\n* 特点：\n    * 共享内存的并发模型，线程之间通过读写共享变量（堆内存中的实例域、静态域、数组元素）来完成隐式通信\n    * 所有变量都存储在主内存中，每条线程有自己的私有内存，也叫工作内存，线程对变量的操作必须在工作内存中进行，不能直接操作主内存中的变量，工作内存中存储了变量副本\n    * 属于语言级的内存模型，在不同的编译器、处理器上，通过禁止特定类型的编译器重排序和处理器重排序（指令级并行重排序、内存系统重排序），确保为程序员提供一致的内存可见性\n\n## 重排序\n* 作用：\n    * 编译器和处理器为了提高性能，会对指令重排序\n* 分类：\n    * 编译器优化的重排序：\n        * 编译器在不改变程序语义的情况下，可以重排语句执行顺序\n    * 指令级并行的重排序：\n        * 现代处理器提供了指令级并行技术来将多条指令并行执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序\n    * 内存系统的重排序：\n        * 由于处理器使用了缓存和读写缓冲区，使加载和存储操作看上去是在乱序执行\n* 从Java源代码到执行指令序列：\n    * 源代码 > 编译器优化重排序 > 指令级重排序 > 内存系统重排序 > 最终执行的指令序列        \n* Java进制处理器重排序方式：\n    * 生成指令序列的内存屏障，即重排序时不能把内存屏障指令重排到之前来实现的\n \n## happens-before\n* 作用：\n    * 描述操作之间的内存可见性（可见性：指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的）\n* 特点：\n    * JDK5出现\n    * 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间\n* 重要的 happens-before 规则如下：\n    * 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。\n    * 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。\n    * volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。\n    * 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。\n   \n## volatile\n* 作用：\n    * 保持变量的修改在多个线程间是同步的\n* 特点：\n    * 保证变量对所有线程都是可见的\n    * volatile变量在并发情况下由于Java的非原子化操作导致线程不安全，synchronized由于统一时间内只能由一个线程操作，所以是线程安全的\n    * 禁止指令重排序优化\n    \n\n    \n\n","slug":"Java/Java内存","published":1,"updated":"2022-04-12T09:00:46.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0aa0003wgttdwqohty7","content":"<h2 id=\"内存区域、内存模型\"><a href=\"#内存区域、内存模型\" class=\"headerlink\" title=\"内存区域、内存模型\"></a>内存区域、内存模型</h2><ul>\n<li>内存区域：即运行时数据区域，指JVM对于不同类型数据在内存中的存储方式</li>\n<li>内存模型（JMM：Java Memory Model）：定义了线程与主内存之间的抽象关系，即JVM在内存中的工作方式，即JVM使用内存区域中的数据的方式</li>\n</ul>\n<h2 id=\"JDK8之后的内存区域：\"><a href=\"#JDK8之后的内存区域：\" class=\"headerlink\" title=\"JDK8之后的内存区域：\"></a>JDK8之后的内存区域：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* Native Method Stacks（本地方法栈）</span><br><span class=\"line\">* Program Counter Register（程序计数器）</span><br><span class=\"line\">* Java Virtual Machine Stacks（JVM Stacks，即虚拟机栈）</span><br><span class=\"line\">    * Stack Frame（栈帧）</span><br><span class=\"line\">        * 局部变量表</span><br><span class=\"line\">        * 操作栈</span><br><span class=\"line\">        * 动态连接</span><br><span class=\"line\">        * 方法返回地址</span><br><span class=\"line\">    * Stack Frame（栈帧）</span><br><span class=\"line\">        * 局部变量表</span><br><span class=\"line\">        * 操作栈</span><br><span class=\"line\">        * 动态连接</span><br><span class=\"line\">        * 方法返回地址</span><br><span class=\"line\">* Heap（堆区）</span><br><span class=\"line\">    * Young区（新生代）</span><br><span class=\"line\">        * Eden</span><br><span class=\"line\">        * S0</span><br><span class=\"line\">        * S1</span><br><span class=\"line\">    * Old区（老年代）</span><br><span class=\"line\">* Method Area（方法区）</span><br><span class=\"line\">    * Runtime Constant Pool（运行时常量池）</span><br><span class=\"line\">    * 方法元信息</span><br><span class=\"line\">    * klass类元信息</span><br><span class=\"line\">* CodeCache（JIT编译产物） </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Program-Counter-Register-程序计数器\"><a href=\"#Program-Counter-Register-程序计数器\" class=\"headerlink\" title=\"Program Counter Register (程序计数器)\"></a>Program Counter Register (程序计数器)</h3><ul>\n<li>作用：当前线程所执行的字节码的行号指示器，当多线程切换时，使线程恢复后找到正确的执行位置</li>\n<li>特点：<ul>\n<li>内存占用少</li>\n<li>线程私有</li>\n<li>当前线程执行Java方法，计数器保存虚拟机中字节码指令地址；执行Native方法，记录null</li>\n<li>唯一一个在JVM规范中没有规定OutOfMemoryError的区域</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JVM-Stacks\"><a href=\"#JVM-Stacks\" class=\"headerlink\" title=\"JVM Stacks\"></a>JVM Stacks</h3><ul>\n<li>概念：<ul>\n<li>活动线程：当前正在执行的线程</li>\n<li>当前帧：正在执行的方法对应的栈帧，由于只有栈顶帧有效，所以当前帧也是栈顶帧</li>\n<li>当前方法：正在执行的方法</li>\n</ul>\n</li>\n<li>简介：描述了Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame：栈中的一个元素，方法运行时的基础数据结构），存储局部变量表，操作数栈、动态连接、方法出口等。每一个方法从调用到执行完的过程，对应一个栈帧入栈出栈过程</li>\n<li>作用：保存Java方法执行的时候需要的各种数据、参数</li>\n<li>特点：<ul>\n<li>线程私有</li>\n<li>生命周期与线程相同</li>\n<li>执行引擎运行时，所有指令都只能对当前帧操作</li>\n<li>一个方法对应一个栈帧</li>\n</ul>\n</li>\n<li>组成：<ul>\n<li><h4 id=\"Stack-Frame（栈帧）：\"><a href=\"#Stack-Frame（栈帧）：\" class=\"headerlink\" title=\"Stack Frame（栈帧）：\"></a>Stack Frame（栈帧）：</h4><ul>\n<li>介绍：一个栈帧对应一个方法执行需要的数据</li>\n<li>JVM规定的与栈帧相关异常：<ul>\n<li>线程请求的栈深度大于JVM允许的深度，抛出StackOverflowError</li>\n<li>对于当前大多数可以拓展的JVM栈，在拓展时申请不到足够内存，抛出OutOfMemoryError</li>\n</ul>\n</li>\n<li>组成：<ul>\n<li><h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><ul>\n<li>作用：存放方法参数和局部变量，字节码指令中的STORE指令就是将操作栈中计算完成局部变量写到当前帧的局部变量表中</li>\n<li>特点：<ul>\n<li>必须显示初始化，才能使用</li>\n<li>如果是非静态方法，会在index[0]位置存储方法所属对象的实例引用，占用4字节，后面存储方法参数和局部变量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h4 id=\"操作栈\"><a href=\"#操作栈\" class=\"headerlink\" title=\"操作栈\"></a>操作栈</h4><ul>\n<li>作用：用于方法执行过程中信息的存取</li>\n<li>简介：JVM的执行引擎是基于栈的执行引擎，其中的栈即操作栈，方法执行时，使用操作栈进行存取信息</li>\n<li>关联：<ul>\n<li>字节码指令集即基于栈类型，栈深度保存在方法元信息的栈属性中</li>\n<li>例：<ul>\n<li>++i：总体思路是按顺序执行，先将局部变量表中的i执行加1操作（load memory&amp;add&amp;store memory），然后放到操作栈中(load memory)，此时从操作栈栈顶取出的i就是加1之后的</li>\n<li>i++：按照按顺序执行的思路，先将i放到操作栈中(load memory)，然后执行加1的操作(add memory)，加1之后的值更新到局部变量表中(store memory)，此时从栈顶读取到的i未加1，所以如果多线程操作i的时候，可能从局部变量表读到的i比预期的小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>初始状态为空桶式结构栈</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h4 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h4><ul>\n<li>介绍：每个栈帧中包含一个在常量池中对当前方法的引用，目的是为了支持方法调用过程的动态连接</li>\n</ul>\n</li>\n<li><h4 id=\"方法返回地址：\"><a href=\"#方法返回地址：\" class=\"headerlink\" title=\"方法返回地址：\"></a>方法返回地址：</h4><ul>\n<li>方法执行退出情况：<ul>\n<li>正常退出，遇到返回字节码指令，比如return、ireturn、areturn</li>\n<li>异常退出</li>\n</ul>\n</li>\n<li>介绍：即方法调用完成返回的位置，方法调用完成后会弹出当前栈帧</li>\n<li>退出后行为：<ul>\n<li>返回值压入上层调用栈帧 </li>\n<li>异常抛给能处理的栈帧</li>\n<li>程序计数器指向方法调用后的下一条指令    </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Native-Method-Stacks-本地方法栈\"><a href=\"#Native-Method-Stacks-本地方法栈\" class=\"headerlink\" title=\"Native Method Stacks(本地方法栈)\"></a>Native Method Stacks(本地方法栈)</h3><ul>\n<li>介绍：与JVM Stacks类似，但保存的是Native方法对应的栈帧</li>\n<li>特点：<ul>\n<li>也会抛出StackOverFlowError和OutOfMemoryError</li>\n<li>线程调用本地方法时，不受JVM约束</li>\n<li>本地方法通过JNI(Java Native Interface)来访问JVM的数据，可以调用寄存器，具有JVM相同的能力、权限</li>\n<li>大量本地方法运行时，会削弱JVM对系统控制力，本地方法出错信息比较黑盒</li>\n<li>本地方法栈会在内存不足时抛出NativeHeapOutOfMemory</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Heap（堆）\"><a href=\"#Heap（堆）\" class=\"headerlink\" title=\"Heap（堆）\"></a>Heap（堆）</h3><ul>\n<li>介绍：存放对象实例，几乎所有的对象实例都在这里分配内存</li>\n<li>特点：<ul>\n<li>对大多数应用来说，Heap是JVM管理内存中最大的一块</li>\n<li>被所有线程共享</li>\n<li>虚拟机启动时创建</li>\n<li>GC管理的主要区域，有时候也成Heap为GC Heap</li>\n<li>内部可能包含多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）</li>\n<li>可以由物理上不连续的内存空间组成，只要逻辑上连续即可</li>\n<li>当堆中无内存完成实例分配，并且无法拓展时，会抛出OutOfMemoryError</li>\n</ul>\n</li>\n<li>按照GC中的分代回收算法分类：<ul>\n<li>新生代<ul>\n<li>Eden</li>\n<li>S0</li>\n<li>S1</li>\n</ul>\n</li>\n<li>老年代 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Metaspace（元数据区）\"><a href=\"#Metaspace（元数据区）\" class=\"headerlink\" title=\"Metaspace（元数据区）\"></a>Metaspace（元数据区）</h3><ul>\n<li>组成：<ul>\n<li><h4 id=\"Method-Area（方法区）\"><a href=\"#Method-Area（方法区）\" class=\"headerlink\" title=\"Method Area（方法区）\"></a>Method Area（方法区）</h4><ul>\n<li>特点：<ul>\n<li>线程共享</li>\n<li>存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>\n<li>JVM对该区域限制非常松，可选择不实现垃圾回收</li>\n<li>垃圾回收在该区域出现少，主要是回收运行时常量池和类元信息</li>\n<li>当方法区无法满足内存分配需求时，抛出OutOfMemoryError</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h4 id=\"Runtime-Constant-Pool（运行时常量池）\"><a href=\"#Runtime-Constant-Pool（运行时常量池）\" class=\"headerlink\" title=\"Runtime Constant Pool（运行时常量池）\"></a>Runtime Constant Pool（运行时常量池）</h4><ul>\n<li>作用：<ul>\n<li>用于存放编译器生成的各种字面量、符号引用、翻译出来的直接引用</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>具备动态性，非编译期也可以产生常量，运行期间可以将常量放入池中，例如String的intern() 方法</li>\n<li>当申请不到新内存时，抛出OutOfMemoryError</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><ul>\n<li>作用：<ul>\n<li>用于避免Java堆与native对来回复制数据，提高某些场景的性能</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>非虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域</li>\n<li>基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用来操作</li>\n<li>动态拓展时申请不到足够内存会抛出OutOfMemoryError</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java-Memory-Model（java内存模型）\"><a href=\"#Java-Memory-Model（java内存模型）\" class=\"headerlink\" title=\"Java Memory Model（java内存模型）\"></a>Java Memory Model（java内存模型）</h2><ul>\n<li>作用：<ul>\n<li>控制线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见</li>\n<li>定义程序中各个变量的访问规则</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>共享内存的并发模型，线程之间通过读写共享变量（堆内存中的实例域、静态域、数组元素）来完成隐式通信</li>\n<li>所有变量都存储在主内存中，每条线程有自己的私有内存，也叫工作内存，线程对变量的操作必须在工作内存中进行，不能直接操作主内存中的变量，工作内存中存储了变量副本</li>\n<li>属于语言级的内存模型，在不同的编译器、处理器上，通过禁止特定类型的编译器重排序和处理器重排序（指令级并行重排序、内存系统重排序），确保为程序员提供一致的内存可见性</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><ul>\n<li>作用：<ul>\n<li>编译器和处理器为了提高性能，会对指令重排序</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>编译器优化的重排序：<ul>\n<li>编译器在不改变程序语义的情况下，可以重排语句执行顺序</li>\n</ul>\n</li>\n<li>指令级并行的重排序：<ul>\n<li>现代处理器提供了指令级并行技术来将多条指令并行执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>\n</ul>\n</li>\n<li>内存系统的重排序：<ul>\n<li>由于处理器使用了缓存和读写缓冲区，使加载和存储操作看上去是在乱序执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>从Java源代码到执行指令序列：<ul>\n<li>源代码 &gt; 编译器优化重排序 &gt; 指令级重排序 &gt; 内存系统重排序 &gt; 最终执行的指令序列        </li>\n</ul>\n</li>\n<li>Java进制处理器重排序方式：<ul>\n<li>生成指令序列的内存屏障，即重排序时不能把内存屏障指令重排到之前来实现的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"happens-before\"><a href=\"#happens-before\" class=\"headerlink\" title=\"happens-before\"></a>happens-before</h2><ul>\n<li>作用：<ul>\n<li>描述操作之间的内存可见性（可见性：指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的）</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>JDK5出现</li>\n<li>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间</li>\n</ul>\n</li>\n<li>重要的 happens-before 规则如下：<ul>\n<li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>\n<li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>\n<li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li>\n<li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><ul>\n<li>作用：<ul>\n<li>保持变量的修改在多个线程间是同步的</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>保证变量对所有线程都是可见的</li>\n<li>volatile变量在并发情况下由于Java的非原子化操作导致线程不安全，synchronized由于统一时间内只能由一个线程操作，所以是线程安全的</li>\n<li>禁止指令重排序优化</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内存区域、内存模型\"><a href=\"#内存区域、内存模型\" class=\"headerlink\" title=\"内存区域、内存模型\"></a>内存区域、内存模型</h2><ul>\n<li>内存区域：即运行时数据区域，指JVM对于不同类型数据在内存中的存储方式</li>\n<li>内存模型（JMM：Java Memory Model）：定义了线程与主内存之间的抽象关系，即JVM在内存中的工作方式，即JVM使用内存区域中的数据的方式</li>\n</ul>\n<h2 id=\"JDK8之后的内存区域：\"><a href=\"#JDK8之后的内存区域：\" class=\"headerlink\" title=\"JDK8之后的内存区域：\"></a>JDK8之后的内存区域：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* Native Method Stacks（本地方法栈）</span><br><span class=\"line\">* Program Counter Register（程序计数器）</span><br><span class=\"line\">* Java Virtual Machine Stacks（JVM Stacks，即虚拟机栈）</span><br><span class=\"line\">    * Stack Frame（栈帧）</span><br><span class=\"line\">        * 局部变量表</span><br><span class=\"line\">        * 操作栈</span><br><span class=\"line\">        * 动态连接</span><br><span class=\"line\">        * 方法返回地址</span><br><span class=\"line\">    * Stack Frame（栈帧）</span><br><span class=\"line\">        * 局部变量表</span><br><span class=\"line\">        * 操作栈</span><br><span class=\"line\">        * 动态连接</span><br><span class=\"line\">        * 方法返回地址</span><br><span class=\"line\">* Heap（堆区）</span><br><span class=\"line\">    * Young区（新生代）</span><br><span class=\"line\">        * Eden</span><br><span class=\"line\">        * S0</span><br><span class=\"line\">        * S1</span><br><span class=\"line\">    * Old区（老年代）</span><br><span class=\"line\">* Method Area（方法区）</span><br><span class=\"line\">    * Runtime Constant Pool（运行时常量池）</span><br><span class=\"line\">    * 方法元信息</span><br><span class=\"line\">    * klass类元信息</span><br><span class=\"line\">* CodeCache（JIT编译产物） </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Program-Counter-Register-程序计数器\"><a href=\"#Program-Counter-Register-程序计数器\" class=\"headerlink\" title=\"Program Counter Register (程序计数器)\"></a>Program Counter Register (程序计数器)</h3><ul>\n<li>作用：当前线程所执行的字节码的行号指示器，当多线程切换时，使线程恢复后找到正确的执行位置</li>\n<li>特点：<ul>\n<li>内存占用少</li>\n<li>线程私有</li>\n<li>当前线程执行Java方法，计数器保存虚拟机中字节码指令地址；执行Native方法，记录null</li>\n<li>唯一一个在JVM规范中没有规定OutOfMemoryError的区域</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JVM-Stacks\"><a href=\"#JVM-Stacks\" class=\"headerlink\" title=\"JVM Stacks\"></a>JVM Stacks</h3><ul>\n<li>概念：<ul>\n<li>活动线程：当前正在执行的线程</li>\n<li>当前帧：正在执行的方法对应的栈帧，由于只有栈顶帧有效，所以当前帧也是栈顶帧</li>\n<li>当前方法：正在执行的方法</li>\n</ul>\n</li>\n<li>简介：描述了Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧（Stack Frame：栈中的一个元素，方法运行时的基础数据结构），存储局部变量表，操作数栈、动态连接、方法出口等。每一个方法从调用到执行完的过程，对应一个栈帧入栈出栈过程</li>\n<li>作用：保存Java方法执行的时候需要的各种数据、参数</li>\n<li>特点：<ul>\n<li>线程私有</li>\n<li>生命周期与线程相同</li>\n<li>执行引擎运行时，所有指令都只能对当前帧操作</li>\n<li>一个方法对应一个栈帧</li>\n</ul>\n</li>\n<li>组成：<ul>\n<li><h4 id=\"Stack-Frame（栈帧）：\"><a href=\"#Stack-Frame（栈帧）：\" class=\"headerlink\" title=\"Stack Frame（栈帧）：\"></a>Stack Frame（栈帧）：</h4><ul>\n<li>介绍：一个栈帧对应一个方法执行需要的数据</li>\n<li>JVM规定的与栈帧相关异常：<ul>\n<li>线程请求的栈深度大于JVM允许的深度，抛出StackOverflowError</li>\n<li>对于当前大多数可以拓展的JVM栈，在拓展时申请不到足够内存，抛出OutOfMemoryError</li>\n</ul>\n</li>\n<li>组成：<ul>\n<li><h4 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h4><ul>\n<li>作用：存放方法参数和局部变量，字节码指令中的STORE指令就是将操作栈中计算完成局部变量写到当前帧的局部变量表中</li>\n<li>特点：<ul>\n<li>必须显示初始化，才能使用</li>\n<li>如果是非静态方法，会在index[0]位置存储方法所属对象的实例引用，占用4字节，后面存储方法参数和局部变量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h4 id=\"操作栈\"><a href=\"#操作栈\" class=\"headerlink\" title=\"操作栈\"></a>操作栈</h4><ul>\n<li>作用：用于方法执行过程中信息的存取</li>\n<li>简介：JVM的执行引擎是基于栈的执行引擎，其中的栈即操作栈，方法执行时，使用操作栈进行存取信息</li>\n<li>关联：<ul>\n<li>字节码指令集即基于栈类型，栈深度保存在方法元信息的栈属性中</li>\n<li>例：<ul>\n<li>++i：总体思路是按顺序执行，先将局部变量表中的i执行加1操作（load memory&amp;add&amp;store memory），然后放到操作栈中(load memory)，此时从操作栈栈顶取出的i就是加1之后的</li>\n<li>i++：按照按顺序执行的思路，先将i放到操作栈中(load memory)，然后执行加1的操作(add memory)，加1之后的值更新到局部变量表中(store memory)，此时从栈顶读取到的i未加1，所以如果多线程操作i的时候，可能从局部变量表读到的i比预期的小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>初始状态为空桶式结构栈</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h4 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h4><ul>\n<li>介绍：每个栈帧中包含一个在常量池中对当前方法的引用，目的是为了支持方法调用过程的动态连接</li>\n</ul>\n</li>\n<li><h4 id=\"方法返回地址：\"><a href=\"#方法返回地址：\" class=\"headerlink\" title=\"方法返回地址：\"></a>方法返回地址：</h4><ul>\n<li>方法执行退出情况：<ul>\n<li>正常退出，遇到返回字节码指令，比如return、ireturn、areturn</li>\n<li>异常退出</li>\n</ul>\n</li>\n<li>介绍：即方法调用完成返回的位置，方法调用完成后会弹出当前栈帧</li>\n<li>退出后行为：<ul>\n<li>返回值压入上层调用栈帧 </li>\n<li>异常抛给能处理的栈帧</li>\n<li>程序计数器指向方法调用后的下一条指令    </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Native-Method-Stacks-本地方法栈\"><a href=\"#Native-Method-Stacks-本地方法栈\" class=\"headerlink\" title=\"Native Method Stacks(本地方法栈)\"></a>Native Method Stacks(本地方法栈)</h3><ul>\n<li>介绍：与JVM Stacks类似，但保存的是Native方法对应的栈帧</li>\n<li>特点：<ul>\n<li>也会抛出StackOverFlowError和OutOfMemoryError</li>\n<li>线程调用本地方法时，不受JVM约束</li>\n<li>本地方法通过JNI(Java Native Interface)来访问JVM的数据，可以调用寄存器，具有JVM相同的能力、权限</li>\n<li>大量本地方法运行时，会削弱JVM对系统控制力，本地方法出错信息比较黑盒</li>\n<li>本地方法栈会在内存不足时抛出NativeHeapOutOfMemory</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Heap（堆）\"><a href=\"#Heap（堆）\" class=\"headerlink\" title=\"Heap（堆）\"></a>Heap（堆）</h3><ul>\n<li>介绍：存放对象实例，几乎所有的对象实例都在这里分配内存</li>\n<li>特点：<ul>\n<li>对大多数应用来说，Heap是JVM管理内存中最大的一块</li>\n<li>被所有线程共享</li>\n<li>虚拟机启动时创建</li>\n<li>GC管理的主要区域，有时候也成Heap为GC Heap</li>\n<li>内部可能包含多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）</li>\n<li>可以由物理上不连续的内存空间组成，只要逻辑上连续即可</li>\n<li>当堆中无内存完成实例分配，并且无法拓展时，会抛出OutOfMemoryError</li>\n</ul>\n</li>\n<li>按照GC中的分代回收算法分类：<ul>\n<li>新生代<ul>\n<li>Eden</li>\n<li>S0</li>\n<li>S1</li>\n</ul>\n</li>\n<li>老年代 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Metaspace（元数据区）\"><a href=\"#Metaspace（元数据区）\" class=\"headerlink\" title=\"Metaspace（元数据区）\"></a>Metaspace（元数据区）</h3><ul>\n<li>组成：<ul>\n<li><h4 id=\"Method-Area（方法区）\"><a href=\"#Method-Area（方法区）\" class=\"headerlink\" title=\"Method Area（方法区）\"></a>Method Area（方法区）</h4><ul>\n<li>特点：<ul>\n<li>线程共享</li>\n<li>存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>\n<li>JVM对该区域限制非常松，可选择不实现垃圾回收</li>\n<li>垃圾回收在该区域出现少，主要是回收运行时常量池和类元信息</li>\n<li>当方法区无法满足内存分配需求时，抛出OutOfMemoryError</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h4 id=\"Runtime-Constant-Pool（运行时常量池）\"><a href=\"#Runtime-Constant-Pool（运行时常量池）\" class=\"headerlink\" title=\"Runtime Constant Pool（运行时常量池）\"></a>Runtime Constant Pool（运行时常量池）</h4><ul>\n<li>作用：<ul>\n<li>用于存放编译器生成的各种字面量、符号引用、翻译出来的直接引用</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>具备动态性，非编译期也可以产生常量，运行期间可以将常量放入池中，例如String的intern() 方法</li>\n<li>当申请不到新内存时，抛出OutOfMemoryError</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><ul>\n<li>作用：<ul>\n<li>用于避免Java堆与native对来回复制数据，提高某些场景的性能</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>非虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域</li>\n<li>基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用来操作</li>\n<li>动态拓展时申请不到足够内存会抛出OutOfMemoryError</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java-Memory-Model（java内存模型）\"><a href=\"#Java-Memory-Model（java内存模型）\" class=\"headerlink\" title=\"Java Memory Model（java内存模型）\"></a>Java Memory Model（java内存模型）</h2><ul>\n<li>作用：<ul>\n<li>控制线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见</li>\n<li>定义程序中各个变量的访问规则</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>共享内存的并发模型，线程之间通过读写共享变量（堆内存中的实例域、静态域、数组元素）来完成隐式通信</li>\n<li>所有变量都存储在主内存中，每条线程有自己的私有内存，也叫工作内存，线程对变量的操作必须在工作内存中进行，不能直接操作主内存中的变量，工作内存中存储了变量副本</li>\n<li>属于语言级的内存模型，在不同的编译器、处理器上，通过禁止特定类型的编译器重排序和处理器重排序（指令级并行重排序、内存系统重排序），确保为程序员提供一致的内存可见性</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"重排序\"><a href=\"#重排序\" class=\"headerlink\" title=\"重排序\"></a>重排序</h2><ul>\n<li>作用：<ul>\n<li>编译器和处理器为了提高性能，会对指令重排序</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>编译器优化的重排序：<ul>\n<li>编译器在不改变程序语义的情况下，可以重排语句执行顺序</li>\n</ul>\n</li>\n<li>指令级并行的重排序：<ul>\n<li>现代处理器提供了指令级并行技术来将多条指令并行执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>\n</ul>\n</li>\n<li>内存系统的重排序：<ul>\n<li>由于处理器使用了缓存和读写缓冲区，使加载和存储操作看上去是在乱序执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>从Java源代码到执行指令序列：<ul>\n<li>源代码 &gt; 编译器优化重排序 &gt; 指令级重排序 &gt; 内存系统重排序 &gt; 最终执行的指令序列        </li>\n</ul>\n</li>\n<li>Java进制处理器重排序方式：<ul>\n<li>生成指令序列的内存屏障，即重排序时不能把内存屏障指令重排到之前来实现的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"happens-before\"><a href=\"#happens-before\" class=\"headerlink\" title=\"happens-before\"></a>happens-before</h2><ul>\n<li>作用：<ul>\n<li>描述操作之间的内存可见性（可见性：指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的）</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>JDK5出现</li>\n<li>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间</li>\n</ul>\n</li>\n<li>重要的 happens-before 规则如下：<ul>\n<li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>\n<li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>\n<li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li>\n<li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><ul>\n<li>作用：<ul>\n<li>保持变量的修改在多个线程间是同步的</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>保证变量对所有线程都是可见的</li>\n<li>volatile变量在并发情况下由于Java的非原子化操作导致线程不安全，synchronized由于统一时间内只能由一个线程操作，所以是线程安全的</li>\n<li>禁止指令重排序优化</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Java概述","date":"2021-08-21T07:24:01.000Z","_content":"\n### 计算机语言\n* 人与计算机之间交流沟通的工具\n\n### Java简介\n* Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全、与系统无关、可移植、高性能、多线程和动态的语言\n\n### Java发展史\n* 发明人：詹姆斯高斯林\n* 发明公司：Sun\n* 发展节点：\n  * 5.0进入发展快车道\n  * 8.0目前商业化应用最多\n  * 当前建议学习11.0\n","source":"_posts/Java/Java概述.md","raw":"---\ntitle: Java概述\ndate: 2021-08-21 15:24:01\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 计算机语言\n* 人与计算机之间交流沟通的工具\n\n### Java简介\n* Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全、与系统无关、可移植、高性能、多线程和动态的语言\n\n### Java发展史\n* 发明人：詹姆斯高斯林\n* 发明公司：Sun\n* 发展节点：\n  * 5.0进入发展快车道\n  * 8.0目前商业化应用最多\n  * 当前建议学习11.0\n","slug":"Java/Java概述","published":1,"updated":"2022-04-12T09:00:46.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ad0005wgtthu6dhafk","content":"<h3 id=\"计算机语言\"><a href=\"#计算机语言\" class=\"headerlink\" title=\"计算机语言\"></a>计算机语言</h3><ul>\n<li>人与计算机之间交流沟通的工具</li>\n</ul>\n<h3 id=\"Java简介\"><a href=\"#Java简介\" class=\"headerlink\" title=\"Java简介\"></a>Java简介</h3><ul>\n<li>Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全、与系统无关、可移植、高性能、多线程和动态的语言</li>\n</ul>\n<h3 id=\"Java发展史\"><a href=\"#Java发展史\" class=\"headerlink\" title=\"Java发展史\"></a>Java发展史</h3><ul>\n<li>发明人：詹姆斯高斯林</li>\n<li>发明公司：Sun</li>\n<li>发展节点：<ul>\n<li>5.0进入发展快车道</li>\n<li>8.0目前商业化应用最多</li>\n<li>当前建议学习11.0</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"计算机语言\"><a href=\"#计算机语言\" class=\"headerlink\" title=\"计算机语言\"></a>计算机语言</h3><ul>\n<li>人与计算机之间交流沟通的工具</li>\n</ul>\n<h3 id=\"Java简介\"><a href=\"#Java简介\" class=\"headerlink\" title=\"Java简介\"></a>Java简介</h3><ul>\n<li>Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全、与系统无关、可移植、高性能、多线程和动态的语言</li>\n</ul>\n<h3 id=\"Java发展史\"><a href=\"#Java发展史\" class=\"headerlink\" title=\"Java发展史\"></a>Java发展史</h3><ul>\n<li>发明人：詹姆斯高斯林</li>\n<li>发明公司：Sun</li>\n<li>发展节点：<ul>\n<li>5.0进入发展快车道</li>\n<li>8.0目前商业化应用最多</li>\n<li>当前建议学习11.0</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Java注释","date":"2021-08-25T12:45:38.000Z","_content":"### 三种注释格式\n* 单行注释\n```\n// 单行注释\n```\n\n* 多行注释\n```\n/*\n多行注释\n多行注释\n多行注释\n*/\n```\n\n* javadoc注释\n```\n/**\nJavadoc注释\nJavadoc注释\nJavadoc注释\n* @author 作者名称\n*/\n```\n\n### javadoc标签\n* [标签描述参考文章](https://www.runoob.com/java/java-documentation.html)\n\n### 自定义注释\n* IDE工具中一般都有自定义注释的功能，可以自行进行编辑，然后配合快捷键进行使用\n\n### 需要注意的点\n* 注释仅存在文档中，不参与编译运行\n","source":"_posts/Java/Java注释.md","raw":"---\ntitle: Java注释\ndate: 2021-08-25 20:45:38\ntags: 编程\ncategories:\n- [Java]\n---\n### 三种注释格式\n* 单行注释\n```\n// 单行注释\n```\n\n* 多行注释\n```\n/*\n多行注释\n多行注释\n多行注释\n*/\n```\n\n* javadoc注释\n```\n/**\nJavadoc注释\nJavadoc注释\nJavadoc注释\n* @author 作者名称\n*/\n```\n\n### javadoc标签\n* [标签描述参考文章](https://www.runoob.com/java/java-documentation.html)\n\n### 自定义注释\n* IDE工具中一般都有自定义注释的功能，可以自行进行编辑，然后配合快捷键进行使用\n\n### 需要注意的点\n* 注释仅存在文档中，不参与编译运行\n","slug":"Java/Java注释","published":1,"updated":"2022-04-12T09:00:46.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ae0006wgtt7ip46iy4","content":"<h3 id=\"三种注释格式\"><a href=\"#三种注释格式\" class=\"headerlink\" title=\"三种注释格式\"></a>三种注释格式</h3><ul>\n<li><p>单行注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 单行注释</span><br></pre></td></tr></table></figure></li>\n<li><p>多行注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></li>\n<li><p>javadoc注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">Javadoc注释</span><br><span class=\"line\">Javadoc注释</span><br><span class=\"line\">Javadoc注释</span><br><span class=\"line\">* @author 作者名称</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"javadoc标签\"><a href=\"#javadoc标签\" class=\"headerlink\" title=\"javadoc标签\"></a>javadoc标签</h3><ul>\n<li><a href=\"https://www.runoob.com/java/java-documentation.html\">标签描述参考文章</a></li>\n</ul>\n<h3 id=\"自定义注释\"><a href=\"#自定义注释\" class=\"headerlink\" title=\"自定义注释\"></a>自定义注释</h3><ul>\n<li>IDE工具中一般都有自定义注释的功能，可以自行进行编辑，然后配合快捷键进行使用</li>\n</ul>\n<h3 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h3><ul>\n<li>注释仅存在文档中，不参与编译运行</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"三种注释格式\"><a href=\"#三种注释格式\" class=\"headerlink\" title=\"三种注释格式\"></a>三种注释格式</h3><ul>\n<li><p>单行注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 单行注释</span><br></pre></td></tr></table></figure></li>\n<li><p>多行注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></li>\n<li><p>javadoc注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">Javadoc注释</span><br><span class=\"line\">Javadoc注释</span><br><span class=\"line\">Javadoc注释</span><br><span class=\"line\">* @author 作者名称</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"javadoc标签\"><a href=\"#javadoc标签\" class=\"headerlink\" title=\"javadoc标签\"></a>javadoc标签</h3><ul>\n<li><a href=\"https://www.runoob.com/java/java-documentation.html\">标签描述参考文章</a></li>\n</ul>\n<h3 id=\"自定义注释\"><a href=\"#自定义注释\" class=\"headerlink\" title=\"自定义注释\"></a>自定义注释</h3><ul>\n<li>IDE工具中一般都有自定义注释的功能，可以自行进行编辑，然后配合快捷键进行使用</li>\n</ul>\n<h3 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h3><ul>\n<li>注释仅存在文档中，不参与编译运行</li>\n</ul>\n"},{"title":"Java程序运行流程","date":"2021-08-25T07:29:57.000Z","_content":"\n### Java运行流程\n* **Java源代码** --- 编译工具 ---> **Java字节码文件** --- 运行工具 ---> **Java程序运行**\n\n### Java程序的基本单位\n* 类\n\n### Java程序执行入口\n* main方法\n","source":"_posts/Java/Java程序运行流程.md","raw":"---\ntitle: Java程序运行流程\ndate: 2021-08-25 15:29:57\ntags: 编程\ncategories:\n- [Java]\n---\n\n### Java运行流程\n* **Java源代码** --- 编译工具 ---> **Java字节码文件** --- 运行工具 ---> **Java程序运行**\n\n### Java程序的基本单位\n* 类\n\n### Java程序执行入口\n* main方法\n","slug":"Java/Java程序运行流程","published":1,"updated":"2022-04-12T09:00:46.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ah000awgtthop0dub6","content":"<h3 id=\"Java运行流程\"><a href=\"#Java运行流程\" class=\"headerlink\" title=\"Java运行流程\"></a>Java运行流程</h3><ul>\n<li><strong>Java源代码</strong> — 编译工具 —&gt; <strong>Java字节码文件</strong> — 运行工具 —&gt; <strong>Java程序运行</strong></li>\n</ul>\n<h3 id=\"Java程序的基本单位\"><a href=\"#Java程序的基本单位\" class=\"headerlink\" title=\"Java程序的基本单位\"></a>Java程序的基本单位</h3><ul>\n<li>类</li>\n</ul>\n<h3 id=\"Java程序执行入口\"><a href=\"#Java程序执行入口\" class=\"headerlink\" title=\"Java程序执行入口\"></a>Java程序执行入口</h3><ul>\n<li>main方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Java运行流程\"><a href=\"#Java运行流程\" class=\"headerlink\" title=\"Java运行流程\"></a>Java运行流程</h3><ul>\n<li><strong>Java源代码</strong> — 编译工具 —&gt; <strong>Java字节码文件</strong> — 运行工具 —&gt; <strong>Java程序运行</strong></li>\n</ul>\n<h3 id=\"Java程序的基本单位\"><a href=\"#Java程序的基本单位\" class=\"headerlink\" title=\"Java程序的基本单位\"></a>Java程序的基本单位</h3><ul>\n<li>类</li>\n</ul>\n<h3 id=\"Java程序执行入口\"><a href=\"#Java程序执行入口\" class=\"headerlink\" title=\"Java程序执行入口\"></a>Java程序执行入口</h3><ul>\n<li>main方法</li>\n</ul>\n"},{"title":"Java类","date":"2021-09-25T09:13:23.000Z","_content":"\n## \n","source":"_posts/Java/Java类.md","raw":"---\ntitle: Java类\ndate: 2021-09-25 17:13:23\ntags: 编程\ncategories:\n- [Java]\n---\n\n## \n","slug":"Java/Java类","published":1,"updated":"2022-04-12T09:00:46.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ai000cwgtt1x0ackg8","content":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"},{"title":"java-package","date":"2021-10-21T12:06:46.000Z","_content":"\n### 命名规则\n* 示例：package:com.liquangang\n\n\n### 单独执行文件中无包名文件\n* 示例：java com.liquangang.HelloWorld","source":"_posts/Java/java-package.md","raw":"---\ntitle: java-package\ndate: 2021-10-21 20:06:46\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 命名规则\n* 示例：package:com.liquangang\n\n\n### 单独执行文件中无包名文件\n* 示例：java com.liquangang.HelloWorld","slug":"Java/java-package","published":1,"updated":"2022-04-12T09:00:46.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ak000gwgttb8eddty6","content":"<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><ul>\n<li>示例：package:com.liquangang</li>\n</ul>\n<h3 id=\"单独执行文件中无包名文件\"><a href=\"#单独执行文件中无包名文件\" class=\"headerlink\" title=\"单独执行文件中无包名文件\"></a>单独执行文件中无包名文件</h3><ul>\n<li>示例：java com.liquangang.HelloWorld</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><ul>\n<li>示例：package:com.liquangang</li>\n</ul>\n<h3 id=\"单独执行文件中无包名文件\"><a href=\"#单独执行文件中无包名文件\" class=\"headerlink\" title=\"单独执行文件中无包名文件\"></a>单独执行文件中无包名文件</h3><ul>\n<li>示例：java com.liquangang.HelloWorld</li>\n</ul>\n"},{"title":"json","date":"2021-10-11T11:02:23.000Z","_content":"\n### 示例代码\n* 获取json串中的key、value：\n```\npublic static void testReadJson() {\n        try\n        {\n            String heartbeatString = FileUtil.readJsonFile(\n                    \"/Users/liquangang/work/chengfeng2.0/baidu/face-link/face-link-deviceSimulation/src/test/java/com/baidu/facelink/websocket/testJson/Heartbeat.json\");\n            JsonParser p = new JsonParser();\n            JsonElement e = p.parse(heartbeatString);\n            jsonTree(e, new JsonKeyAndValueHandle() {\n                @Override\n                public void handleKey(String key) {\n                    System.out.println(key);\n                }\n\n                @Override\n                public void handleValue(JsonElement e) {\n                    System.out.println(e.toString());\n                }\n\n                @Override\n                public void handleKeyAndValue(Map.Entry<String, JsonElement> en) {\n                    if (en.getKey().equals(\"deviceId\")) {\n                        en.setValue(new Gson().toJsonTree(\"DMCM020AYC21E00252\"));\n                    }\n\n                    if (en.getKey().equals(\"appId\")) {\n                        en.setValue(new Gson().toJsonTree(\"692805283478\"));\n                    }\n                }\n            });\n\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    public static void jsonTree(JsonElement e, JsonKeyAndValueHandle jsonKeyAndValueHandle)\n    {\n        if (e.isJsonNull())\n        {\n            jsonKeyAndValueHandle.handleValue(e);\n            return;\n        }\n\n        if (e.isJsonPrimitive())\n        {\n            jsonKeyAndValueHandle.handleValue(e);\n            return;\n        }\n\n        if (e.isJsonArray())\n        {\n            JsonArray ja = e.getAsJsonArray();\n            if (null != ja)\n            {\n                for (JsonElement ae : ja)\n                {\n                    jsonTree(ae, jsonKeyAndValueHandle);\n                }\n            }\n            return;\n        }\n\n        if (e.isJsonObject())\n        {\n            Set<Map.Entry<String, JsonElement>> es = e.getAsJsonObject().entrySet();\n            for (Map.Entry<String, JsonElement> en : es)\n            {\n                jsonKeyAndValueHandle.handleKey(en.getKey());\n                jsonKeyAndValueHandle.handleKeyAndValue(en);\n                jsonTree(en.getValue(), jsonKeyAndValueHandle);\n            }\n        }\n    }\n\n    public interface JsonKeyAndValueHandle {\n        void handleKey(String key);\n        void handleValue(JsonElement e);\n        void handleKeyAndValue(Map.Entry<String, JsonElement> en);\n    }\n\n```","source":"_posts/Java/json.md","raw":"---\ntitle: json\ndate: 2021-10-11 19:02:23\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 示例代码\n* 获取json串中的key、value：\n```\npublic static void testReadJson() {\n        try\n        {\n            String heartbeatString = FileUtil.readJsonFile(\n                    \"/Users/liquangang/work/chengfeng2.0/baidu/face-link/face-link-deviceSimulation/src/test/java/com/baidu/facelink/websocket/testJson/Heartbeat.json\");\n            JsonParser p = new JsonParser();\n            JsonElement e = p.parse(heartbeatString);\n            jsonTree(e, new JsonKeyAndValueHandle() {\n                @Override\n                public void handleKey(String key) {\n                    System.out.println(key);\n                }\n\n                @Override\n                public void handleValue(JsonElement e) {\n                    System.out.println(e.toString());\n                }\n\n                @Override\n                public void handleKeyAndValue(Map.Entry<String, JsonElement> en) {\n                    if (en.getKey().equals(\"deviceId\")) {\n                        en.setValue(new Gson().toJsonTree(\"DMCM020AYC21E00252\"));\n                    }\n\n                    if (en.getKey().equals(\"appId\")) {\n                        en.setValue(new Gson().toJsonTree(\"692805283478\"));\n                    }\n                }\n            });\n\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    public static void jsonTree(JsonElement e, JsonKeyAndValueHandle jsonKeyAndValueHandle)\n    {\n        if (e.isJsonNull())\n        {\n            jsonKeyAndValueHandle.handleValue(e);\n            return;\n        }\n\n        if (e.isJsonPrimitive())\n        {\n            jsonKeyAndValueHandle.handleValue(e);\n            return;\n        }\n\n        if (e.isJsonArray())\n        {\n            JsonArray ja = e.getAsJsonArray();\n            if (null != ja)\n            {\n                for (JsonElement ae : ja)\n                {\n                    jsonTree(ae, jsonKeyAndValueHandle);\n                }\n            }\n            return;\n        }\n\n        if (e.isJsonObject())\n        {\n            Set<Map.Entry<String, JsonElement>> es = e.getAsJsonObject().entrySet();\n            for (Map.Entry<String, JsonElement> en : es)\n            {\n                jsonKeyAndValueHandle.handleKey(en.getKey());\n                jsonKeyAndValueHandle.handleKeyAndValue(en);\n                jsonTree(en.getValue(), jsonKeyAndValueHandle);\n            }\n        }\n    }\n\n    public interface JsonKeyAndValueHandle {\n        void handleKey(String key);\n        void handleValue(JsonElement e);\n        void handleKeyAndValue(Map.Entry<String, JsonElement> en);\n    }\n\n```","slug":"Java/json","published":1,"updated":"2022-04-12T09:00:46.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0al000jwgtt4xe94bkz","content":"<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><ul>\n<li>获取json串中的key、value：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void testReadJson() &#123;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            String heartbeatString = FileUtil.readJsonFile(</span><br><span class=\"line\">                    &quot;/Users/liquangang/work/chengfeng2.0/baidu/face-link/face-link-deviceSimulation/src/test/java/com/baidu/facelink/websocket/testJson/Heartbeat.json&quot;);</span><br><span class=\"line\">            JsonParser p = new JsonParser();</span><br><span class=\"line\">            JsonElement e = p.parse(heartbeatString);</span><br><span class=\"line\">            jsonTree(e, new JsonKeyAndValueHandle() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void handleKey(String key) &#123;</span><br><span class=\"line\">                    System.out.println(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void handleValue(JsonElement e) &#123;</span><br><span class=\"line\">                    System.out.println(e.toString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void handleKeyAndValue(Map.Entry&lt;String, JsonElement&gt; en) &#123;</span><br><span class=\"line\">                    if (en.getKey().equals(&quot;deviceId&quot;)) &#123;</span><br><span class=\"line\">                        en.setValue(new Gson().toJsonTree(&quot;DMCM020AYC21E00252&quot;));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    if (en.getKey().equals(&quot;appId&quot;)) &#123;</span><br><span class=\"line\">                        en.setValue(new Gson().toJsonTree(&quot;692805283478&quot;));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch(Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void jsonTree(JsonElement e, JsonKeyAndValueHandle jsonKeyAndValueHandle)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (e.isJsonNull())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            jsonKeyAndValueHandle.handleValue(e);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (e.isJsonPrimitive())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            jsonKeyAndValueHandle.handleValue(e);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (e.isJsonArray())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            JsonArray ja = e.getAsJsonArray();</span><br><span class=\"line\">            if (null != ja)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (JsonElement ae : ja)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    jsonTree(ae, jsonKeyAndValueHandle);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (e.isJsonObject())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; es = e.getAsJsonObject().entrySet();</span><br><span class=\"line\">            for (Map.Entry&lt;String, JsonElement&gt; en : es)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                jsonKeyAndValueHandle.handleKey(en.getKey());</span><br><span class=\"line\">                jsonKeyAndValueHandle.handleKeyAndValue(en);</span><br><span class=\"line\">                jsonTree(en.getValue(), jsonKeyAndValueHandle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface JsonKeyAndValueHandle &#123;</span><br><span class=\"line\">        void handleKey(String key);</span><br><span class=\"line\">        void handleValue(JsonElement e);</span><br><span class=\"line\">        void handleKeyAndValue(Map.Entry&lt;String, JsonElement&gt; en);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><ul>\n<li>获取json串中的key、value：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void testReadJson() &#123;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            String heartbeatString = FileUtil.readJsonFile(</span><br><span class=\"line\">                    &quot;/Users/liquangang/work/chengfeng2.0/baidu/face-link/face-link-deviceSimulation/src/test/java/com/baidu/facelink/websocket/testJson/Heartbeat.json&quot;);</span><br><span class=\"line\">            JsonParser p = new JsonParser();</span><br><span class=\"line\">            JsonElement e = p.parse(heartbeatString);</span><br><span class=\"line\">            jsonTree(e, new JsonKeyAndValueHandle() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void handleKey(String key) &#123;</span><br><span class=\"line\">                    System.out.println(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void handleValue(JsonElement e) &#123;</span><br><span class=\"line\">                    System.out.println(e.toString());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void handleKeyAndValue(Map.Entry&lt;String, JsonElement&gt; en) &#123;</span><br><span class=\"line\">                    if (en.getKey().equals(&quot;deviceId&quot;)) &#123;</span><br><span class=\"line\">                        en.setValue(new Gson().toJsonTree(&quot;DMCM020AYC21E00252&quot;));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    if (en.getKey().equals(&quot;appId&quot;)) &#123;</span><br><span class=\"line\">                        en.setValue(new Gson().toJsonTree(&quot;692805283478&quot;));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch(Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void jsonTree(JsonElement e, JsonKeyAndValueHandle jsonKeyAndValueHandle)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (e.isJsonNull())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            jsonKeyAndValueHandle.handleValue(e);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (e.isJsonPrimitive())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            jsonKeyAndValueHandle.handleValue(e);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (e.isJsonArray())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            JsonArray ja = e.getAsJsonArray();</span><br><span class=\"line\">            if (null != ja)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                for (JsonElement ae : ja)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    jsonTree(ae, jsonKeyAndValueHandle);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (e.isJsonObject())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; es = e.getAsJsonObject().entrySet();</span><br><span class=\"line\">            for (Map.Entry&lt;String, JsonElement&gt; en : es)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                jsonKeyAndValueHandle.handleKey(en.getKey());</span><br><span class=\"line\">                jsonKeyAndValueHandle.handleKeyAndValue(en);</span><br><span class=\"line\">                jsonTree(en.getValue(), jsonKeyAndValueHandle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public interface JsonKeyAndValueHandle &#123;</span><br><span class=\"line\">        void handleKey(String key);</span><br><span class=\"line\">        void handleValue(JsonElement e);</span><br><span class=\"line\">        void handleKeyAndValue(Map.Entry&lt;String, JsonElement&gt; en);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Java跨平台原理","date":"2021-08-21T09:39:04.000Z","_content":"\n* 平台：指可以运行代码的操作系统\n* JVM：Java virtual machine，Java实现跨平台的软件\n","source":"_posts/Java/Java跨平台原理.md","raw":"---\ntitle: Java跨平台原理\ndate: 2021-08-21 17:39:04\ntags: 编程\ncategories:\n- [Java]\n---\n\n* 平台：指可以运行代码的操作系统\n* JVM：Java virtual machine，Java实现跨平台的软件\n","slug":"Java/Java跨平台原理","published":1,"updated":"2022-04-12T09:00:46.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0an000mwgtt8xqnef4m","content":"<ul>\n<li>平台：指可以运行代码的操作系统</li>\n<li>JVM：Java virtual machine，Java实现跨平台的软件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>平台：指可以运行代码的操作系统</li>\n<li>JVM：Java virtual machine，Java实现跨平台的软件</li>\n</ul>\n"},{"title":"关键字、标识符","date":"2021-08-26T12:59:33.000Z","_content":"### 关键字\n* 特点：\n  * 小写\n\n### 标识符\n* 作用：用于给常量、变量、函数、语句块等进行命名\n* 组成:\n  * 字母\n  * 数字\n  * 下划线（_）\n  * 美元符号（$）\n* 特点：\n  * 第一个字符不能是数字\n  * 不能使用关键字和保留字\n  * 无长度限制\n  * 区分大小写\n  \n  \n### final\n* 自我理解：即被修饰的东西不能被改变\n* 特点：\n    * 变量值不能变，但是引用类型其属性值可以变\n    * 类不能被继承\n    * 方法不能被重写\n    \n### static\n* 特点：可以被类的所有对象访问，包含类对象和普通对象\n","source":"_posts/Java/关键字、标识符.md","raw":"---\ntitle: 关键字、标识符\ndate: 2021-08-26 20:59:33\ntags: 编程\ncategories:\n- [Java]\n---\n### 关键字\n* 特点：\n  * 小写\n\n### 标识符\n* 作用：用于给常量、变量、函数、语句块等进行命名\n* 组成:\n  * 字母\n  * 数字\n  * 下划线（_）\n  * 美元符号（$）\n* 特点：\n  * 第一个字符不能是数字\n  * 不能使用关键字和保留字\n  * 无长度限制\n  * 区分大小写\n  \n  \n### final\n* 自我理解：即被修饰的东西不能被改变\n* 特点：\n    * 变量值不能变，但是引用类型其属性值可以变\n    * 类不能被继承\n    * 方法不能被重写\n    \n### static\n* 特点：可以被类的所有对象访问，包含类对象和普通对象\n","slug":"Java/关键字、标识符","published":1,"updated":"2022-04-12T09:00:46.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ap000pwgttbppkfj57","content":"<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li>特点：<ul>\n<li>小写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h3><ul>\n<li>作用：用于给常量、变量、函数、语句块等进行命名</li>\n<li>组成:<ul>\n<li>字母</li>\n<li>数字</li>\n<li>下划线（_）</li>\n<li>美元符号（$）</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>第一个字符不能是数字</li>\n<li>不能使用关键字和保留字</li>\n<li>无长度限制</li>\n<li>区分大小写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><ul>\n<li>自我理解：即被修饰的东西不能被改变</li>\n<li>特点：<ul>\n<li>变量值不能变，但是引用类型其属性值可以变</li>\n<li>类不能被继承</li>\n<li>方法不能被重写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><ul>\n<li>特点：可以被类的所有对象访问，包含类对象和普通对象</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li>特点：<ul>\n<li>小写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h3><ul>\n<li>作用：用于给常量、变量、函数、语句块等进行命名</li>\n<li>组成:<ul>\n<li>字母</li>\n<li>数字</li>\n<li>下划线（_）</li>\n<li>美元符号（$）</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>第一个字符不能是数字</li>\n<li>不能使用关键字和保留字</li>\n<li>无长度限制</li>\n<li>区分大小写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><ul>\n<li>自我理解：即被修饰的东西不能被改变</li>\n<li>特点：<ul>\n<li>变量值不能变，但是引用类型其属性值可以变</li>\n<li>类不能被继承</li>\n<li>方法不能被重写</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><ul>\n<li>特点：可以被类的所有对象访问，包含类对象和普通对象</li>\n</ul>\n"},{"title":"多态","date":"2021-11-03T17:30:39.000Z","_content":"\n### 多态前提\n* 有继承或实现关系\n* 有方法重写\n* 有父类引用指向子类对象\n\n\n### 多态访问成员变量、成员方法特点\n* 只能访问声明类型内有的成员变量和成员方法，比如Person p = new Student(); 此时p只能调用Person中有的成员变量和成员方法\n\n\n### 优缺点\n* 优点：可以动态的调用子类重写方法\n* 缺点：不能使用子类特有变量、方法","source":"_posts/Java/多态.md","raw":"---\ntitle: 多态\ndate: 2021-11-04 01:30:39\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 多态前提\n* 有继承或实现关系\n* 有方法重写\n* 有父类引用指向子类对象\n\n\n### 多态访问成员变量、成员方法特点\n* 只能访问声明类型内有的成员变量和成员方法，比如Person p = new Student(); 此时p只能调用Person中有的成员变量和成员方法\n\n\n### 优缺点\n* 优点：可以动态的调用子类重写方法\n* 缺点：不能使用子类特有变量、方法","slug":"Java/多态","published":1,"updated":"2022-04-12T09:00:46.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0aq000swgtt13tgdd0e","content":"<h3 id=\"多态前提\"><a href=\"#多态前提\" class=\"headerlink\" title=\"多态前提\"></a>多态前提</h3><ul>\n<li>有继承或实现关系</li>\n<li>有方法重写</li>\n<li>有父类引用指向子类对象</li>\n</ul>\n<h3 id=\"多态访问成员变量、成员方法特点\"><a href=\"#多态访问成员变量、成员方法特点\" class=\"headerlink\" title=\"多态访问成员变量、成员方法特点\"></a>多态访问成员变量、成员方法特点</h3><ul>\n<li>只能访问声明类型内有的成员变量和成员方法，比如Person p = new Student(); 此时p只能调用Person中有的成员变量和成员方法</li>\n</ul>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>优点：可以动态的调用子类重写方法</li>\n<li>缺点：不能使用子类特有变量、方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"多态前提\"><a href=\"#多态前提\" class=\"headerlink\" title=\"多态前提\"></a>多态前提</h3><ul>\n<li>有继承或实现关系</li>\n<li>有方法重写</li>\n<li>有父类引用指向子类对象</li>\n</ul>\n<h3 id=\"多态访问成员变量、成员方法特点\"><a href=\"#多态访问成员变量、成员方法特点\" class=\"headerlink\" title=\"多态访问成员变量、成员方法特点\"></a>多态访问成员变量、成员方法特点</h3><ul>\n<li>只能访问声明类型内有的成员变量和成员方法，比如Person p = new Student(); 此时p只能调用Person中有的成员变量和成员方法</li>\n</ul>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>优点：可以动态的调用子类重写方法</li>\n<li>缺点：不能使用子类特有变量、方法</li>\n</ul>\n"},{"title":"数据类型","date":"2021-08-26T12:39:22.000Z","_content":"### 存储单位\n* 8 bit = 1 Byte 一字节\n* 1024 B = 1 KB （KiloByte） 千字节\n* 1024 KB = 1 MB （MegaByte） 兆字节\n* 1024 MB = 1 GB （GigaByte） 吉字节\n* 1024 GB = 1 TB （TeraByte） 太字节\n* 1024 TB = 1 PB （PetaByte） 拍字节\n* 1024 PB = 1 EB （ExaByte） 艾字节\n* 1024 EB = 1 ZB （ZetaByte） 泽字节\n* 1024 ZB = 1 YB （YottaByte） 尧字节\n* 1024 YB = 1BB（Brontobyte）珀字节\n* 1024 BB = 1 NB （NonaByte） 诺字节\n* 1024 NB = 1 DB （DoggaByte）刀字节\n\n### 字节（Byte）\n* 计算机最小存储单元\n* 可存储开和关信息，即1和0\n\n### 数据类型\n* 基本数据类型\n  * 整形\n    * byte\n    * short\n    * int\n    * long\n  * 浮点型\n    * float\n    * double\n  * 字符\n    * char\n  * 布尔型\n    * boolean\n* 引用数据类型\n  * string\n  * class\n  * interface\n  * list\n  * map\n\n### 类型转换\n* 数据范围大小：\n  * double>float>long>int>short=char>byte\n* 自动转换（小转大）\n  * 示例：\n    * double a = 10;\n  * 注意：\n    * byte不能自动转换成char\n* 强制转换（大转小）\n  * 示例：\n    * int a = (int)1.1;\n","source":"_posts/Java/数据类型.md","raw":"---\ntitle: 数据类型\ndate: 2021-08-26 20:39:22\ntags: 编程\ncategories:\n- [Java]\n---\n### 存储单位\n* 8 bit = 1 Byte 一字节\n* 1024 B = 1 KB （KiloByte） 千字节\n* 1024 KB = 1 MB （MegaByte） 兆字节\n* 1024 MB = 1 GB （GigaByte） 吉字节\n* 1024 GB = 1 TB （TeraByte） 太字节\n* 1024 TB = 1 PB （PetaByte） 拍字节\n* 1024 PB = 1 EB （ExaByte） 艾字节\n* 1024 EB = 1 ZB （ZetaByte） 泽字节\n* 1024 ZB = 1 YB （YottaByte） 尧字节\n* 1024 YB = 1BB（Brontobyte）珀字节\n* 1024 BB = 1 NB （NonaByte） 诺字节\n* 1024 NB = 1 DB （DoggaByte）刀字节\n\n### 字节（Byte）\n* 计算机最小存储单元\n* 可存储开和关信息，即1和0\n\n### 数据类型\n* 基本数据类型\n  * 整形\n    * byte\n    * short\n    * int\n    * long\n  * 浮点型\n    * float\n    * double\n  * 字符\n    * char\n  * 布尔型\n    * boolean\n* 引用数据类型\n  * string\n  * class\n  * interface\n  * list\n  * map\n\n### 类型转换\n* 数据范围大小：\n  * double>float>long>int>short=char>byte\n* 自动转换（小转大）\n  * 示例：\n    * double a = 10;\n  * 注意：\n    * byte不能自动转换成char\n* 强制转换（大转小）\n  * 示例：\n    * int a = (int)1.1;\n","slug":"Java/数据类型","published":1,"updated":"2022-04-12T09:00:46.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ar000vwgtt20qo8fil","content":"<h3 id=\"存储单位\"><a href=\"#存储单位\" class=\"headerlink\" title=\"存储单位\"></a>存储单位</h3><ul>\n<li>8 bit = 1 Byte 一字节</li>\n<li>1024 B = 1 KB （KiloByte） 千字节</li>\n<li>1024 KB = 1 MB （MegaByte） 兆字节</li>\n<li>1024 MB = 1 GB （GigaByte） 吉字节</li>\n<li>1024 GB = 1 TB （TeraByte） 太字节</li>\n<li>1024 TB = 1 PB （PetaByte） 拍字节</li>\n<li>1024 PB = 1 EB （ExaByte） 艾字节</li>\n<li>1024 EB = 1 ZB （ZetaByte） 泽字节</li>\n<li>1024 ZB = 1 YB （YottaByte） 尧字节</li>\n<li>1024 YB = 1BB（Brontobyte）珀字节</li>\n<li>1024 BB = 1 NB （NonaByte） 诺字节</li>\n<li>1024 NB = 1 DB （DoggaByte）刀字节</li>\n</ul>\n<h3 id=\"字节（Byte）\"><a href=\"#字节（Byte）\" class=\"headerlink\" title=\"字节（Byte）\"></a>字节（Byte）</h3><ul>\n<li>计算机最小存储单元</li>\n<li>可存储开和关信息，即1和0</li>\n</ul>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li>基本数据类型<ul>\n<li>整形<ul>\n<li>byte</li>\n<li>short</li>\n<li>int</li>\n<li>long</li>\n</ul>\n</li>\n<li>浮点型<ul>\n<li>float</li>\n<li>double</li>\n</ul>\n</li>\n<li>字符<ul>\n<li>char</li>\n</ul>\n</li>\n<li>布尔型<ul>\n<li>boolean</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>引用数据类型<ul>\n<li>string</li>\n<li>class</li>\n<li>interface</li>\n<li>list</li>\n<li>map</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><ul>\n<li>数据范围大小：<ul>\n<li>double&gt;float&gt;long&gt;int&gt;short=char&gt;byte</li>\n</ul>\n</li>\n<li>自动转换（小转大）<ul>\n<li>示例：<ul>\n<li>double a = 10;</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>byte不能自动转换成char</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>强制转换（大转小）<ul>\n<li>示例：<ul>\n<li>int a = (int)1.1;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"存储单位\"><a href=\"#存储单位\" class=\"headerlink\" title=\"存储单位\"></a>存储单位</h3><ul>\n<li>8 bit = 1 Byte 一字节</li>\n<li>1024 B = 1 KB （KiloByte） 千字节</li>\n<li>1024 KB = 1 MB （MegaByte） 兆字节</li>\n<li>1024 MB = 1 GB （GigaByte） 吉字节</li>\n<li>1024 GB = 1 TB （TeraByte） 太字节</li>\n<li>1024 TB = 1 PB （PetaByte） 拍字节</li>\n<li>1024 PB = 1 EB （ExaByte） 艾字节</li>\n<li>1024 EB = 1 ZB （ZetaByte） 泽字节</li>\n<li>1024 ZB = 1 YB （YottaByte） 尧字节</li>\n<li>1024 YB = 1BB（Brontobyte）珀字节</li>\n<li>1024 BB = 1 NB （NonaByte） 诺字节</li>\n<li>1024 NB = 1 DB （DoggaByte）刀字节</li>\n</ul>\n<h3 id=\"字节（Byte）\"><a href=\"#字节（Byte）\" class=\"headerlink\" title=\"字节（Byte）\"></a>字节（Byte）</h3><ul>\n<li>计算机最小存储单元</li>\n<li>可存储开和关信息，即1和0</li>\n</ul>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li>基本数据类型<ul>\n<li>整形<ul>\n<li>byte</li>\n<li>short</li>\n<li>int</li>\n<li>long</li>\n</ul>\n</li>\n<li>浮点型<ul>\n<li>float</li>\n<li>double</li>\n</ul>\n</li>\n<li>字符<ul>\n<li>char</li>\n</ul>\n</li>\n<li>布尔型<ul>\n<li>boolean</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>引用数据类型<ul>\n<li>string</li>\n<li>class</li>\n<li>interface</li>\n<li>list</li>\n<li>map</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><ul>\n<li>数据范围大小：<ul>\n<li>double&gt;float&gt;long&gt;int&gt;short=char&gt;byte</li>\n</ul>\n</li>\n<li>自动转换（小转大）<ul>\n<li>示例：<ul>\n<li>double a = 10;</li>\n</ul>\n</li>\n<li>注意：<ul>\n<li>byte不能自动转换成char</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>强制转换（大转小）<ul>\n<li>示例：<ul>\n<li>int a = (int)1.1;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"流程控制","date":"2021-08-30T11:42:38.000Z","_content":"\n### 分类\n* 顺序\n* 循环\n    * for\n    * while\n    * do...while\n* 分支\n    * if\n    * switch\n    \n### 特殊点\n* 死循环写法\n```\nfor(;;) {}\nwhile(true){}\n```\n* break\n    * 终止循环\n* continue\n    * 终止本次循环\n    \n    \n\n\n","source":"_posts/Java/流程控制.md","raw":"---\ntitle: 流程控制\ndate: 2021-08-30 19:42:38\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 分类\n* 顺序\n* 循环\n    * for\n    * while\n    * do...while\n* 分支\n    * if\n    * switch\n    \n### 特殊点\n* 死循环写法\n```\nfor(;;) {}\nwhile(true){}\n```\n* break\n    * 终止循环\n* continue\n    * 终止本次循环\n    \n    \n\n\n","slug":"Java/流程控制","published":1,"updated":"2022-04-12T09:00:46.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0as000ywgtt64mff3qy","content":"<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>顺序</li>\n<li>循环<ul>\n<li>for</li>\n<li>while</li>\n<li>do…while</li>\n</ul>\n</li>\n<li>分支<ul>\n<li>if</li>\n<li>switch</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"特殊点\"><a href=\"#特殊点\" class=\"headerlink\" title=\"特殊点\"></a>特殊点</h3><ul>\n<li>死循环写法<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(;;) &#123;&#125;</span><br><span class=\"line\">while(true)&#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li>break<ul>\n<li>终止循环</li>\n</ul>\n</li>\n<li>continue<ul>\n<li>终止本次循环</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>顺序</li>\n<li>循环<ul>\n<li>for</li>\n<li>while</li>\n<li>do…while</li>\n</ul>\n</li>\n<li>分支<ul>\n<li>if</li>\n<li>switch</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"特殊点\"><a href=\"#特殊点\" class=\"headerlink\" title=\"特殊点\"></a>特殊点</h3><ul>\n<li>死循环写法<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(;;) &#123;&#125;</span><br><span class=\"line\">while(true)&#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li>break<ul>\n<li>终止循环</li>\n</ul>\n</li>\n<li>continue<ul>\n<li>终止本次循环</li>\n</ul>\n</li>\n</ul>\n"},{"title":"多线程","date":"2021-08-31T13:43:37.000Z","_content":"\n### 实现方式\n* JVM的多线程是通过线程轮流切换分配处理器的执行时间来实现的，在任何一个确定的时刻，一个处理器核心只执行一个线程中的指令\n\n### 线程通信\n* 主要方式\n    * 消息传递\n    * 共享内存\n* Java采用共享内存方式","source":"_posts/Java/多线程.md","raw":"---\ntitle: 多线程\ndate: 2021-08-31 21:43:37\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 实现方式\n* JVM的多线程是通过线程轮流切换分配处理器的执行时间来实现的，在任何一个确定的时刻，一个处理器核心只执行一个线程中的指令\n\n### 线程通信\n* 主要方式\n    * 消息传递\n    * 共享内存\n* Java采用共享内存方式","slug":"Java/多线程","published":1,"updated":"2022-04-12T09:00:46.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0at0011wgttexgifnjm","content":"<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><ul>\n<li>JVM的多线程是通过线程轮流切换分配处理器的执行时间来实现的，在任何一个确定的时刻，一个处理器核心只执行一个线程中的指令</li>\n</ul>\n<h3 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h3><ul>\n<li>主要方式<ul>\n<li>消息传递</li>\n<li>共享内存</li>\n</ul>\n</li>\n<li>Java采用共享内存方式</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><ul>\n<li>JVM的多线程是通过线程轮流切换分配处理器的执行时间来实现的，在任何一个确定的时刻，一个处理器核心只执行一个线程中的指令</li>\n</ul>\n<h3 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h3><ul>\n<li>主要方式<ul>\n<li>消息传递</li>\n<li>共享内存</li>\n</ul>\n</li>\n<li>Java采用共享内存方式</li>\n</ul>\n"},{"title":"数组","date":"2021-08-31T02:59:44.000Z","_content":"\n### 初始化\n* 动态初始化：\n    * int[] arr = new int[100];\n        * 即设定数组长度之后，编译器可以自动完成内存分配与初始值设定，初始值跟数据类型相关\n* 静态初始化：\n    * int[] arr = {1, 2, 3};\n        * 初始化相关元素，不初始化数组长度\n\n### 异常\n* 索引越界\n* 空指针异常\n\n\n### ArrayList\n* 特点：\n    * 可调整大小\n    * ArrayList<E>中的E指泛型","source":"_posts/Java/数组.md","raw":"---\ntitle: 数组\ndate: 2021-08-31 10:59:44\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 初始化\n* 动态初始化：\n    * int[] arr = new int[100];\n        * 即设定数组长度之后，编译器可以自动完成内存分配与初始值设定，初始值跟数据类型相关\n* 静态初始化：\n    * int[] arr = {1, 2, 3};\n        * 初始化相关元素，不初始化数组长度\n\n### 异常\n* 索引越界\n* 空指针异常\n\n\n### ArrayList\n* 特点：\n    * 可调整大小\n    * ArrayList<E>中的E指泛型","slug":"Java/数组","published":1,"updated":"2022-04-12T09:00:46.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0au0014wgttbqsfcanq","content":"<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>动态初始化：<ul>\n<li>int[] arr = new int[100];<ul>\n<li>即设定数组长度之后，编译器可以自动完成内存分配与初始值设定，初始值跟数据类型相关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>静态初始化：<ul>\n<li>int[] arr = {1, 2, 3};<ul>\n<li>初始化相关元素，不初始化数组长度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><ul>\n<li>索引越界</li>\n<li>空指针异常</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li>特点：<ul>\n<li>可调整大小</li>\n<li>ArrayList<E>中的E指泛型</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>动态初始化：<ul>\n<li>int[] arr = new int[100];<ul>\n<li>即设定数组长度之后，编译器可以自动完成内存分配与初始值设定，初始值跟数据类型相关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>静态初始化：<ul>\n<li>int[] arr = {1, 2, 3};<ul>\n<li>初始化相关元素，不初始化数组长度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><ul>\n<li>索引越界</li>\n<li>空指针异常</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li>特点：<ul>\n<li>可调整大小</li>\n<li>ArrayList<E>中的E指泛型</li>\n</ul>\n</li>\n</ul>\n"},{"title":"继承","date":"2021-10-10T07:26:55.000Z","_content":"\n### 利弊\n* 利\n    * 代码复用性\n    * 代码可维护性\n* 弊\n    * 削弱子类独立性\n    * 类之间耦合性大\n    \n### 特点\n* 子类任何构造方法均调动父类无参构造方法，目的是为了完成父类对象的创建与初始化，保证子类使用父类属性与方法不会出错，相当于默认调用了super()\n* 子类重写方法访问权限需要大于等于父类方法\n* 单继承\n\n","source":"_posts/Java/继承.md","raw":"---\ntitle: 继承\ndate: 2021-10-10 15:26:55\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 利弊\n* 利\n    * 代码复用性\n    * 代码可维护性\n* 弊\n    * 削弱子类独立性\n    * 类之间耦合性大\n    \n### 特点\n* 子类任何构造方法均调动父类无参构造方法，目的是为了完成父类对象的创建与初始化，保证子类使用父类属性与方法不会出错，相当于默认调用了super()\n* 子类重写方法访问权限需要大于等于父类方法\n* 单继承\n\n","slug":"Java/继承","published":1,"updated":"2022-04-12T09:00:46.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0av0017wgtt7dhwdcvk","content":"<h3 id=\"利弊\"><a href=\"#利弊\" class=\"headerlink\" title=\"利弊\"></a>利弊</h3><ul>\n<li>利<ul>\n<li>代码复用性</li>\n<li>代码可维护性</li>\n</ul>\n</li>\n<li>弊<ul>\n<li>削弱子类独立性</li>\n<li>类之间耦合性大</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>子类任何构造方法均调动父类无参构造方法，目的是为了完成父类对象的创建与初始化，保证子类使用父类属性与方法不会出错，相当于默认调用了super()</li>\n<li>子类重写方法访问权限需要大于等于父类方法</li>\n<li>单继承</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"利弊\"><a href=\"#利弊\" class=\"headerlink\" title=\"利弊\"></a>利弊</h3><ul>\n<li>利<ul>\n<li>代码复用性</li>\n<li>代码可维护性</li>\n</ul>\n</li>\n<li>弊<ul>\n<li>削弱子类独立性</li>\n<li>类之间耦合性大</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>子类任何构造方法均调动父类无参构造方法，目的是为了完成父类对象的创建与初始化，保证子类使用父类属性与方法不会出错，相当于默认调用了super()</li>\n<li>子类重写方法访问权限需要大于等于父类方法</li>\n<li>单继承</li>\n</ul>\n"},{"title":"运算符","date":"2021-08-27T08:08:51.000Z","_content":"\n### 概念\n* 运算符：\n  * 在表达式中表示计算的符号\n* 表达式：\n  * 由运算符、变量、常量等组成的有意义的组合\n\n### 算数运算符\n* 组成：\n  * +\n  * -\n  * \\*\n  * \\\\\n  * \\%\n* 总结：\n  * char运算时会转换为ASCII码的值\n  * 多个类型运算时，结果为最大范围类型\n  * 从左到右顺序执行\n    * 例：1 + 2 + \"abc\" = \"3abc\"\n    * 例：\"abc\" + 1 + 2 = \"abc12\"\n\n### 赋值运算符\n* 组成：\n  * =\n* 总结：\n  * 可搭配其他运算符使用，例 +=、-=等，+=类似的赋值运算符内隐含强制类型转换\n\n### 自增、自减运算符\n* 组成\n    * ++\n    * --\n* 总结：\n    * 在参与复杂表达式中时，按顺序执行，++在前，先赋值，++在后，先+1，--同理\n    \n### 关系运算符\n* 组成：\n    * ==\n    * !=\n    * \\>\n    * \\>=\n    * <\n    * <=\n* 总结：\n    * 结果为boolean\n     \n### 逻辑运算符\n* 组成：\n    * &\n    * |\n    * !\n    * ^\n    * 短路逻辑运算符：\n        * &&\n        * ||\n* 总结：\n    * 逻辑运算符是用来连接最终结果为boolean的表达式的\n    * 逻辑运算符前后的表达式结果为boolean\n    * 短路逻辑运算符有短路效果，如果第一个表达式就能确定最终结果，后面的表达式即不执行\n    \n### 三元运算符\n* 组成：\n    * 例：a > b ? a : b;\n     ","source":"_posts/Java/运算符.md","raw":"---\ntitle: 运算符\ndate: 2021-08-27 16:08:51\ntags: 编程\ncategories:\n- [Java]\n---\n\n### 概念\n* 运算符：\n  * 在表达式中表示计算的符号\n* 表达式：\n  * 由运算符、变量、常量等组成的有意义的组合\n\n### 算数运算符\n* 组成：\n  * +\n  * -\n  * \\*\n  * \\\\\n  * \\%\n* 总结：\n  * char运算时会转换为ASCII码的值\n  * 多个类型运算时，结果为最大范围类型\n  * 从左到右顺序执行\n    * 例：1 + 2 + \"abc\" = \"3abc\"\n    * 例：\"abc\" + 1 + 2 = \"abc12\"\n\n### 赋值运算符\n* 组成：\n  * =\n* 总结：\n  * 可搭配其他运算符使用，例 +=、-=等，+=类似的赋值运算符内隐含强制类型转换\n\n### 自增、自减运算符\n* 组成\n    * ++\n    * --\n* 总结：\n    * 在参与复杂表达式中时，按顺序执行，++在前，先赋值，++在后，先+1，--同理\n    \n### 关系运算符\n* 组成：\n    * ==\n    * !=\n    * \\>\n    * \\>=\n    * <\n    * <=\n* 总结：\n    * 结果为boolean\n     \n### 逻辑运算符\n* 组成：\n    * &\n    * |\n    * !\n    * ^\n    * 短路逻辑运算符：\n        * &&\n        * ||\n* 总结：\n    * 逻辑运算符是用来连接最终结果为boolean的表达式的\n    * 逻辑运算符前后的表达式结果为boolean\n    * 短路逻辑运算符有短路效果，如果第一个表达式就能确定最终结果，后面的表达式即不执行\n    \n### 三元运算符\n* 组成：\n    * 例：a > b ? a : b;\n     ","slug":"Java/运算符","published":1,"updated":"2022-04-12T09:00:46.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0aw001awgttclnle2k4","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>运算符：<ul>\n<li>在表达式中表示计算的符号</li>\n</ul>\n</li>\n<li>表达式：<ul>\n<li>由运算符、变量、常量等组成的有意义的组合</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h3><ul>\n<li>组成：<ul>\n<li>+</li>\n<li>-</li>\n<li>*</li>\n<li>\\</li>\n<li>%</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>char运算时会转换为ASCII码的值</li>\n<li>多个类型运算时，结果为最大范围类型</li>\n<li>从左到右顺序执行<ul>\n<li>例：1 + 2 + “abc” = “3abc”</li>\n<li>例：”abc” + 1 + 2 = “abc12”</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><ul>\n<li>组成：<ul>\n<li>=</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>可搭配其他运算符使用，例 +=、-=等，+=类似的赋值运算符内隐含强制类型转换</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自增、自减运算符\"><a href=\"#自增、自减运算符\" class=\"headerlink\" title=\"自增、自减运算符\"></a>自增、自减运算符</h3><ul>\n<li>组成<ul>\n<li>++</li>\n<li>–</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>在参与复杂表达式中时，按顺序执行，++在前，先赋值，++在后，先+1，–同理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><ul>\n<li>组成：<ul>\n<li>==</li>\n<li>!=</li>\n<li>&gt;</li>\n<li>&gt;=</li>\n<li>&lt;</li>\n<li>&lt;=</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>结果为boolean</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><ul>\n<li>组成：<ul>\n<li>&amp;</li>\n<li>|</li>\n<li>!</li>\n<li>^</li>\n<li>短路逻辑运算符：<ul>\n<li>&amp;&amp;</li>\n<li>||</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>逻辑运算符是用来连接最终结果为boolean的表达式的</li>\n<li>逻辑运算符前后的表达式结果为boolean</li>\n<li>短路逻辑运算符有短路效果，如果第一个表达式就能确定最终结果，后面的表达式即不执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h3><ul>\n<li>组成：<ul>\n<li>例：a &gt; b ? a : b;</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>运算符：<ul>\n<li>在表达式中表示计算的符号</li>\n</ul>\n</li>\n<li>表达式：<ul>\n<li>由运算符、变量、常量等组成的有意义的组合</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h3><ul>\n<li>组成：<ul>\n<li>+</li>\n<li>-</li>\n<li>*</li>\n<li>\\</li>\n<li>%</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>char运算时会转换为ASCII码的值</li>\n<li>多个类型运算时，结果为最大范围类型</li>\n<li>从左到右顺序执行<ul>\n<li>例：1 + 2 + “abc” = “3abc”</li>\n<li>例：”abc” + 1 + 2 = “abc12”</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><ul>\n<li>组成：<ul>\n<li>=</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>可搭配其他运算符使用，例 +=、-=等，+=类似的赋值运算符内隐含强制类型转换</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自增、自减运算符\"><a href=\"#自增、自减运算符\" class=\"headerlink\" title=\"自增、自减运算符\"></a>自增、自减运算符</h3><ul>\n<li>组成<ul>\n<li>++</li>\n<li>–</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>在参与复杂表达式中时，按顺序执行，++在前，先赋值，++在后，先+1，–同理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><ul>\n<li>组成：<ul>\n<li>==</li>\n<li>!=</li>\n<li>&gt;</li>\n<li>&gt;=</li>\n<li>&lt;</li>\n<li>&lt;=</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>结果为boolean</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><ul>\n<li>组成：<ul>\n<li>&amp;</li>\n<li>|</li>\n<li>!</li>\n<li>^</li>\n<li>短路逻辑运算符：<ul>\n<li>&amp;&amp;</li>\n<li>||</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总结：<ul>\n<li>逻辑运算符是用来连接最终结果为boolean的表达式的</li>\n<li>逻辑运算符前后的表达式结果为boolean</li>\n<li>短路逻辑运算符有短路效果，如果第一个表达式就能确定最终结果，后面的表达式即不执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h3><ul>\n<li>组成：<ul>\n<li>例：a &gt; b ? a : b;</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Linux常用命令总结","date":"2021-09-09T02:26:09.000Z","_content":"\n### cat\n* 显示文件最后10行：cat filename | tail -n 10\n* 显示文件前10行：cat filename | head -n 10\n* 从10行开始显示，显示10行以后的所有行：cat filename | tail -n +10\n* 显示10行到50行：cat filename | head -n 50 | tail -n +10  \n* 在filename1 和 filename2中查找xxx关键字：cat filename1 filename2 | grep xxx\n* 模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字：cat aaaa*.log | grep xxx\n* 模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字统计出现次数：cat aaaa*.log | grep xxx -c \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n    \n\n    \n\n\n\n","source":"_posts/Linux/Linux常用命令总结.md","raw":"---\ntitle: Linux常用命令总结\ndate: 2021-09-09 10:26:09\ntags: 编程\ncategories:\n- [Linux]\n---\n\n### cat\n* 显示文件最后10行：cat filename | tail -n 10\n* 显示文件前10行：cat filename | head -n 10\n* 从10行开始显示，显示10行以后的所有行：cat filename | tail -n +10\n* 显示10行到50行：cat filename | head -n 50 | tail -n +10  \n* 在filename1 和 filename2中查找xxx关键字：cat filename1 filename2 | grep xxx\n* 模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字：cat aaaa*.log | grep xxx\n* 模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字统计出现次数：cat aaaa*.log | grep xxx -c \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n    \n\n    \n\n\n\n","slug":"Linux/Linux常用命令总结","published":1,"updated":"2022-04-12T09:00:46.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ax001dwgtt98wfbqaf","content":"<h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><ul>\n<li>显示文件最后10行：cat filename | tail -n 10</li>\n<li>显示文件前10行：cat filename | head -n 10</li>\n<li>从10行开始显示，显示10行以后的所有行：cat filename | tail -n +10</li>\n<li>显示10行到50行：cat filename | head -n 50 | tail -n +10  </li>\n<li>在filename1 和 filename2中查找xxx关键字：cat filename1 filename2 | grep xxx</li>\n<li>模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字：cat aaaa*.log | grep xxx</li>\n<li>模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字统计出现次数：cat aaaa*.log | grep xxx -c </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><ul>\n<li>显示文件最后10行：cat filename | tail -n 10</li>\n<li>显示文件前10行：cat filename | head -n 10</li>\n<li>从10行开始显示，显示10行以后的所有行：cat filename | tail -n +10</li>\n<li>显示10行到50行：cat filename | head -n 50 | tail -n +10  </li>\n<li>在filename1 和 filename2中查找xxx关键字：cat filename1 filename2 | grep xxx</li>\n<li>模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字：cat aaaa*.log | grep xxx</li>\n<li>模糊匹配aaaa开头的文件并在这些文件中查找xxx关键字统计出现次数：cat aaaa*.log | grep xxx -c </li>\n</ul>\n"},{"title":"数字货币私钥保存方案设计","date":"2022-02-08T08:25:55.000Z","_content":"\n### 方案设计描述（此处只讨论保存到互联网中）\n* 保存私钥：\n  1、使用RSA方案对钱包私钥进行加密获得钱包私钥密文\n  2、将RSA私钥和钱包私钥密文对应的文件压缩成zip文件，并设置密码\n  3、然后将RSA私钥和钱包私钥密文分别保存到不用的地方\n* 获取私钥：\n  1、找到RSA私钥和钱包私钥密文\n  2、找到解zip密码，解压获得两个文件\n  3、将解密后的文件地址复制到代码中，运行获得明文\n\n### RSA加解密示例代码\n```\nfrom binascii import b2a_hex, a2b_hex\n\nimport rsa as rsa\nfrom Crypto.Cipher import AES\n\n\"\"\"\nAES加密部分\n使用AES ECB模式，16位AES_KEY\n\"\"\"\n\nclass AESUtil(object):\n    AES_KEY = \"XewGlSGidrB+REgf\"\n\n    def add_to_16(self, text):\n        if len(text.encode('utf-8')) % 16:\n            add = 16 - (len(text.encode('utf-8')) % 16)\n        else:\n            add = 0\n        text = text + ('\\0' * add)\n        return text.encode('utf-8')\n\n    # 加密函数\n    def encrypt(self, text, aes_key):\n\n        cryptos = AES.new(aes_key.encode('utf-8'), AES.MODE_ECB)\n        cipher_text = cryptos.encrypt(self.add_to_16(text))\n        # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串\n        return b2a_hex(cipher_text)\n\n    # 解密后，去掉补足的空格用strip() 去掉\n    def decrypt(self, text, aes_key):\n        cryptos = AES.new(aes_key.encode('utf-8'), AES.MODE_ECB)\n        plain_text = cryptos.decrypt(a2b_hex(text))\n        return bytes.decode(plain_text).rstrip('\\0')\n\n    # 生成随机密钥\n    def get_random_aes_key(self, n=16):\n        \"\"\"\n        获取密钥 n 密钥长度\n        :return:\n        \"\"\"\n        c_length = int(n)\n        source = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n        length = len(source) - 1\n        result = ''\n        for i in range(c_length):\n            import random\n            result += source[random.randint(0, length)]\n        return result\n\ndef test_aes():\n    print(\"aes加解密测试\")\n    aesUtil = AESUtil()\n    aes_key = aesUtil.get_random_aes_key()\n    print(\"随机aeskey\", aes_key)\n    encrypt_text = aesUtil.encrypt(\"aes加解密测试\", aes_key)\n    print(\"aes加密：\", encrypt_text)\n    decrypt_text = aesUtil.decrypt(encrypt_text, aes_key)\n    print(\"aes解密：\", decrypt_text)\n\n\"\"\"\nRSA加密部分\n\"\"\"\n\nPUBLIC_KEY_PATH = './rsa_public_key.pem'  # 公钥\nPRIVATE_KEY_PATH = './rsa_private_key.pem'  # 私钥\n\nclass RSAUtil(object):\n\n    def create_rsa_pri_pub_key(self):\n        (public_key, private_key) = rsa.newkeys(1024)\n        public_key = public_key.save_pkcs1()\n        private_key = private_key.save_pkcs1()\n        return (public_key, private_key)\n\n    def encrypt(self, public_key, text):\n        return rsa.encrypt(text.encode('utf8'), public_key)\n\n    def decrypt(self, private_key, text):\n        return rsa.decrypt(text, private_key).decode()\n\n    \"\"\"\n    传入多个path，将加密数据保存到对应path，并保存秘钥到对应path\n    \"\"\"\n    def encrypt_save_text_with_path(self, text, private_key_path, text_path):\n        (public_key, private_key) = self.create_rsa_pri_pub_key()\n        with open(private_key_path, \"wb\") as f:\n            f.write(private_key)\n\n        tmp_rsa_public_key_path = \"./rsa_public.pem\"\n        with open(tmp_rsa_public_key_path, \"wb\") as f:\n            f.write(public_key)\n\n        public_key = rsa.PublicKey.load_pkcs1(open(tmp_rsa_public_key_path).read())\n\n        encrypt_text = self.encrypt(public_key, text)\n\n        with open(text_path, \"wb\") as f:\n            f.write(encrypt_text)\n\n\n\n    \"\"\"\n    传入多个path，将加密数据解密获得明文\n    \"\"\"\n    def decrypt_text_with_path(self, private_key_path, text_path):\n        private_key = rsa.PrivateKey.load_pkcs1(open(private_key_path).read())\n\n        with open(text_path, \"rb\") as f:\n            encrypt_text = f.read()\n\n        return self.decrypt(private_key, encrypt_text)\n\n\n\"\"\"\nrsa+aes\n\"\"\"\n\nclass RSAAESUtil(object):\n\n    def get_rsa_aes_key(self):\n        aes_util = AESUtil()\n        rsa_util = RSAUtil()\n\n        aes_key = aes_util.get_random_aes_key()\n        (rsa_public_key, rsa_private_key) = rsa_util.get_rsa_pub_pri_key(PUBLIC_KEY_PATH, PRIVATE_KEY_PATH)\n        return (aes_key, rsa_public_key, rsa_private_key)\n\n\n    def encrypt(self, text, aes_key, rsa_public_key):\n        aes_util = AESUtil()\n        rsa_util = RSAUtil()\n\n        # 加密\n        encrypt_text = aes_util.encrypt(text, aes_key)\n        encrypt_aes_key = rsa_util.encrypt(rsa_public_key, aes_key)\n        return (encrypt_text, encrypt_aes_key)\n\n    def decrypty(self, rsa_private_key, encrypt_text, encrypt_aes_key):\n        aes_util = AESUtil()\n        rsa_util = RSAUtil()\n        aes_key = rsa_util.decrypt(rsa_private_key, encrypt_aes_key)\n        return aes_util.decrypt(encrypt_text, aes_key)\n\ndef test_rsa_aes():\n    print(\"rsa_aes加解密测试\")\n    rsa_aes_util = RSAAESUtil()\n\n    # 生成秘钥\n    (aes_key, rsa_public_key, rsa_private_key) = rsa_aes_util.get_rsa_aes_key()\n\n    # 加密\n    (encrypt_text, encrypt_aes_key) = rsa_aes_util.encrypt(\"rsa_aes加解密测试\", aes_key, rsa_public_key)\n    print(\"rsa_aes加密：\", encrypt_text)\n    print(\"rsa_aes加密后的aes_key\", encrypt_aes_key)\n\n    # 解密\n    decrypt_text = rsa_aes_util.decrypty(rsa_private_key, encrypt_text, encrypt_aes_key)\n    print(\"rsa_aes解密：\", decrypt_text)\n\nBTC_RSA_PRIVATE_KEY_PATH = \"./btc_rsa_private_key.pem\"\nBTC_RSA_PUBLIC_KEY_PATH = \"./btc_rsa_public_key.pem\"\n\nETH_RSA_PRIVATE_KEY_PATH = \"./eth_rsa_private_key.pem\"\nETH_RSA_PUBLIC_KEY_PATH = \"./eth_rsa_public_key.pem\"\n\nBTC_ENCRYPT_TEXT_PATH = \"./btc_encrypt_text.txt\"\nETH_ENCRYPT_TEXT_PATH = \"./eth_encrypt_text.txt\"\n\ndef test_rsa_solution():\n    rsa_util = RSAUtil()\n\n    btc_text = \"我是比特币私钥\"\n    eth_text = \"我是以太坊私钥\"\n\n    rsa_util.encrypt_save_text_with_path(btc_text, BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)\n    print(rsa_util.decrypt_text_with_path(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH))\n\n    rsa_util.encrypt_save_text_with_path(eth_text, ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH)\n    print(rsa_util.decrypt_text_with_path(ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH))\n\ndef get_key(private_key_path, encrypt_text_path):\n    rsa_util = RSAUtil()\n    print(rsa_util.decrypt_text_with_path(private_key_path, encrypt_text_path))\n\n\n\n\nif __name__ == '__main__':\n    test_rsa_solution()\n    get_key(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)\n```\n","source":"_posts/blockchain/数字货币私钥保存方案设计.md","raw":"---\ntitle: 数字货币私钥保存方案设计\ndate: 2022-02-08 16:25:55\ntags: 区块链\ncategories:\n- [区块链使用]\n---\n\n### 方案设计描述（此处只讨论保存到互联网中）\n* 保存私钥：\n  1、使用RSA方案对钱包私钥进行加密获得钱包私钥密文\n  2、将RSA私钥和钱包私钥密文对应的文件压缩成zip文件，并设置密码\n  3、然后将RSA私钥和钱包私钥密文分别保存到不用的地方\n* 获取私钥：\n  1、找到RSA私钥和钱包私钥密文\n  2、找到解zip密码，解压获得两个文件\n  3、将解密后的文件地址复制到代码中，运行获得明文\n\n### RSA加解密示例代码\n```\nfrom binascii import b2a_hex, a2b_hex\n\nimport rsa as rsa\nfrom Crypto.Cipher import AES\n\n\"\"\"\nAES加密部分\n使用AES ECB模式，16位AES_KEY\n\"\"\"\n\nclass AESUtil(object):\n    AES_KEY = \"XewGlSGidrB+REgf\"\n\n    def add_to_16(self, text):\n        if len(text.encode('utf-8')) % 16:\n            add = 16 - (len(text.encode('utf-8')) % 16)\n        else:\n            add = 0\n        text = text + ('\\0' * add)\n        return text.encode('utf-8')\n\n    # 加密函数\n    def encrypt(self, text, aes_key):\n\n        cryptos = AES.new(aes_key.encode('utf-8'), AES.MODE_ECB)\n        cipher_text = cryptos.encrypt(self.add_to_16(text))\n        # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串\n        return b2a_hex(cipher_text)\n\n    # 解密后，去掉补足的空格用strip() 去掉\n    def decrypt(self, text, aes_key):\n        cryptos = AES.new(aes_key.encode('utf-8'), AES.MODE_ECB)\n        plain_text = cryptos.decrypt(a2b_hex(text))\n        return bytes.decode(plain_text).rstrip('\\0')\n\n    # 生成随机密钥\n    def get_random_aes_key(self, n=16):\n        \"\"\"\n        获取密钥 n 密钥长度\n        :return:\n        \"\"\"\n        c_length = int(n)\n        source = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n        length = len(source) - 1\n        result = ''\n        for i in range(c_length):\n            import random\n            result += source[random.randint(0, length)]\n        return result\n\ndef test_aes():\n    print(\"aes加解密测试\")\n    aesUtil = AESUtil()\n    aes_key = aesUtil.get_random_aes_key()\n    print(\"随机aeskey\", aes_key)\n    encrypt_text = aesUtil.encrypt(\"aes加解密测试\", aes_key)\n    print(\"aes加密：\", encrypt_text)\n    decrypt_text = aesUtil.decrypt(encrypt_text, aes_key)\n    print(\"aes解密：\", decrypt_text)\n\n\"\"\"\nRSA加密部分\n\"\"\"\n\nPUBLIC_KEY_PATH = './rsa_public_key.pem'  # 公钥\nPRIVATE_KEY_PATH = './rsa_private_key.pem'  # 私钥\n\nclass RSAUtil(object):\n\n    def create_rsa_pri_pub_key(self):\n        (public_key, private_key) = rsa.newkeys(1024)\n        public_key = public_key.save_pkcs1()\n        private_key = private_key.save_pkcs1()\n        return (public_key, private_key)\n\n    def encrypt(self, public_key, text):\n        return rsa.encrypt(text.encode('utf8'), public_key)\n\n    def decrypt(self, private_key, text):\n        return rsa.decrypt(text, private_key).decode()\n\n    \"\"\"\n    传入多个path，将加密数据保存到对应path，并保存秘钥到对应path\n    \"\"\"\n    def encrypt_save_text_with_path(self, text, private_key_path, text_path):\n        (public_key, private_key) = self.create_rsa_pri_pub_key()\n        with open(private_key_path, \"wb\") as f:\n            f.write(private_key)\n\n        tmp_rsa_public_key_path = \"./rsa_public.pem\"\n        with open(tmp_rsa_public_key_path, \"wb\") as f:\n            f.write(public_key)\n\n        public_key = rsa.PublicKey.load_pkcs1(open(tmp_rsa_public_key_path).read())\n\n        encrypt_text = self.encrypt(public_key, text)\n\n        with open(text_path, \"wb\") as f:\n            f.write(encrypt_text)\n\n\n\n    \"\"\"\n    传入多个path，将加密数据解密获得明文\n    \"\"\"\n    def decrypt_text_with_path(self, private_key_path, text_path):\n        private_key = rsa.PrivateKey.load_pkcs1(open(private_key_path).read())\n\n        with open(text_path, \"rb\") as f:\n            encrypt_text = f.read()\n\n        return self.decrypt(private_key, encrypt_text)\n\n\n\"\"\"\nrsa+aes\n\"\"\"\n\nclass RSAAESUtil(object):\n\n    def get_rsa_aes_key(self):\n        aes_util = AESUtil()\n        rsa_util = RSAUtil()\n\n        aes_key = aes_util.get_random_aes_key()\n        (rsa_public_key, rsa_private_key) = rsa_util.get_rsa_pub_pri_key(PUBLIC_KEY_PATH, PRIVATE_KEY_PATH)\n        return (aes_key, rsa_public_key, rsa_private_key)\n\n\n    def encrypt(self, text, aes_key, rsa_public_key):\n        aes_util = AESUtil()\n        rsa_util = RSAUtil()\n\n        # 加密\n        encrypt_text = aes_util.encrypt(text, aes_key)\n        encrypt_aes_key = rsa_util.encrypt(rsa_public_key, aes_key)\n        return (encrypt_text, encrypt_aes_key)\n\n    def decrypty(self, rsa_private_key, encrypt_text, encrypt_aes_key):\n        aes_util = AESUtil()\n        rsa_util = RSAUtil()\n        aes_key = rsa_util.decrypt(rsa_private_key, encrypt_aes_key)\n        return aes_util.decrypt(encrypt_text, aes_key)\n\ndef test_rsa_aes():\n    print(\"rsa_aes加解密测试\")\n    rsa_aes_util = RSAAESUtil()\n\n    # 生成秘钥\n    (aes_key, rsa_public_key, rsa_private_key) = rsa_aes_util.get_rsa_aes_key()\n\n    # 加密\n    (encrypt_text, encrypt_aes_key) = rsa_aes_util.encrypt(\"rsa_aes加解密测试\", aes_key, rsa_public_key)\n    print(\"rsa_aes加密：\", encrypt_text)\n    print(\"rsa_aes加密后的aes_key\", encrypt_aes_key)\n\n    # 解密\n    decrypt_text = rsa_aes_util.decrypty(rsa_private_key, encrypt_text, encrypt_aes_key)\n    print(\"rsa_aes解密：\", decrypt_text)\n\nBTC_RSA_PRIVATE_KEY_PATH = \"./btc_rsa_private_key.pem\"\nBTC_RSA_PUBLIC_KEY_PATH = \"./btc_rsa_public_key.pem\"\n\nETH_RSA_PRIVATE_KEY_PATH = \"./eth_rsa_private_key.pem\"\nETH_RSA_PUBLIC_KEY_PATH = \"./eth_rsa_public_key.pem\"\n\nBTC_ENCRYPT_TEXT_PATH = \"./btc_encrypt_text.txt\"\nETH_ENCRYPT_TEXT_PATH = \"./eth_encrypt_text.txt\"\n\ndef test_rsa_solution():\n    rsa_util = RSAUtil()\n\n    btc_text = \"我是比特币私钥\"\n    eth_text = \"我是以太坊私钥\"\n\n    rsa_util.encrypt_save_text_with_path(btc_text, BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)\n    print(rsa_util.decrypt_text_with_path(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH))\n\n    rsa_util.encrypt_save_text_with_path(eth_text, ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH)\n    print(rsa_util.decrypt_text_with_path(ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH))\n\ndef get_key(private_key_path, encrypt_text_path):\n    rsa_util = RSAUtil()\n    print(rsa_util.decrypt_text_with_path(private_key_path, encrypt_text_path))\n\n\n\n\nif __name__ == '__main__':\n    test_rsa_solution()\n    get_key(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)\n```\n","slug":"blockchain/数字货币私钥保存方案设计","published":1,"updated":"2022-04-12T09:00:46.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0ay001gwgtt1q0jfxwk","content":"<h3 id=\"方案设计描述（此处只讨论保存到互联网中）\"><a href=\"#方案设计描述（此处只讨论保存到互联网中）\" class=\"headerlink\" title=\"方案设计描述（此处只讨论保存到互联网中）\"></a>方案设计描述（此处只讨论保存到互联网中）</h3><ul>\n<li>保存私钥：<br>1、使用RSA方案对钱包私钥进行加密获得钱包私钥密文<br>2、将RSA私钥和钱包私钥密文对应的文件压缩成zip文件，并设置密码<br>3、然后将RSA私钥和钱包私钥密文分别保存到不用的地方</li>\n<li>获取私钥：<br>1、找到RSA私钥和钱包私钥密文<br>2、找到解zip密码，解压获得两个文件<br>3、将解密后的文件地址复制到代码中，运行获得明文</li>\n</ul>\n<h3 id=\"RSA加解密示例代码\"><a href=\"#RSA加解密示例代码\" class=\"headerlink\" title=\"RSA加解密示例代码\"></a>RSA加解密示例代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from binascii import b2a_hex, a2b_hex</span><br><span class=\"line\"></span><br><span class=\"line\">import rsa as rsa</span><br><span class=\"line\">from Crypto.Cipher import AES</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">AES加密部分</span><br><span class=\"line\">使用AES ECB模式，16位AES_KEY</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">class AESUtil(object):</span><br><span class=\"line\">    AES_KEY = &quot;XewGlSGidrB+REgf&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    def add_to_16(self, text):</span><br><span class=\"line\">        if len(text.encode(&#x27;utf-8&#x27;)) % 16:</span><br><span class=\"line\">            add = 16 - (len(text.encode(&#x27;utf-8&#x27;)) % 16)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            add = 0</span><br><span class=\"line\">        text = text + (&#x27;\\0&#x27; * add)</span><br><span class=\"line\">        return text.encode(&#x27;utf-8&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 加密函数</span><br><span class=\"line\">    def encrypt(self, text, aes_key):</span><br><span class=\"line\"></span><br><span class=\"line\">        cryptos = AES.new(aes_key.encode(&#x27;utf-8&#x27;), AES.MODE_ECB)</span><br><span class=\"line\">        cipher_text = cryptos.encrypt(self.add_to_16(text))</span><br><span class=\"line\">        # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串</span><br><span class=\"line\">        return b2a_hex(cipher_text)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 解密后，去掉补足的空格用strip() 去掉</span><br><span class=\"line\">    def decrypt(self, text, aes_key):</span><br><span class=\"line\">        cryptos = AES.new(aes_key.encode(&#x27;utf-8&#x27;), AES.MODE_ECB)</span><br><span class=\"line\">        plain_text = cryptos.decrypt(a2b_hex(text))</span><br><span class=\"line\">        return bytes.decode(plain_text).rstrip(&#x27;\\0&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 生成随机密钥</span><br><span class=\"line\">    def get_random_aes_key(self, n=16):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        获取密钥 n 密钥长度</span><br><span class=\"line\">        :return:</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        c_length = int(n)</span><br><span class=\"line\">        source = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br><span class=\"line\">        length = len(source) - 1</span><br><span class=\"line\">        result = &#x27;&#x27;</span><br><span class=\"line\">        for i in range(c_length):</span><br><span class=\"line\">            import random</span><br><span class=\"line\">            result += source[random.randint(0, length)]</span><br><span class=\"line\">        return result</span><br><span class=\"line\"></span><br><span class=\"line\">def test_aes():</span><br><span class=\"line\">    print(&quot;aes加解密测试&quot;)</span><br><span class=\"line\">    aesUtil = AESUtil()</span><br><span class=\"line\">    aes_key = aesUtil.get_random_aes_key()</span><br><span class=\"line\">    print(&quot;随机aeskey&quot;, aes_key)</span><br><span class=\"line\">    encrypt_text = aesUtil.encrypt(&quot;aes加解密测试&quot;, aes_key)</span><br><span class=\"line\">    print(&quot;aes加密：&quot;, encrypt_text)</span><br><span class=\"line\">    decrypt_text = aesUtil.decrypt(encrypt_text, aes_key)</span><br><span class=\"line\">    print(&quot;aes解密：&quot;, decrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">RSA加密部分</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">PUBLIC_KEY_PATH = &#x27;./rsa_public_key.pem&#x27;  # 公钥</span><br><span class=\"line\">PRIVATE_KEY_PATH = &#x27;./rsa_private_key.pem&#x27;  # 私钥</span><br><span class=\"line\"></span><br><span class=\"line\">class RSAUtil(object):</span><br><span class=\"line\"></span><br><span class=\"line\">    def create_rsa_pri_pub_key(self):</span><br><span class=\"line\">        (public_key, private_key) = rsa.newkeys(1024)</span><br><span class=\"line\">        public_key = public_key.save_pkcs1()</span><br><span class=\"line\">        private_key = private_key.save_pkcs1()</span><br><span class=\"line\">        return (public_key, private_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    def encrypt(self, public_key, text):</span><br><span class=\"line\">        return rsa.encrypt(text.encode(&#x27;utf8&#x27;), public_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    def decrypt(self, private_key, text):</span><br><span class=\"line\">        return rsa.decrypt(text, private_key).decode()</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    传入多个path，将加密数据保存到对应path，并保存秘钥到对应path</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    def encrypt_save_text_with_path(self, text, private_key_path, text_path):</span><br><span class=\"line\">        (public_key, private_key) = self.create_rsa_pri_pub_key()</span><br><span class=\"line\">        with open(private_key_path, &quot;wb&quot;) as f:</span><br><span class=\"line\">            f.write(private_key)</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp_rsa_public_key_path = &quot;./rsa_public.pem&quot;</span><br><span class=\"line\">        with open(tmp_rsa_public_key_path, &quot;wb&quot;) as f:</span><br><span class=\"line\">            f.write(public_key)</span><br><span class=\"line\"></span><br><span class=\"line\">        public_key = rsa.PublicKey.load_pkcs1(open(tmp_rsa_public_key_path).read())</span><br><span class=\"line\"></span><br><span class=\"line\">        encrypt_text = self.encrypt(public_key, text)</span><br><span class=\"line\"></span><br><span class=\"line\">        with open(text_path, &quot;wb&quot;) as f:</span><br><span class=\"line\">            f.write(encrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    传入多个path，将加密数据解密获得明文</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    def decrypt_text_with_path(self, private_key_path, text_path):</span><br><span class=\"line\">        private_key = rsa.PrivateKey.load_pkcs1(open(private_key_path).read())</span><br><span class=\"line\"></span><br><span class=\"line\">        with open(text_path, &quot;rb&quot;) as f:</span><br><span class=\"line\">            encrypt_text = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">        return self.decrypt(private_key, encrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">rsa+aes</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">class RSAAESUtil(object):</span><br><span class=\"line\"></span><br><span class=\"line\">    def get_rsa_aes_key(self):</span><br><span class=\"line\">        aes_util = AESUtil()</span><br><span class=\"line\">        rsa_util = RSAUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">        aes_key = aes_util.get_random_aes_key()</span><br><span class=\"line\">        (rsa_public_key, rsa_private_key) = rsa_util.get_rsa_pub_pri_key(PUBLIC_KEY_PATH, PRIVATE_KEY_PATH)</span><br><span class=\"line\">        return (aes_key, rsa_public_key, rsa_private_key)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    def encrypt(self, text, aes_key, rsa_public_key):</span><br><span class=\"line\">        aes_util = AESUtil()</span><br><span class=\"line\">        rsa_util = RSAUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">        # 加密</span><br><span class=\"line\">        encrypt_text = aes_util.encrypt(text, aes_key)</span><br><span class=\"line\">        encrypt_aes_key = rsa_util.encrypt(rsa_public_key, aes_key)</span><br><span class=\"line\">        return (encrypt_text, encrypt_aes_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    def decrypty(self, rsa_private_key, encrypt_text, encrypt_aes_key):</span><br><span class=\"line\">        aes_util = AESUtil()</span><br><span class=\"line\">        rsa_util = RSAUtil()</span><br><span class=\"line\">        aes_key = rsa_util.decrypt(rsa_private_key, encrypt_aes_key)</span><br><span class=\"line\">        return aes_util.decrypt(encrypt_text, aes_key)</span><br><span class=\"line\"></span><br><span class=\"line\">def test_rsa_aes():</span><br><span class=\"line\">    print(&quot;rsa_aes加解密测试&quot;)</span><br><span class=\"line\">    rsa_aes_util = RSAAESUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">    # 生成秘钥</span><br><span class=\"line\">    (aes_key, rsa_public_key, rsa_private_key) = rsa_aes_util.get_rsa_aes_key()</span><br><span class=\"line\"></span><br><span class=\"line\">    # 加密</span><br><span class=\"line\">    (encrypt_text, encrypt_aes_key) = rsa_aes_util.encrypt(&quot;rsa_aes加解密测试&quot;, aes_key, rsa_public_key)</span><br><span class=\"line\">    print(&quot;rsa_aes加密：&quot;, encrypt_text)</span><br><span class=\"line\">    print(&quot;rsa_aes加密后的aes_key&quot;, encrypt_aes_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 解密</span><br><span class=\"line\">    decrypt_text = rsa_aes_util.decrypty(rsa_private_key, encrypt_text, encrypt_aes_key)</span><br><span class=\"line\">    print(&quot;rsa_aes解密：&quot;, decrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\">BTC_RSA_PRIVATE_KEY_PATH = &quot;./btc_rsa_private_key.pem&quot;</span><br><span class=\"line\">BTC_RSA_PUBLIC_KEY_PATH = &quot;./btc_rsa_public_key.pem&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ETH_RSA_PRIVATE_KEY_PATH = &quot;./eth_rsa_private_key.pem&quot;</span><br><span class=\"line\">ETH_RSA_PUBLIC_KEY_PATH = &quot;./eth_rsa_public_key.pem&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">BTC_ENCRYPT_TEXT_PATH = &quot;./btc_encrypt_text.txt&quot;</span><br><span class=\"line\">ETH_ENCRYPT_TEXT_PATH = &quot;./eth_encrypt_text.txt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">def test_rsa_solution():</span><br><span class=\"line\">    rsa_util = RSAUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">    btc_text = &quot;我是比特币私钥&quot;</span><br><span class=\"line\">    eth_text = &quot;我是以太坊私钥&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    rsa_util.encrypt_save_text_with_path(btc_text, BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)</span><br><span class=\"line\">    print(rsa_util.decrypt_text_with_path(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH))</span><br><span class=\"line\"></span><br><span class=\"line\">    rsa_util.encrypt_save_text_with_path(eth_text, ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH)</span><br><span class=\"line\">    print(rsa_util.decrypt_text_with_path(ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH))</span><br><span class=\"line\"></span><br><span class=\"line\">def get_key(private_key_path, encrypt_text_path):</span><br><span class=\"line\">    rsa_util = RSAUtil()</span><br><span class=\"line\">    print(rsa_util.decrypt_text_with_path(private_key_path, encrypt_text_path))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    test_rsa_solution()</span><br><span class=\"line\">    get_key(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"方案设计描述（此处只讨论保存到互联网中）\"><a href=\"#方案设计描述（此处只讨论保存到互联网中）\" class=\"headerlink\" title=\"方案设计描述（此处只讨论保存到互联网中）\"></a>方案设计描述（此处只讨论保存到互联网中）</h3><ul>\n<li>保存私钥：<br>1、使用RSA方案对钱包私钥进行加密获得钱包私钥密文<br>2、将RSA私钥和钱包私钥密文对应的文件压缩成zip文件，并设置密码<br>3、然后将RSA私钥和钱包私钥密文分别保存到不用的地方</li>\n<li>获取私钥：<br>1、找到RSA私钥和钱包私钥密文<br>2、找到解zip密码，解压获得两个文件<br>3、将解密后的文件地址复制到代码中，运行获得明文</li>\n</ul>\n<h3 id=\"RSA加解密示例代码\"><a href=\"#RSA加解密示例代码\" class=\"headerlink\" title=\"RSA加解密示例代码\"></a>RSA加解密示例代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from binascii import b2a_hex, a2b_hex</span><br><span class=\"line\"></span><br><span class=\"line\">import rsa as rsa</span><br><span class=\"line\">from Crypto.Cipher import AES</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">AES加密部分</span><br><span class=\"line\">使用AES ECB模式，16位AES_KEY</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">class AESUtil(object):</span><br><span class=\"line\">    AES_KEY = &quot;XewGlSGidrB+REgf&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    def add_to_16(self, text):</span><br><span class=\"line\">        if len(text.encode(&#x27;utf-8&#x27;)) % 16:</span><br><span class=\"line\">            add = 16 - (len(text.encode(&#x27;utf-8&#x27;)) % 16)</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            add = 0</span><br><span class=\"line\">        text = text + (&#x27;\\0&#x27; * add)</span><br><span class=\"line\">        return text.encode(&#x27;utf-8&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 加密函数</span><br><span class=\"line\">    def encrypt(self, text, aes_key):</span><br><span class=\"line\"></span><br><span class=\"line\">        cryptos = AES.new(aes_key.encode(&#x27;utf-8&#x27;), AES.MODE_ECB)</span><br><span class=\"line\">        cipher_text = cryptos.encrypt(self.add_to_16(text))</span><br><span class=\"line\">        # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串</span><br><span class=\"line\">        return b2a_hex(cipher_text)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 解密后，去掉补足的空格用strip() 去掉</span><br><span class=\"line\">    def decrypt(self, text, aes_key):</span><br><span class=\"line\">        cryptos = AES.new(aes_key.encode(&#x27;utf-8&#x27;), AES.MODE_ECB)</span><br><span class=\"line\">        plain_text = cryptos.decrypt(a2b_hex(text))</span><br><span class=\"line\">        return bytes.decode(plain_text).rstrip(&#x27;\\0&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 生成随机密钥</span><br><span class=\"line\">    def get_random_aes_key(self, n=16):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        获取密钥 n 密钥长度</span><br><span class=\"line\">        :return:</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        c_length = int(n)</span><br><span class=\"line\">        source = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span><br><span class=\"line\">        length = len(source) - 1</span><br><span class=\"line\">        result = &#x27;&#x27;</span><br><span class=\"line\">        for i in range(c_length):</span><br><span class=\"line\">            import random</span><br><span class=\"line\">            result += source[random.randint(0, length)]</span><br><span class=\"line\">        return result</span><br><span class=\"line\"></span><br><span class=\"line\">def test_aes():</span><br><span class=\"line\">    print(&quot;aes加解密测试&quot;)</span><br><span class=\"line\">    aesUtil = AESUtil()</span><br><span class=\"line\">    aes_key = aesUtil.get_random_aes_key()</span><br><span class=\"line\">    print(&quot;随机aeskey&quot;, aes_key)</span><br><span class=\"line\">    encrypt_text = aesUtil.encrypt(&quot;aes加解密测试&quot;, aes_key)</span><br><span class=\"line\">    print(&quot;aes加密：&quot;, encrypt_text)</span><br><span class=\"line\">    decrypt_text = aesUtil.decrypt(encrypt_text, aes_key)</span><br><span class=\"line\">    print(&quot;aes解密：&quot;, decrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">RSA加密部分</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">PUBLIC_KEY_PATH = &#x27;./rsa_public_key.pem&#x27;  # 公钥</span><br><span class=\"line\">PRIVATE_KEY_PATH = &#x27;./rsa_private_key.pem&#x27;  # 私钥</span><br><span class=\"line\"></span><br><span class=\"line\">class RSAUtil(object):</span><br><span class=\"line\"></span><br><span class=\"line\">    def create_rsa_pri_pub_key(self):</span><br><span class=\"line\">        (public_key, private_key) = rsa.newkeys(1024)</span><br><span class=\"line\">        public_key = public_key.save_pkcs1()</span><br><span class=\"line\">        private_key = private_key.save_pkcs1()</span><br><span class=\"line\">        return (public_key, private_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    def encrypt(self, public_key, text):</span><br><span class=\"line\">        return rsa.encrypt(text.encode(&#x27;utf8&#x27;), public_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    def decrypt(self, private_key, text):</span><br><span class=\"line\">        return rsa.decrypt(text, private_key).decode()</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    传入多个path，将加密数据保存到对应path，并保存秘钥到对应path</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    def encrypt_save_text_with_path(self, text, private_key_path, text_path):</span><br><span class=\"line\">        (public_key, private_key) = self.create_rsa_pri_pub_key()</span><br><span class=\"line\">        with open(private_key_path, &quot;wb&quot;) as f:</span><br><span class=\"line\">            f.write(private_key)</span><br><span class=\"line\"></span><br><span class=\"line\">        tmp_rsa_public_key_path = &quot;./rsa_public.pem&quot;</span><br><span class=\"line\">        with open(tmp_rsa_public_key_path, &quot;wb&quot;) as f:</span><br><span class=\"line\">            f.write(public_key)</span><br><span class=\"line\"></span><br><span class=\"line\">        public_key = rsa.PublicKey.load_pkcs1(open(tmp_rsa_public_key_path).read())</span><br><span class=\"line\"></span><br><span class=\"line\">        encrypt_text = self.encrypt(public_key, text)</span><br><span class=\"line\"></span><br><span class=\"line\">        with open(text_path, &quot;wb&quot;) as f:</span><br><span class=\"line\">            f.write(encrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    传入多个path，将加密数据解密获得明文</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    def decrypt_text_with_path(self, private_key_path, text_path):</span><br><span class=\"line\">        private_key = rsa.PrivateKey.load_pkcs1(open(private_key_path).read())</span><br><span class=\"line\"></span><br><span class=\"line\">        with open(text_path, &quot;rb&quot;) as f:</span><br><span class=\"line\">            encrypt_text = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">        return self.decrypt(private_key, encrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\">rsa+aes</span><br><span class=\"line\">&quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">class RSAAESUtil(object):</span><br><span class=\"line\"></span><br><span class=\"line\">    def get_rsa_aes_key(self):</span><br><span class=\"line\">        aes_util = AESUtil()</span><br><span class=\"line\">        rsa_util = RSAUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">        aes_key = aes_util.get_random_aes_key()</span><br><span class=\"line\">        (rsa_public_key, rsa_private_key) = rsa_util.get_rsa_pub_pri_key(PUBLIC_KEY_PATH, PRIVATE_KEY_PATH)</span><br><span class=\"line\">        return (aes_key, rsa_public_key, rsa_private_key)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    def encrypt(self, text, aes_key, rsa_public_key):</span><br><span class=\"line\">        aes_util = AESUtil()</span><br><span class=\"line\">        rsa_util = RSAUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">        # 加密</span><br><span class=\"line\">        encrypt_text = aes_util.encrypt(text, aes_key)</span><br><span class=\"line\">        encrypt_aes_key = rsa_util.encrypt(rsa_public_key, aes_key)</span><br><span class=\"line\">        return (encrypt_text, encrypt_aes_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    def decrypty(self, rsa_private_key, encrypt_text, encrypt_aes_key):</span><br><span class=\"line\">        aes_util = AESUtil()</span><br><span class=\"line\">        rsa_util = RSAUtil()</span><br><span class=\"line\">        aes_key = rsa_util.decrypt(rsa_private_key, encrypt_aes_key)</span><br><span class=\"line\">        return aes_util.decrypt(encrypt_text, aes_key)</span><br><span class=\"line\"></span><br><span class=\"line\">def test_rsa_aes():</span><br><span class=\"line\">    print(&quot;rsa_aes加解密测试&quot;)</span><br><span class=\"line\">    rsa_aes_util = RSAAESUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">    # 生成秘钥</span><br><span class=\"line\">    (aes_key, rsa_public_key, rsa_private_key) = rsa_aes_util.get_rsa_aes_key()</span><br><span class=\"line\"></span><br><span class=\"line\">    # 加密</span><br><span class=\"line\">    (encrypt_text, encrypt_aes_key) = rsa_aes_util.encrypt(&quot;rsa_aes加解密测试&quot;, aes_key, rsa_public_key)</span><br><span class=\"line\">    print(&quot;rsa_aes加密：&quot;, encrypt_text)</span><br><span class=\"line\">    print(&quot;rsa_aes加密后的aes_key&quot;, encrypt_aes_key)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 解密</span><br><span class=\"line\">    decrypt_text = rsa_aes_util.decrypty(rsa_private_key, encrypt_text, encrypt_aes_key)</span><br><span class=\"line\">    print(&quot;rsa_aes解密：&quot;, decrypt_text)</span><br><span class=\"line\"></span><br><span class=\"line\">BTC_RSA_PRIVATE_KEY_PATH = &quot;./btc_rsa_private_key.pem&quot;</span><br><span class=\"line\">BTC_RSA_PUBLIC_KEY_PATH = &quot;./btc_rsa_public_key.pem&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ETH_RSA_PRIVATE_KEY_PATH = &quot;./eth_rsa_private_key.pem&quot;</span><br><span class=\"line\">ETH_RSA_PUBLIC_KEY_PATH = &quot;./eth_rsa_public_key.pem&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">BTC_ENCRYPT_TEXT_PATH = &quot;./btc_encrypt_text.txt&quot;</span><br><span class=\"line\">ETH_ENCRYPT_TEXT_PATH = &quot;./eth_encrypt_text.txt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">def test_rsa_solution():</span><br><span class=\"line\">    rsa_util = RSAUtil()</span><br><span class=\"line\"></span><br><span class=\"line\">    btc_text = &quot;我是比特币私钥&quot;</span><br><span class=\"line\">    eth_text = &quot;我是以太坊私钥&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    rsa_util.encrypt_save_text_with_path(btc_text, BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)</span><br><span class=\"line\">    print(rsa_util.decrypt_text_with_path(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH))</span><br><span class=\"line\"></span><br><span class=\"line\">    rsa_util.encrypt_save_text_with_path(eth_text, ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH)</span><br><span class=\"line\">    print(rsa_util.decrypt_text_with_path(ETH_RSA_PRIVATE_KEY_PATH, ETH_ENCRYPT_TEXT_PATH))</span><br><span class=\"line\"></span><br><span class=\"line\">def get_key(private_key_path, encrypt_text_path):</span><br><span class=\"line\">    rsa_util = RSAUtil()</span><br><span class=\"line\">    print(rsa_util.decrypt_text_with_path(private_key_path, encrypt_text_path))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    test_rsa_solution()</span><br><span class=\"line\">    get_key(BTC_RSA_PRIVATE_KEY_PATH, BTC_ENCRYPT_TEXT_PATH)</span><br></pre></td></tr></table></figure>\n"},{"title":"Markdown指南","date":"2021-08-27T08:07:38.000Z","_content":"[参考文章](https://www.markdown.xyz/getting-started/)\n","source":"_posts/blogTutorial/Markdown指南.md","raw":"---\ntitle: Markdown指南\ndate: 2021-08-27 16:07:38\ntags: 博客搭建\ncategories:\n- [博客搭建]\n---\n[参考文章](https://www.markdown.xyz/getting-started/)\n","slug":"blogTutorial/Markdown指南","published":1,"updated":"2022-04-12T09:00:46.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0az001jwgttcqbt09kg","content":"<p><a href=\"https://www.markdown.xyz/getting-started/\">参考文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.markdown.xyz/getting-started/\">参考文章</a></p>\n"},{"title":"博客搭建","date":"2021-08-24T02:52:32.000Z","_content":"\n\n```\n以下相关讲解均基于hexo + github pages方案，请注意！！！\n```\n\n\n### 博客搭建方案选择\n* [参考文章1](https://www.cnblogs.com/panchanggui/p/12483459.html)\n\n### 搭建教程\n* [参考文章1](https://zhuanlan.zhihu.com/p/26625249)\n\n### hexo + github pages搭建过程中遇到的问题\n#### 删除categories、tags\n1、删除含有需要删除categories、tags的文章\n2、hexo clean\n3、hexo s\n4、hexo g\n\n#### Support for password authentication was removed on August 13, 2021. Please use a personal access token instead\n  * github 不再支持password，必须使用Personal access tokens\n    * [参考文章1](http://odcowl.com/2021/08/16/Hexo%E5%8D%9A%E5%AE%A2%EF%BC%9Agithub%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882021-8-13%E6%9B%B4%E6%96%B0/)\n\n\n#### No layout: index.html\n  * 可能是主题未正确安装的问题\n    * [安装主题参考](https://www.haomwei.com/technology/maupassant-hexo.html)\n\n\n#### fatal: in unpopulated submodule '.deploy_git'\n  * 删除.deploy_git(rm -rf .deploy_git/)，然后重新hexo d\n\n#### git push 需要输入用户名密码问题\n* 需要改成token方式：\n  * git remove -v: 查看当前origin配置\n  * git remote remove origin：移除origin配置\n  * git remove -v：再次查看origin配置\n  * git remote add origin https://你的token@github.com/liquangang/liquangang.github.io.git\n  * git remote -v：查看是否修改成功\n\n#### hexo d 推动失败\n* 一种可能：依然是git配置问题，需要修改_config.yml文件中的git配置（deploy->repo），此处与git的正常配置一样，即设置origin（举例：https://你的token@github.com/liquangang/liquangang.github.io.git）\n* 另一种可能: 代码库地址配置的是http格式，换成ssh格式，然后重新配置一遍ssh key就行了（伤心&激动，搞了好久，一直在搞http格式的，一直没成功，不过我觉得http的也行，因为之前我用的就是http格式，不知道这次为什么不行了，总之现在确定ssh形式可以）\n\n\n#### hexo clean 等提示 node-sass问题\n* [参考文章](https://ld246.com/article/1514944079522)\n* 原因：node源不稳定\n* 解决：切换国内源（npm install -g cnpm --registry=https://registry.npm.taobao.org），然后使用cnpm命令执行操作\n\n#### err: Error: Spawn failed\n* 解决：\n    * 删除.deploy_git目录\n    * git config --global core.autocrlf false\n    * hexo clean && hexo g && hexo d\n    \n#### Node Sass could not find a binding for your current environment\n* node跟npm的版本不对应问题，尝试重新安装即可\n\n### 技巧\n#### 如何保存原始文章：\n* 目前笔者采用的方式是，在github上新建一个专门用来保存原始文章的分支，然后将原始文章push到这个分支上\n* push脚本：\n    ```\n        hexo clean;\n        git add .;\n        git commit -m \"博客文章更新\";\n        git push;\n        hexo g;\n        hexo d;\n        hexo clean;\n    ```\n","source":"_posts/blogTutorial/博客搭建.md","raw":"---\ntitle: 博客搭建\ndate: 2021-08-24 10:52:32\ntags: 博客搭建\ncategories:\n- [博客搭建]\n---\n\n\n```\n以下相关讲解均基于hexo + github pages方案，请注意！！！\n```\n\n\n### 博客搭建方案选择\n* [参考文章1](https://www.cnblogs.com/panchanggui/p/12483459.html)\n\n### 搭建教程\n* [参考文章1](https://zhuanlan.zhihu.com/p/26625249)\n\n### hexo + github pages搭建过程中遇到的问题\n#### 删除categories、tags\n1、删除含有需要删除categories、tags的文章\n2、hexo clean\n3、hexo s\n4、hexo g\n\n#### Support for password authentication was removed on August 13, 2021. Please use a personal access token instead\n  * github 不再支持password，必须使用Personal access tokens\n    * [参考文章1](http://odcowl.com/2021/08/16/Hexo%E5%8D%9A%E5%AE%A2%EF%BC%9Agithub%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882021-8-13%E6%9B%B4%E6%96%B0/)\n\n\n#### No layout: index.html\n  * 可能是主题未正确安装的问题\n    * [安装主题参考](https://www.haomwei.com/technology/maupassant-hexo.html)\n\n\n#### fatal: in unpopulated submodule '.deploy_git'\n  * 删除.deploy_git(rm -rf .deploy_git/)，然后重新hexo d\n\n#### git push 需要输入用户名密码问题\n* 需要改成token方式：\n  * git remove -v: 查看当前origin配置\n  * git remote remove origin：移除origin配置\n  * git remove -v：再次查看origin配置\n  * git remote add origin https://你的token@github.com/liquangang/liquangang.github.io.git\n  * git remote -v：查看是否修改成功\n\n#### hexo d 推动失败\n* 一种可能：依然是git配置问题，需要修改_config.yml文件中的git配置（deploy->repo），此处与git的正常配置一样，即设置origin（举例：https://你的token@github.com/liquangang/liquangang.github.io.git）\n* 另一种可能: 代码库地址配置的是http格式，换成ssh格式，然后重新配置一遍ssh key就行了（伤心&激动，搞了好久，一直在搞http格式的，一直没成功，不过我觉得http的也行，因为之前我用的就是http格式，不知道这次为什么不行了，总之现在确定ssh形式可以）\n\n\n#### hexo clean 等提示 node-sass问题\n* [参考文章](https://ld246.com/article/1514944079522)\n* 原因：node源不稳定\n* 解决：切换国内源（npm install -g cnpm --registry=https://registry.npm.taobao.org），然后使用cnpm命令执行操作\n\n#### err: Error: Spawn failed\n* 解决：\n    * 删除.deploy_git目录\n    * git config --global core.autocrlf false\n    * hexo clean && hexo g && hexo d\n    \n#### Node Sass could not find a binding for your current environment\n* node跟npm的版本不对应问题，尝试重新安装即可\n\n### 技巧\n#### 如何保存原始文章：\n* 目前笔者采用的方式是，在github上新建一个专门用来保存原始文章的分支，然后将原始文章push到这个分支上\n* push脚本：\n    ```\n        hexo clean;\n        git add .;\n        git commit -m \"博客文章更新\";\n        git push;\n        hexo g;\n        hexo d;\n        hexo clean;\n    ```\n","slug":"blogTutorial/博客搭建","published":1,"updated":"2022-04-12T09:00:46.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0b0001owgtth8em6mr8","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下相关讲解均基于hexo + github pages方案，请注意！！！</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"博客搭建方案选择\"><a href=\"#博客搭建方案选择\" class=\"headerlink\" title=\"博客搭建方案选择\"></a>博客搭建方案选择</h3><ul>\n<li><a href=\"https://www.cnblogs.com/panchanggui/p/12483459.html\">参考文章1</a></li>\n</ul>\n<h3 id=\"搭建教程\"><a href=\"#搭建教程\" class=\"headerlink\" title=\"搭建教程\"></a>搭建教程</h3><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26625249\">参考文章1</a></li>\n</ul>\n<h3 id=\"hexo-github-pages搭建过程中遇到的问题\"><a href=\"#hexo-github-pages搭建过程中遇到的问题\" class=\"headerlink\" title=\"hexo + github pages搭建过程中遇到的问题\"></a>hexo + github pages搭建过程中遇到的问题</h3><h4 id=\"删除categories、tags\"><a href=\"#删除categories、tags\" class=\"headerlink\" title=\"删除categories、tags\"></a>删除categories、tags</h4><p>1、删除含有需要删除categories、tags的文章<br>2、hexo clean<br>3、hexo s<br>4、hexo g</p>\n<h4 id=\"Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead\"><a href=\"#Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead\" class=\"headerlink\" title=\"Support for password authentication was removed on August 13, 2021. Please use a personal access token instead\"></a>Support for password authentication was removed on August 13, 2021. Please use a personal access token instead</h4><ul>\n<li>github 不再支持password，必须使用Personal access tokens<ul>\n<li><a href=\"http://odcowl.com/2021/08/16/Hexo%E5%8D%9A%E5%AE%A2%EF%BC%9Agithub%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882021-8-13%E6%9B%B4%E6%96%B0/\">参考文章1</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"No-layout-index-html\"><a href=\"#No-layout-index-html\" class=\"headerlink\" title=\"No layout: index.html\"></a>No layout: index.html</h4><ul>\n<li>可能是主题未正确安装的问题<ul>\n<li><a href=\"https://www.haomwei.com/technology/maupassant-hexo.html\">安装主题参考</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"fatal-in-unpopulated-submodule-‘-deploy-git’\"><a href=\"#fatal-in-unpopulated-submodule-‘-deploy-git’\" class=\"headerlink\" title=\"fatal: in unpopulated submodule ‘.deploy_git’\"></a>fatal: in unpopulated submodule ‘.deploy_git’</h4><ul>\n<li>删除.deploy_git(rm -rf .deploy_git/)，然后重新hexo d</li>\n</ul>\n<h4 id=\"git-push-需要输入用户名密码问题\"><a href=\"#git-push-需要输入用户名密码问题\" class=\"headerlink\" title=\"git push 需要输入用户名密码问题\"></a>git push 需要输入用户名密码问题</h4><ul>\n<li>需要改成token方式：<ul>\n<li>git remove -v: 查看当前origin配置</li>\n<li>git remote remove origin：移除origin配置</li>\n<li>git remove -v：再次查看origin配置</li>\n<li>git remote add origin https://你的<a href=\"mailto:&#x74;&#111;&#x6b;&#x65;&#110;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;\">&#x74;&#111;&#x6b;&#x65;&#110;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>/liquangang/liquangang.github.io.git</li>\n<li>git remote -v：查看是否修改成功</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"hexo-d-推动失败\"><a href=\"#hexo-d-推动失败\" class=\"headerlink\" title=\"hexo d 推动失败\"></a>hexo d 推动失败</h4><ul>\n<li>一种可能：依然是git配置问题，需要修改_config.yml文件中的git配置（deploy-&gt;repo），此处与git的正常配置一样，即设置origin（举例：https://你的<a href=\"mailto:&#x74;&#111;&#107;&#x65;&#110;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;\">&#x74;&#111;&#107;&#x65;&#110;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;</a>/liquangang/liquangang.github.io.git）</li>\n<li>另一种可能: 代码库地址配置的是http格式，换成ssh格式，然后重新配置一遍ssh key就行了（伤心&amp;激动，搞了好久，一直在搞http格式的，一直没成功，不过我觉得http的也行，因为之前我用的就是http格式，不知道这次为什么不行了，总之现在确定ssh形式可以）</li>\n</ul>\n<h4 id=\"hexo-clean-等提示-node-sass问题\"><a href=\"#hexo-clean-等提示-node-sass问题\" class=\"headerlink\" title=\"hexo clean 等提示 node-sass问题\"></a>hexo clean 等提示 node-sass问题</h4><ul>\n<li><a href=\"https://ld246.com/article/1514944079522\">参考文章</a></li>\n<li>原因：node源不稳定</li>\n<li>解决：切换国内源（npm install -g cnpm –registry=<a href=\"https://registry.npm.taobao.org),然后使用cnpm命令执行操作/\">https://registry.npm.taobao.org），然后使用cnpm命令执行操作</a></li>\n</ul>\n<h4 id=\"err-Error-Spawn-failed\"><a href=\"#err-Error-Spawn-failed\" class=\"headerlink\" title=\"err: Error: Spawn failed\"></a>err: Error: Spawn failed</h4><ul>\n<li>解决：<ul>\n<li>删除.deploy_git目录</li>\n<li>git config –global core.autocrlf false</li>\n<li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Node-Sass-could-not-find-a-binding-for-your-current-environment\"><a href=\"#Node-Sass-could-not-find-a-binding-for-your-current-environment\" class=\"headerlink\" title=\"Node Sass could not find a binding for your current environment\"></a>Node Sass could not find a binding for your current environment</h4><ul>\n<li>node跟npm的版本不对应问题，尝试重新安装即可</li>\n</ul>\n<h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><h4 id=\"如何保存原始文章：\"><a href=\"#如何保存原始文章：\" class=\"headerlink\" title=\"如何保存原始文章：\"></a>如何保存原始文章：</h4><ul>\n<li>目前笔者采用的方式是，在github上新建一个专门用来保存原始文章的分支，然后将原始文章push到这个分支上</li>\n<li>push脚本：  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean;</span><br><span class=\"line\">git add .;</span><br><span class=\"line\">git commit -m &quot;博客文章更新&quot;;</span><br><span class=\"line\">git push;</span><br><span class=\"line\">hexo g;</span><br><span class=\"line\">hexo d;</span><br><span class=\"line\">hexo clean;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下相关讲解均基于hexo + github pages方案，请注意！！！</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"博客搭建方案选择\"><a href=\"#博客搭建方案选择\" class=\"headerlink\" title=\"博客搭建方案选择\"></a>博客搭建方案选择</h3><ul>\n<li><a href=\"https://www.cnblogs.com/panchanggui/p/12483459.html\">参考文章1</a></li>\n</ul>\n<h3 id=\"搭建教程\"><a href=\"#搭建教程\" class=\"headerlink\" title=\"搭建教程\"></a>搭建教程</h3><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26625249\">参考文章1</a></li>\n</ul>\n<h3 id=\"hexo-github-pages搭建过程中遇到的问题\"><a href=\"#hexo-github-pages搭建过程中遇到的问题\" class=\"headerlink\" title=\"hexo + github pages搭建过程中遇到的问题\"></a>hexo + github pages搭建过程中遇到的问题</h3><h4 id=\"删除categories、tags\"><a href=\"#删除categories、tags\" class=\"headerlink\" title=\"删除categories、tags\"></a>删除categories、tags</h4><p>1、删除含有需要删除categories、tags的文章<br>2、hexo clean<br>3、hexo s<br>4、hexo g</p>\n<h4 id=\"Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead\"><a href=\"#Support-for-password-authentication-was-removed-on-August-13-2021-Please-use-a-personal-access-token-instead\" class=\"headerlink\" title=\"Support for password authentication was removed on August 13, 2021. Please use a personal access token instead\"></a>Support for password authentication was removed on August 13, 2021. Please use a personal access token instead</h4><ul>\n<li>github 不再支持password，必须使用Personal access tokens<ul>\n<li><a href=\"http://odcowl.com/2021/08/16/Hexo%E5%8D%9A%E5%AE%A2%EF%BC%9Agithub%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882021-8-13%E6%9B%B4%E6%96%B0/\">参考文章1</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"No-layout-index-html\"><a href=\"#No-layout-index-html\" class=\"headerlink\" title=\"No layout: index.html\"></a>No layout: index.html</h4><ul>\n<li>可能是主题未正确安装的问题<ul>\n<li><a href=\"https://www.haomwei.com/technology/maupassant-hexo.html\">安装主题参考</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"fatal-in-unpopulated-submodule-‘-deploy-git’\"><a href=\"#fatal-in-unpopulated-submodule-‘-deploy-git’\" class=\"headerlink\" title=\"fatal: in unpopulated submodule ‘.deploy_git’\"></a>fatal: in unpopulated submodule ‘.deploy_git’</h4><ul>\n<li>删除.deploy_git(rm -rf .deploy_git/)，然后重新hexo d</li>\n</ul>\n<h4 id=\"git-push-需要输入用户名密码问题\"><a href=\"#git-push-需要输入用户名密码问题\" class=\"headerlink\" title=\"git push 需要输入用户名密码问题\"></a>git push 需要输入用户名密码问题</h4><ul>\n<li>需要改成token方式：<ul>\n<li>git remove -v: 查看当前origin配置</li>\n<li>git remote remove origin：移除origin配置</li>\n<li>git remove -v：再次查看origin配置</li>\n<li>git remote add origin https://你的<a href=\"mailto:&#x74;&#111;&#x6b;&#x65;&#110;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;\">&#x74;&#111;&#x6b;&#x65;&#110;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#x6d;</a>/liquangang/liquangang.github.io.git</li>\n<li>git remote -v：查看是否修改成功</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"hexo-d-推动失败\"><a href=\"#hexo-d-推动失败\" class=\"headerlink\" title=\"hexo d 推动失败\"></a>hexo d 推动失败</h4><ul>\n<li>一种可能：依然是git配置问题，需要修改_config.yml文件中的git配置（deploy-&gt;repo），此处与git的正常配置一样，即设置origin（举例：https://你的<a href=\"mailto:&#x74;&#111;&#107;&#x65;&#110;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;\">&#x74;&#111;&#107;&#x65;&#110;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#109;</a>/liquangang/liquangang.github.io.git）</li>\n<li>另一种可能: 代码库地址配置的是http格式，换成ssh格式，然后重新配置一遍ssh key就行了（伤心&amp;激动，搞了好久，一直在搞http格式的，一直没成功，不过我觉得http的也行，因为之前我用的就是http格式，不知道这次为什么不行了，总之现在确定ssh形式可以）</li>\n</ul>\n<h4 id=\"hexo-clean-等提示-node-sass问题\"><a href=\"#hexo-clean-等提示-node-sass问题\" class=\"headerlink\" title=\"hexo clean 等提示 node-sass问题\"></a>hexo clean 等提示 node-sass问题</h4><ul>\n<li><a href=\"https://ld246.com/article/1514944079522\">参考文章</a></li>\n<li>原因：node源不稳定</li>\n<li>解决：切换国内源（npm install -g cnpm –registry=<a href=\"https://registry.npm.taobao.org),然后使用cnpm命令执行操作/\">https://registry.npm.taobao.org），然后使用cnpm命令执行操作</a></li>\n</ul>\n<h4 id=\"err-Error-Spawn-failed\"><a href=\"#err-Error-Spawn-failed\" class=\"headerlink\" title=\"err: Error: Spawn failed\"></a>err: Error: Spawn failed</h4><ul>\n<li>解决：<ul>\n<li>删除.deploy_git目录</li>\n<li>git config –global core.autocrlf false</li>\n<li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Node-Sass-could-not-find-a-binding-for-your-current-environment\"><a href=\"#Node-Sass-could-not-find-a-binding-for-your-current-environment\" class=\"headerlink\" title=\"Node Sass could not find a binding for your current environment\"></a>Node Sass could not find a binding for your current environment</h4><ul>\n<li>node跟npm的版本不对应问题，尝试重新安装即可</li>\n</ul>\n<h3 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h3><h4 id=\"如何保存原始文章：\"><a href=\"#如何保存原始文章：\" class=\"headerlink\" title=\"如何保存原始文章：\"></a>如何保存原始文章：</h4><ul>\n<li>目前笔者采用的方式是，在github上新建一个专门用来保存原始文章的分支，然后将原始文章push到这个分支上</li>\n<li>push脚本：  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean;</span><br><span class=\"line\">git add .;</span><br><span class=\"line\">git commit -m &quot;博客文章更新&quot;;</span><br><span class=\"line\">git push;</span><br><span class=\"line\">hexo g;</span><br><span class=\"line\">hexo d;</span><br><span class=\"line\">hexo clean;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"栈","date":"2021-11-15T02:16:31.000Z","_content":"\n### 定义\n* 一种特殊线性表\n\n### 特点\n* 只允许在表尾删除、插入\n\n### 示例\n```\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\nclass StackTest(object):\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        self.items.pop();\n\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    def size(self):\n        return len(self.items)\n\n\ndef reverseArrayItem(array):\n    stackTest = StackTest()\n\n    for item in array:\n        stackTest.push(item)\n\n    while stackTest.size() > 0:\n        print(stackTest.peek())\n        stackTest.pop()\n\n\n\nif __name__ == \"__main__\":\n    tmpArray = [1, 2, 3]\n    reverseArrayItem(tmpArray)\n```","source":"_posts/dataStructure/栈.md","raw":"---\ntitle: 栈\ndate: 2021-11-15 10:16:31\ntags: 编程\ncategories:\n- [数据结构]\n---\n\n### 定义\n* 一种特殊线性表\n\n### 特点\n* 只允许在表尾删除、插入\n\n### 示例\n```\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\nclass StackTest(object):\n    def __init__(self):\n        self.items = []\n\n    def is_empty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        self.items.pop();\n\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    def size(self):\n        return len(self.items)\n\n\ndef reverseArrayItem(array):\n    stackTest = StackTest()\n\n    for item in array:\n        stackTest.push(item)\n\n    while stackTest.size() > 0:\n        print(stackTest.peek())\n        stackTest.pop()\n\n\n\nif __name__ == \"__main__\":\n    tmpArray = [1, 2, 3]\n    reverseArrayItem(tmpArray)\n```","slug":"dataStructure/栈","published":1,"updated":"2022-04-12T09:00:46.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0b1001rwgttf2uh639w","content":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>一种特殊线性表</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只允许在表尾删除、插入</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\"># -*- coding: UTF-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">class StackTest(object):</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.items = []</span><br><span class=\"line\"></span><br><span class=\"line\">    def is_empty(self):</span><br><span class=\"line\">        return self.items == []</span><br><span class=\"line\"></span><br><span class=\"line\">    def push(self, item):</span><br><span class=\"line\">        self.items.append(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    def pop(self):</span><br><span class=\"line\">        self.items.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    def peek(self):</span><br><span class=\"line\">        return self.items[len(self.items) - 1]</span><br><span class=\"line\"></span><br><span class=\"line\">    def size(self):</span><br><span class=\"line\">        return len(self.items)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def reverseArrayItem(array):</span><br><span class=\"line\">    stackTest = StackTest()</span><br><span class=\"line\"></span><br><span class=\"line\">    for item in array:</span><br><span class=\"line\">        stackTest.push(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    while stackTest.size() &gt; 0:</span><br><span class=\"line\">        print(stackTest.peek())</span><br><span class=\"line\">        stackTest.pop()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    tmpArray = [1, 2, 3]</span><br><span class=\"line\">    reverseArrayItem(tmpArray)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>一种特殊线性表</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只允许在表尾删除、插入</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\"># -*- coding: UTF-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">class StackTest(object):</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.items = []</span><br><span class=\"line\"></span><br><span class=\"line\">    def is_empty(self):</span><br><span class=\"line\">        return self.items == []</span><br><span class=\"line\"></span><br><span class=\"line\">    def push(self, item):</span><br><span class=\"line\">        self.items.append(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    def pop(self):</span><br><span class=\"line\">        self.items.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    def peek(self):</span><br><span class=\"line\">        return self.items[len(self.items) - 1]</span><br><span class=\"line\"></span><br><span class=\"line\">    def size(self):</span><br><span class=\"line\">        return len(self.items)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def reverseArrayItem(array):</span><br><span class=\"line\">    stackTest = StackTest()</span><br><span class=\"line\"></span><br><span class=\"line\">    for item in array:</span><br><span class=\"line\">        stackTest.push(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    while stackTest.size() &gt; 0:</span><br><span class=\"line\">        print(stackTest.peek())</span><br><span class=\"line\">        stackTest.pop()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    tmpArray = [1, 2, 3]</span><br><span class=\"line\">    reverseArrayItem(tmpArray)</span><br></pre></td></tr></table></figure>"},{"title":"队列","date":"2021-11-14T14:07:48.000Z","_content":"\n### 定义\n* 一种特殊线性表\n\n### 特点\n* 只允许表头删除，表尾插入\n\n### 示例\n```\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def peek(self):\n        item = self.items[0]\n        self.dequeue()\n        return item\n\n    def dequeue(self):\n        return self.items.pop(0)\n\n    def empty(self):\n        return self.size() == 0\n\n    def size(self):\n        return len(self.items)\n\n\ndef sendMessage(array):\n    messageQueue = Queue()\n\n    for item in array:\n        messageQueue.enqueue(item)\n\n    while messageQueue.empty() is False:\n        print(\"发送\" + messageQueue.peek())\n\nif __name__ == \"__main__\":\n    array = [\"消息1\", \"消息2\", \"消息3\"]\n    sendMessage(array)\n```","source":"_posts/dataStructure/队列.md","raw":"---\ntitle: 队列\ndate: 2021-11-14 22:07:48\ntags: 编程\ncategories:\n- [数据结构]\n---\n\n### 定义\n* 一种特殊线性表\n\n### 特点\n* 只允许表头删除，表尾插入\n\n### 示例\n```\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def peek(self):\n        item = self.items[0]\n        self.dequeue()\n        return item\n\n    def dequeue(self):\n        return self.items.pop(0)\n\n    def empty(self):\n        return self.size() == 0\n\n    def size(self):\n        return len(self.items)\n\n\ndef sendMessage(array):\n    messageQueue = Queue()\n\n    for item in array:\n        messageQueue.enqueue(item)\n\n    while messageQueue.empty() is False:\n        print(\"发送\" + messageQueue.peek())\n\nif __name__ == \"__main__\":\n    array = [\"消息1\", \"消息2\", \"消息3\"]\n    sendMessage(array)\n```","slug":"dataStructure/队列","published":1,"updated":"2022-04-12T09:00:46.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0b2001vwgttfya5hjc8","content":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>一种特殊线性表</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只允许表头删除，表尾插入</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\"># -*- coding: UTF-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">class Queue:</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.items = []</span><br><span class=\"line\"></span><br><span class=\"line\">    def enqueue(self, item):</span><br><span class=\"line\">        self.items.append(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    def peek(self):</span><br><span class=\"line\">        item = self.items[0]</span><br><span class=\"line\">        self.dequeue()</span><br><span class=\"line\">        return item</span><br><span class=\"line\"></span><br><span class=\"line\">    def dequeue(self):</span><br><span class=\"line\">        return self.items.pop(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    def empty(self):</span><br><span class=\"line\">        return self.size() == 0</span><br><span class=\"line\"></span><br><span class=\"line\">    def size(self):</span><br><span class=\"line\">        return len(self.items)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def sendMessage(array):</span><br><span class=\"line\">    messageQueue = Queue()</span><br><span class=\"line\"></span><br><span class=\"line\">    for item in array:</span><br><span class=\"line\">        messageQueue.enqueue(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    while messageQueue.empty() is False:</span><br><span class=\"line\">        print(&quot;发送&quot; + messageQueue.peek())</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    array = [&quot;消息1&quot;, &quot;消息2&quot;, &quot;消息3&quot;]</span><br><span class=\"line\">    sendMessage(array)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>一种特殊线性表</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只允许表头删除，表尾插入</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\"># -*- coding: UTF-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">class Queue:</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.items = []</span><br><span class=\"line\"></span><br><span class=\"line\">    def enqueue(self, item):</span><br><span class=\"line\">        self.items.append(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    def peek(self):</span><br><span class=\"line\">        item = self.items[0]</span><br><span class=\"line\">        self.dequeue()</span><br><span class=\"line\">        return item</span><br><span class=\"line\"></span><br><span class=\"line\">    def dequeue(self):</span><br><span class=\"line\">        return self.items.pop(0)</span><br><span class=\"line\"></span><br><span class=\"line\">    def empty(self):</span><br><span class=\"line\">        return self.size() == 0</span><br><span class=\"line\"></span><br><span class=\"line\">    def size(self):</span><br><span class=\"line\">        return len(self.items)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def sendMessage(array):</span><br><span class=\"line\">    messageQueue = Queue()</span><br><span class=\"line\"></span><br><span class=\"line\">    for item in array:</span><br><span class=\"line\">        messageQueue.enqueue(item)</span><br><span class=\"line\"></span><br><span class=\"line\">    while messageQueue.empty() is False:</span><br><span class=\"line\">        print(&quot;发送&quot; + messageQueue.peek())</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    array = [&quot;消息1&quot;, &quot;消息2&quot;, &quot;消息3&quot;]</span><br><span class=\"line\">    sendMessage(array)</span><br></pre></td></tr></table></figure>"},{"title":"代码规范","date":"2021-08-26T13:10:44.000Z","_content":"\n## Java\n### 标识符命名\n* 小驼峰命名法\n  * 示例：studentName\n  * 适用：函数命名、变量命名、常量命名\n* 大驼峰命名法\n  * 示例：StudentName\n  * 适用：类命名、接口命名\n### 类定义\n* 类变量默认使用private\n","source":"_posts/codeStyle/代码规范.md","raw":"---\ntitle: 代码规范\ndate: 2021-08-26 21:10:44\ntags: 编程\ncategories:\n- [codeStyle]\n---\n\n## Java\n### 标识符命名\n* 小驼峰命名法\n  * 示例：studentName\n  * 适用：函数命名、变量命名、常量命名\n* 大驼峰命名法\n  * 示例：StudentName\n  * 适用：类命名、接口命名\n### 类定义\n* 类变量默认使用private\n","slug":"codeStyle/代码规范","published":1,"updated":"2022-04-12T09:00:46.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0b3001zwgtt2xec379e","content":"<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h3 id=\"标识符命名\"><a href=\"#标识符命名\" class=\"headerlink\" title=\"标识符命名\"></a>标识符命名</h3><ul>\n<li>小驼峰命名法<ul>\n<li>示例：studentName</li>\n<li>适用：函数命名、变量命名、常量命名</li>\n</ul>\n</li>\n<li>大驼峰命名法<ul>\n<li>示例：StudentName</li>\n<li>适用：类命名、接口命名<h3 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h3></li>\n</ul>\n</li>\n<li>类变量默认使用private</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h3 id=\"标识符命名\"><a href=\"#标识符命名\" class=\"headerlink\" title=\"标识符命名\"></a>标识符命名</h3><ul>\n<li>小驼峰命名法<ul>\n<li>示例：studentName</li>\n<li>适用：函数命名、变量命名、常量命名</li>\n</ul>\n</li>\n<li>大驼峰命名法<ul>\n<li>示例：StudentName</li>\n<li>适用：类命名、接口命名<h3 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h3></li>\n</ul>\n</li>\n<li>类变量默认使用private</li>\n</ul>\n"},{"title":"redis","date":"2021-09-09T03:04:25.000Z","_content":"\n### 常用命令\n* 链接redis服务：redis-cli\n* 获取某个key（xxx）的数据：get xxx\n\n","source":"_posts/module/redis.md","raw":"---\ntitle: redis\ndate: 2021-09-09 11:04:25\ntags: 编程\ncategories:\n- [组件]\n---\n\n### 常用命令\n* 链接redis服务：redis-cli\n* 获取某个key（xxx）的数据：get xxx\n\n","slug":"module/redis","published":1,"updated":"2022-04-12T09:00:46.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0b50023wgtt32jz0gau","content":"<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>链接redis服务：redis-cli</li>\n<li>获取某个key（xxx）的数据：get xxx</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>链接redis服务：redis-cli</li>\n<li>获取某个key（xxx）的数据：get xxx</li>\n</ul>\n"},{"title":"IDEA指南","date":"2021-08-31T02:39:05.000Z","_content":"\n### IDEA简介\n* 截止到2021.08.31，是全世界最流行的Java集成开发环境\n\n### tips\n#### 快捷键\n* ctrl + alt + v：快速生成方法返回值接收代码\n* /** + enter：生成javaDoc注释\n\n### IDEA常见error\n#### Error: java: System Java Compiler was not found in classpath\n* Project Settings > Compiler > Java Compiler \n    * changed the drop down Use compiler from Javac to Eclipse\n  \n#### Error:java: source level should be comprised in between '1.3' and '1.9' (or '5', '5.0', ..., '9' or '9.0'): 12\n* Preferences部分设置\n    * Preferences > Compiler > Java Compiler > Use compiler, 选javac\n    * Project bytecode version，选8，根据project sdk来确定\n    * Target bytecode version，选8，与Project bytecode version保持一致\n* Project structure部分设置\n    * Project structure > project > project sdk，选择1.8\n    * Project language level，选SDK default\n    * Modules > source > language level, 选Project default\n\n\n### IDEA 破解\n* [参考链接](https://www.cnblogs.com/vitual/p/11361406.html)\n","source":"_posts/toolApplication/IDEA指南.md","raw":"---\ntitle: IDEA指南\ndate: 2021-08-31 10:39:05\ntags: 编程\ncategories:\n- [工具应用]\n---\n\n### IDEA简介\n* 截止到2021.08.31，是全世界最流行的Java集成开发环境\n\n### tips\n#### 快捷键\n* ctrl + alt + v：快速生成方法返回值接收代码\n* /** + enter：生成javaDoc注释\n\n### IDEA常见error\n#### Error: java: System Java Compiler was not found in classpath\n* Project Settings > Compiler > Java Compiler \n    * changed the drop down Use compiler from Javac to Eclipse\n  \n#### Error:java: source level should be comprised in between '1.3' and '1.9' (or '5', '5.0', ..., '9' or '9.0'): 12\n* Preferences部分设置\n    * Preferences > Compiler > Java Compiler > Use compiler, 选javac\n    * Project bytecode version，选8，根据project sdk来确定\n    * Target bytecode version，选8，与Project bytecode version保持一致\n* Project structure部分设置\n    * Project structure > project > project sdk，选择1.8\n    * Project language level，选SDK default\n    * Modules > source > language level, 选Project default\n\n\n### IDEA 破解\n* [参考链接](https://www.cnblogs.com/vitual/p/11361406.html)\n","slug":"toolApplication/IDEA指南","published":1,"updated":"2022-04-12T09:00:46.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bn002nwgttgj8e17zp","content":"<h3 id=\"IDEA简介\"><a href=\"#IDEA简介\" class=\"headerlink\" title=\"IDEA简介\"></a>IDEA简介</h3><ul>\n<li>截止到2021.08.31，是全世界最流行的Java集成开发环境</li>\n</ul>\n<h3 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h3><h4 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><ul>\n<li>ctrl + alt + v：快速生成方法返回值接收代码</li>\n<li>/** + enter：生成javaDoc注释</li>\n</ul>\n<h3 id=\"IDEA常见error\"><a href=\"#IDEA常见error\" class=\"headerlink\" title=\"IDEA常见error\"></a>IDEA常见error</h3><h4 id=\"Error-java-System-Java-Compiler-was-not-found-in-classpath\"><a href=\"#Error-java-System-Java-Compiler-was-not-found-in-classpath\" class=\"headerlink\" title=\"Error: java: System Java Compiler was not found in classpath\"></a>Error: java: System Java Compiler was not found in classpath</h4><ul>\n<li>Project Settings &gt; Compiler &gt; Java Compiler <ul>\n<li>changed the drop down Use compiler from Javac to Eclipse</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Error-java-source-level-should-be-comprised-in-between-‘1-3’-and-‘1-9’-or-‘5’-‘5-0’-…-‘9’-or-‘9-0’-12\"><a href=\"#Error-java-source-level-should-be-comprised-in-between-‘1-3’-and-‘1-9’-or-‘5’-‘5-0’-…-‘9’-or-‘9-0’-12\" class=\"headerlink\" title=\"Error:java: source level should be comprised in between ‘1.3’ and ‘1.9’ (or ‘5’, ‘5.0’, …, ‘9’ or ‘9.0’): 12\"></a>Error:java: source level should be comprised in between ‘1.3’ and ‘1.9’ (or ‘5’, ‘5.0’, …, ‘9’ or ‘9.0’): 12</h4><ul>\n<li>Preferences部分设置<ul>\n<li>Preferences &gt; Compiler &gt; Java Compiler &gt; Use compiler, 选javac</li>\n<li>Project bytecode version，选8，根据project sdk来确定</li>\n<li>Target bytecode version，选8，与Project bytecode version保持一致</li>\n</ul>\n</li>\n<li>Project structure部分设置<ul>\n<li>Project structure &gt; project &gt; project sdk，选择1.8</li>\n<li>Project language level，选SDK default</li>\n<li>Modules &gt; source &gt; language level, 选Project default</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IDEA-破解\"><a href=\"#IDEA-破解\" class=\"headerlink\" title=\"IDEA 破解\"></a>IDEA 破解</h3><ul>\n<li><a href=\"https://www.cnblogs.com/vitual/p/11361406.html\">参考链接</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"IDEA简介\"><a href=\"#IDEA简介\" class=\"headerlink\" title=\"IDEA简介\"></a>IDEA简介</h3><ul>\n<li>截止到2021.08.31，是全世界最流行的Java集成开发环境</li>\n</ul>\n<h3 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h3><h4 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><ul>\n<li>ctrl + alt + v：快速生成方法返回值接收代码</li>\n<li>/** + enter：生成javaDoc注释</li>\n</ul>\n<h3 id=\"IDEA常见error\"><a href=\"#IDEA常见error\" class=\"headerlink\" title=\"IDEA常见error\"></a>IDEA常见error</h3><h4 id=\"Error-java-System-Java-Compiler-was-not-found-in-classpath\"><a href=\"#Error-java-System-Java-Compiler-was-not-found-in-classpath\" class=\"headerlink\" title=\"Error: java: System Java Compiler was not found in classpath\"></a>Error: java: System Java Compiler was not found in classpath</h4><ul>\n<li>Project Settings &gt; Compiler &gt; Java Compiler <ul>\n<li>changed the drop down Use compiler from Javac to Eclipse</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Error-java-source-level-should-be-comprised-in-between-‘1-3’-and-‘1-9’-or-‘5’-‘5-0’-…-‘9’-or-‘9-0’-12\"><a href=\"#Error-java-source-level-should-be-comprised-in-between-‘1-3’-and-‘1-9’-or-‘5’-‘5-0’-…-‘9’-or-‘9-0’-12\" class=\"headerlink\" title=\"Error:java: source level should be comprised in between ‘1.3’ and ‘1.9’ (or ‘5’, ‘5.0’, …, ‘9’ or ‘9.0’): 12\"></a>Error:java: source level should be comprised in between ‘1.3’ and ‘1.9’ (or ‘5’, ‘5.0’, …, ‘9’ or ‘9.0’): 12</h4><ul>\n<li>Preferences部分设置<ul>\n<li>Preferences &gt; Compiler &gt; Java Compiler &gt; Use compiler, 选javac</li>\n<li>Project bytecode version，选8，根据project sdk来确定</li>\n<li>Target bytecode version，选8，与Project bytecode version保持一致</li>\n</ul>\n</li>\n<li>Project structure部分设置<ul>\n<li>Project structure &gt; project &gt; project sdk，选择1.8</li>\n<li>Project language level，选SDK default</li>\n<li>Modules &gt; source &gt; language level, 选Project default</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"IDEA-破解\"><a href=\"#IDEA-破解\" class=\"headerlink\" title=\"IDEA 破解\"></a>IDEA 破解</h3><ul>\n<li><a href=\"https://www.cnblogs.com/vitual/p/11361406.html\">参考链接</a></li>\n</ul>\n"},{"title":"PyCharm指南","date":"2022-01-30T04:41:37.000Z","_content":"\n### 安装\n* 相关资源\n  * [安装教程](http://www.noobyard.com/article/p-kllghgsu-mc.html)\n  * [\"x.app已损坏\"修复教程](https://www.macwk.com/article/mac-catalina-1015-file-damage)\n* 注意点：\n  * 尽量使用旧版本即可，新版本不容易实现破解\n","source":"_posts/toolApplication/PyCharm指南.md","raw":"---\ntitle: PyCharm指南\ndate: 2022-01-30 12:41:37\ntags: 编程\ncategories:\n- [工具应用]\n---\n\n### 安装\n* 相关资源\n  * [安装教程](http://www.noobyard.com/article/p-kllghgsu-mc.html)\n  * [\"x.app已损坏\"修复教程](https://www.macwk.com/article/mac-catalina-1015-file-damage)\n* 注意点：\n  * 尽量使用旧版本即可，新版本不容易实现破解\n","slug":"toolApplication/PyCharm指南","published":1,"updated":"2022-04-12T09:00:46.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bn002owgttc754ffoz","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>相关资源<ul>\n<li><a href=\"http://www.noobyard.com/article/p-kllghgsu-mc.html\">安装教程</a></li>\n<li><a href=\"https://www.macwk.com/article/mac-catalina-1015-file-damage\">“x.app已损坏”修复教程</a></li>\n</ul>\n</li>\n<li>注意点：<ul>\n<li>尽量使用旧版本即可，新版本不容易实现破解</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>相关资源<ul>\n<li><a href=\"http://www.noobyard.com/article/p-kllghgsu-mc.html\">安装教程</a></li>\n<li><a href=\"https://www.macwk.com/article/mac-catalina-1015-file-damage\">“x.app已损坏”修复教程</a></li>\n</ul>\n</li>\n<li>注意点：<ul>\n<li>尽量使用旧版本即可，新版本不容易实现破解</li>\n</ul>\n</li>\n</ul>\n"},{"title":"git指南","date":"2022-03-11T03:50:59.000Z","_content":"\n### 常用命令\n#### 常用流程\n* git pull\n* git add .; git add [filename]\n* git commit -m \"\"; git commit --amend\n* git push\n* git status: 查看本次修改\n\n#### stash\n* git stash\n* git stash save \"我是暂存名称\"\n* git stash pop\n* git stash list\n* git stash clear\n* git stash drop [stashId]: 删除某个暂存\n* git stash apply [stashId]: 使用某个暂存\n\n#### commit\n* git reset --soft 想撤回到的commit：撤回commit\n* git log: 查看commit 记录\n\n#### dif\n* git diff\n\n### branch\n* git branch -D [branchId]: 删除本地分支\n* git checkout -b 分支名：切换，如没有，就新建然后切换\n* \n\n### checkout\n*  git checkout -b device_3-1-3_BRANCH origin/device_3-1-3_BRANCH: 拉取远程分支\n\n### 取消追踪某些文件\n\n","source":"_posts/toolApplication/git指南.md","raw":"---\ntitle: git指南\ndate: 2022-03-11 11:50:59\ntags: 编程\ncategories:\n- [工具应用]\n---\n\n### 常用命令\n#### 常用流程\n* git pull\n* git add .; git add [filename]\n* git commit -m \"\"; git commit --amend\n* git push\n* git status: 查看本次修改\n\n#### stash\n* git stash\n* git stash save \"我是暂存名称\"\n* git stash pop\n* git stash list\n* git stash clear\n* git stash drop [stashId]: 删除某个暂存\n* git stash apply [stashId]: 使用某个暂存\n\n#### commit\n* git reset --soft 想撤回到的commit：撤回commit\n* git log: 查看commit 记录\n\n#### dif\n* git diff\n\n### branch\n* git branch -D [branchId]: 删除本地分支\n* git checkout -b 分支名：切换，如没有，就新建然后切换\n* \n\n### checkout\n*  git checkout -b device_3-1-3_BRANCH origin/device_3-1-3_BRANCH: 拉取远程分支\n\n### 取消追踪某些文件\n\n","slug":"toolApplication/git指南","published":1,"updated":"2022-04-12T09:00:46.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bo002qwgtt2tpx5zce","content":"<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h4 id=\"常用流程\"><a href=\"#常用流程\" class=\"headerlink\" title=\"常用流程\"></a>常用流程</h4><ul>\n<li>git pull</li>\n<li>git add .; git add [filename]</li>\n<li>git commit -m “”; git commit –amend</li>\n<li>git push</li>\n<li>git status: 查看本次修改</li>\n</ul>\n<h4 id=\"stash\"><a href=\"#stash\" class=\"headerlink\" title=\"stash\"></a>stash</h4><ul>\n<li>git stash</li>\n<li>git stash save “我是暂存名称”</li>\n<li>git stash pop</li>\n<li>git stash list</li>\n<li>git stash clear</li>\n<li>git stash drop [stashId]: 删除某个暂存</li>\n<li>git stash apply [stashId]: 使用某个暂存</li>\n</ul>\n<h4 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h4><ul>\n<li>git reset –soft 想撤回到的commit：撤回commit</li>\n<li>git log: 查看commit 记录</li>\n</ul>\n<h4 id=\"dif\"><a href=\"#dif\" class=\"headerlink\" title=\"dif\"></a>dif</h4><ul>\n<li>git diff</li>\n</ul>\n<h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><ul>\n<li>git branch -D [branchId]: 删除本地分支</li>\n<li>git checkout -b 分支名：切换，如没有，就新建然后切换</li>\n<li></li>\n</ul>\n<h3 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h3><ul>\n<li> git checkout -b device_3-1-3_BRANCH origin/device_3-1-3_BRANCH: 拉取远程分支</li>\n</ul>\n<h3 id=\"取消追踪某些文件\"><a href=\"#取消追踪某些文件\" class=\"headerlink\" title=\"取消追踪某些文件\"></a>取消追踪某些文件</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><h4 id=\"常用流程\"><a href=\"#常用流程\" class=\"headerlink\" title=\"常用流程\"></a>常用流程</h4><ul>\n<li>git pull</li>\n<li>git add .; git add [filename]</li>\n<li>git commit -m “”; git commit –amend</li>\n<li>git push</li>\n<li>git status: 查看本次修改</li>\n</ul>\n<h4 id=\"stash\"><a href=\"#stash\" class=\"headerlink\" title=\"stash\"></a>stash</h4><ul>\n<li>git stash</li>\n<li>git stash save “我是暂存名称”</li>\n<li>git stash pop</li>\n<li>git stash list</li>\n<li>git stash clear</li>\n<li>git stash drop [stashId]: 删除某个暂存</li>\n<li>git stash apply [stashId]: 使用某个暂存</li>\n</ul>\n<h4 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h4><ul>\n<li>git reset –soft 想撤回到的commit：撤回commit</li>\n<li>git log: 查看commit 记录</li>\n</ul>\n<h4 id=\"dif\"><a href=\"#dif\" class=\"headerlink\" title=\"dif\"></a>dif</h4><ul>\n<li>git diff</li>\n</ul>\n<h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><ul>\n<li>git branch -D [branchId]: 删除本地分支</li>\n<li>git checkout -b 分支名：切换，如没有，就新建然后切换</li>\n<li></li>\n</ul>\n<h3 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h3><ul>\n<li> git checkout -b device_3-1-3_BRANCH origin/device_3-1-3_BRANCH: 拉取远程分支</li>\n</ul>\n<h3 id=\"取消追踪某些文件\"><a href=\"#取消追踪某些文件\" class=\"headerlink\" title=\"取消追踪某些文件\"></a>取消追踪某些文件</h3>"},{"title":"mac使用技巧","date":"2021-09-25T04:28:45.000Z","_content":"\n## 应用问题\n### g hub（罗技出品）卡在\"正在初始化\"问题\n* 问题原因：可能是已经安装过导致\n* 解决方法：删除电脑上lghub相关的文件，需要从Macintosh HD目录开始搜索\n\n### 文件已损坏，***\n* [参考文章](https://www.macwk.com/article/macos-file-damage)\n\n### iphone 链接 mac 闪断问题\n* [参考文章](https://blog.csdn.net/weixin_43971980/article/details/113804704)\n\n## 系统技巧\n### 横向滑动技巧\n* shift+鼠标滚动\n","source":"_posts/toolApplication/mac使用记录.md","raw":"---\ntitle: mac使用技巧\ndate: 2021-09-25 12:28:45\ntags: 电脑使用技巧\ncategories:\n- [mac使用技巧]\n---\n\n## 应用问题\n### g hub（罗技出品）卡在\"正在初始化\"问题\n* 问题原因：可能是已经安装过导致\n* 解决方法：删除电脑上lghub相关的文件，需要从Macintosh HD目录开始搜索\n\n### 文件已损坏，***\n* [参考文章](https://www.macwk.com/article/macos-file-damage)\n\n### iphone 链接 mac 闪断问题\n* [参考文章](https://blog.csdn.net/weixin_43971980/article/details/113804704)\n\n## 系统技巧\n### 横向滑动技巧\n* shift+鼠标滚动\n","slug":"toolApplication/mac使用记录","published":1,"updated":"2022-04-12T09:00:46.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bp002twgtta5dk9ro2","content":"<h2 id=\"应用问题\"><a href=\"#应用问题\" class=\"headerlink\" title=\"应用问题\"></a>应用问题</h2><h3 id=\"g-hub（罗技出品）卡在”正在初始化”问题\"><a href=\"#g-hub（罗技出品）卡在”正在初始化”问题\" class=\"headerlink\" title=\"g hub（罗技出品）卡在”正在初始化”问题\"></a>g hub（罗技出品）卡在”正在初始化”问题</h3><ul>\n<li>问题原因：可能是已经安装过导致</li>\n<li>解决方法：删除电脑上lghub相关的文件，需要从Macintosh HD目录开始搜索</li>\n</ul>\n<h3 id=\"文件已损坏，\"><a href=\"#文件已损坏，\" class=\"headerlink\" title=\"文件已损坏，***\"></a>文件已损坏，***</h3><ul>\n<li><a href=\"https://www.macwk.com/article/macos-file-damage\">参考文章</a></li>\n</ul>\n<h3 id=\"iphone-链接-mac-闪断问题\"><a href=\"#iphone-链接-mac-闪断问题\" class=\"headerlink\" title=\"iphone 链接 mac 闪断问题\"></a>iphone 链接 mac 闪断问题</h3><ul>\n<li><a href=\"https://blog.csdn.net/weixin_43971980/article/details/113804704\">参考文章</a></li>\n</ul>\n<h2 id=\"系统技巧\"><a href=\"#系统技巧\" class=\"headerlink\" title=\"系统技巧\"></a>系统技巧</h2><h3 id=\"横向滑动技巧\"><a href=\"#横向滑动技巧\" class=\"headerlink\" title=\"横向滑动技巧\"></a>横向滑动技巧</h3><ul>\n<li>shift+鼠标滚动</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用问题\"><a href=\"#应用问题\" class=\"headerlink\" title=\"应用问题\"></a>应用问题</h2><h3 id=\"g-hub（罗技出品）卡在”正在初始化”问题\"><a href=\"#g-hub（罗技出品）卡在”正在初始化”问题\" class=\"headerlink\" title=\"g hub（罗技出品）卡在”正在初始化”问题\"></a>g hub（罗技出品）卡在”正在初始化”问题</h3><ul>\n<li>问题原因：可能是已经安装过导致</li>\n<li>解决方法：删除电脑上lghub相关的文件，需要从Macintosh HD目录开始搜索</li>\n</ul>\n<h3 id=\"文件已损坏，\"><a href=\"#文件已损坏，\" class=\"headerlink\" title=\"文件已损坏，***\"></a>文件已损坏，***</h3><ul>\n<li><a href=\"https://www.macwk.com/article/macos-file-damage\">参考文章</a></li>\n</ul>\n<h3 id=\"iphone-链接-mac-闪断问题\"><a href=\"#iphone-链接-mac-闪断问题\" class=\"headerlink\" title=\"iphone 链接 mac 闪断问题\"></a>iphone 链接 mac 闪断问题</h3><ul>\n<li><a href=\"https://blog.csdn.net/weixin_43971980/article/details/113804704\">参考文章</a></li>\n</ul>\n<h2 id=\"系统技巧\"><a href=\"#系统技巧\" class=\"headerlink\" title=\"系统技巧\"></a>系统技巧</h2><h3 id=\"横向滑动技巧\"><a href=\"#横向滑动技巧\" class=\"headerlink\" title=\"横向滑动技巧\"></a>横向滑动技巧</h3><ul>\n<li>shift+鼠标滚动</li>\n</ul>\n"},{"title":"上传图书到kindle","date":"2022-02-17T08:28:59.000Z","_content":"\n### 配置以及获取相关信息\n* 登录[该页面](https://www.amazon.cn/gp/digital/fiona/manage?ref_=hp_ss_qs_v3_dv_dc#/home/settings/payment)，然后在“个人文档设置”部分，增加自己使用发送电子书的邮箱到“”已认可的发件人电子邮箱列表”，该部分邮箱即为下文脚本中的发送邮箱\n* 获取要发送到的邮箱，该邮箱跟上面的添加邮箱在同一个页面上，在“〖发送至Kindle〗电子邮箱”部分，该部分邮箱即为下文脚本中的接收邮箱\n* 到发送邮箱里面开启SMTP服务器，此处我使用的是163，该部分请自行百度\n\n\n\n### 示例脚本\n```\n# -*- coding: utf-8 -*-\nimport os\nimport smtplib  # 导入PyEmail\n# 发送字符串的邮件\nfrom email import encoders\nfrom email.mime.application import MIMEApplication\nfrom email.mime.base import MIMEBase\nfrom email.mime.text import MIMEText\n# 需要 MIMEMultipart 类\nfrom email.mime.multipart import MIMEMultipart\n\nSENDER = \"fasongyouxiang@163.com\" # 发送邮箱\nRECEIVE = \"jiehsouyouxiang1@kindle.cn;jiehsouyouxiang2@kindle.cn\" # 接收邮箱，多个用分号隔开\nPASSWORD = \"youxiangmima\" #邮箱密码\nSERVER = \"smtp.163.com\" # smtp服务地址\nSERVER_PORT = 994 # smtp服务器端口\n\n# 邮件构建\n\ndef send(file_path):\n\n    print(\"开始发送：\", file_path)\n    message = MIMEMultipart()\n    message['From'] = SENDER  # 发送方\n    message['To'] = RECEIVE  # 接收方\n\n    # 构建邮件附件\n    part = MIMEApplication(open(file_path, 'rb').read())\n    part.add_header('Content-Disposition', 'attachment', filename=get_last_filename(file_path))\n    message.attach(part)\n\n    smtp = smtplib.SMTP_SSL(SERVER, SERVER_PORT)  # 实例化smtp服务器\n    smtp.login(SENDER, PASSWORD)  # 发件人登录\n    smtp.sendmail(SENDER, [RECEIVE], message.as_string())  # as_string 对 message 的消息进行了封装\n    smtp.close()\n    print(\"发送邮件成功：\", file_path)\n\ndef get_last_filename(filename):\n    return filename[filename.rindex('/') + 1: len(filename)]\n\ndef send_to_kindle():\n    dir = os.walk(r\"./ebook\")\n    for path, dir_list, file_list in dir:\n        for file_name in file_list:\n            if \"DS_Store\" not in file_name:\n                send(\"./ebook/\" + file_name)\n\n\nif __name__=='__main__':\n    send_to_kindle()\n```\n","source":"_posts/toolScript/上传图书到kindle.md","raw":"---\ntitle: 上传图书到kindle\ndate: 2022-02-17 16:28:59\ntags: 脚本工具\ncategories:\n- [工具脚本]\n---\n\n### 配置以及获取相关信息\n* 登录[该页面](https://www.amazon.cn/gp/digital/fiona/manage?ref_=hp_ss_qs_v3_dv_dc#/home/settings/payment)，然后在“个人文档设置”部分，增加自己使用发送电子书的邮箱到“”已认可的发件人电子邮箱列表”，该部分邮箱即为下文脚本中的发送邮箱\n* 获取要发送到的邮箱，该邮箱跟上面的添加邮箱在同一个页面上，在“〖发送至Kindle〗电子邮箱”部分，该部分邮箱即为下文脚本中的接收邮箱\n* 到发送邮箱里面开启SMTP服务器，此处我使用的是163，该部分请自行百度\n\n\n\n### 示例脚本\n```\n# -*- coding: utf-8 -*-\nimport os\nimport smtplib  # 导入PyEmail\n# 发送字符串的邮件\nfrom email import encoders\nfrom email.mime.application import MIMEApplication\nfrom email.mime.base import MIMEBase\nfrom email.mime.text import MIMEText\n# 需要 MIMEMultipart 类\nfrom email.mime.multipart import MIMEMultipart\n\nSENDER = \"fasongyouxiang@163.com\" # 发送邮箱\nRECEIVE = \"jiehsouyouxiang1@kindle.cn;jiehsouyouxiang2@kindle.cn\" # 接收邮箱，多个用分号隔开\nPASSWORD = \"youxiangmima\" #邮箱密码\nSERVER = \"smtp.163.com\" # smtp服务地址\nSERVER_PORT = 994 # smtp服务器端口\n\n# 邮件构建\n\ndef send(file_path):\n\n    print(\"开始发送：\", file_path)\n    message = MIMEMultipart()\n    message['From'] = SENDER  # 发送方\n    message['To'] = RECEIVE  # 接收方\n\n    # 构建邮件附件\n    part = MIMEApplication(open(file_path, 'rb').read())\n    part.add_header('Content-Disposition', 'attachment', filename=get_last_filename(file_path))\n    message.attach(part)\n\n    smtp = smtplib.SMTP_SSL(SERVER, SERVER_PORT)  # 实例化smtp服务器\n    smtp.login(SENDER, PASSWORD)  # 发件人登录\n    smtp.sendmail(SENDER, [RECEIVE], message.as_string())  # as_string 对 message 的消息进行了封装\n    smtp.close()\n    print(\"发送邮件成功：\", file_path)\n\ndef get_last_filename(filename):\n    return filename[filename.rindex('/') + 1: len(filename)]\n\ndef send_to_kindle():\n    dir = os.walk(r\"./ebook\")\n    for path, dir_list, file_list in dir:\n        for file_name in file_list:\n            if \"DS_Store\" not in file_name:\n                send(\"./ebook/\" + file_name)\n\n\nif __name__=='__main__':\n    send_to_kindle()\n```\n","slug":"toolScript/上传图书到kindle","published":1,"updated":"2022-04-12T09:00:46.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bq002vwgtth7tue0c2","content":"<h3 id=\"配置以及获取相关信息\"><a href=\"#配置以及获取相关信息\" class=\"headerlink\" title=\"配置以及获取相关信息\"></a>配置以及获取相关信息</h3><ul>\n<li>登录<a href=\"https://www.amazon.cn/gp/digital/fiona/manage?ref_=hp_ss_qs_v3_dv_dc#/home/settings/payment\">该页面</a>，然后在“个人文档设置”部分，增加自己使用发送电子书的邮箱到“”已认可的发件人电子邮箱列表”，该部分邮箱即为下文脚本中的发送邮箱</li>\n<li>获取要发送到的邮箱，该邮箱跟上面的添加邮箱在同一个页面上，在“〖发送至Kindle〗电子邮箱”部分，该部分邮箱即为下文脚本中的接收邮箱</li>\n<li>到发送邮箱里面开启SMTP服务器，此处我使用的是163，该部分请自行百度</li>\n</ul>\n<h3 id=\"示例脚本\"><a href=\"#示例脚本\" class=\"headerlink\" title=\"示例脚本\"></a>示例脚本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import os</span><br><span class=\"line\">import smtplib  # 导入PyEmail</span><br><span class=\"line\"># 发送字符串的邮件</span><br><span class=\"line\">from email import encoders</span><br><span class=\"line\">from email.mime.application import MIMEApplication</span><br><span class=\"line\">from email.mime.base import MIMEBase</span><br><span class=\"line\">from email.mime.text import MIMEText</span><br><span class=\"line\"># 需要 MIMEMultipart 类</span><br><span class=\"line\">from email.mime.multipart import MIMEMultipart</span><br><span class=\"line\"></span><br><span class=\"line\">SENDER = &quot;fasongyouxiang@163.com&quot; # 发送邮箱</span><br><span class=\"line\">RECEIVE = &quot;jiehsouyouxiang1@kindle.cn;jiehsouyouxiang2@kindle.cn&quot; # 接收邮箱，多个用分号隔开</span><br><span class=\"line\">PASSWORD = &quot;youxiangmima&quot; #邮箱密码</span><br><span class=\"line\">SERVER = &quot;smtp.163.com&quot; # smtp服务地址</span><br><span class=\"line\">SERVER_PORT = 994 # smtp服务器端口</span><br><span class=\"line\"></span><br><span class=\"line\"># 邮件构建</span><br><span class=\"line\"></span><br><span class=\"line\">def send(file_path):</span><br><span class=\"line\"></span><br><span class=\"line\">    print(&quot;开始发送：&quot;, file_path)</span><br><span class=\"line\">    message = MIMEMultipart()</span><br><span class=\"line\">    message[&#x27;From&#x27;] = SENDER  # 发送方</span><br><span class=\"line\">    message[&#x27;To&#x27;] = RECEIVE  # 接收方</span><br><span class=\"line\"></span><br><span class=\"line\">    # 构建邮件附件</span><br><span class=\"line\">    part = MIMEApplication(open(file_path, &#x27;rb&#x27;).read())</span><br><span class=\"line\">    part.add_header(&#x27;Content-Disposition&#x27;, &#x27;attachment&#x27;, filename=get_last_filename(file_path))</span><br><span class=\"line\">    message.attach(part)</span><br><span class=\"line\"></span><br><span class=\"line\">    smtp = smtplib.SMTP_SSL(SERVER, SERVER_PORT)  # 实例化smtp服务器</span><br><span class=\"line\">    smtp.login(SENDER, PASSWORD)  # 发件人登录</span><br><span class=\"line\">    smtp.sendmail(SENDER, [RECEIVE], message.as_string())  # as_string 对 message 的消息进行了封装</span><br><span class=\"line\">    smtp.close()</span><br><span class=\"line\">    print(&quot;发送邮件成功：&quot;, file_path)</span><br><span class=\"line\"></span><br><span class=\"line\">def get_last_filename(filename):</span><br><span class=\"line\">    return filename[filename.rindex(&#x27;/&#x27;) + 1: len(filename)]</span><br><span class=\"line\"></span><br><span class=\"line\">def send_to_kindle():</span><br><span class=\"line\">    dir = os.walk(r&quot;./ebook&quot;)</span><br><span class=\"line\">    for path, dir_list, file_list in dir:</span><br><span class=\"line\">        for file_name in file_list:</span><br><span class=\"line\">            if &quot;DS_Store&quot; not in file_name:</span><br><span class=\"line\">                send(&quot;./ebook/&quot; + file_name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__==&#x27;__main__&#x27;:</span><br><span class=\"line\">    send_to_kindle()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"配置以及获取相关信息\"><a href=\"#配置以及获取相关信息\" class=\"headerlink\" title=\"配置以及获取相关信息\"></a>配置以及获取相关信息</h3><ul>\n<li>登录<a href=\"https://www.amazon.cn/gp/digital/fiona/manage?ref_=hp_ss_qs_v3_dv_dc#/home/settings/payment\">该页面</a>，然后在“个人文档设置”部分，增加自己使用发送电子书的邮箱到“”已认可的发件人电子邮箱列表”，该部分邮箱即为下文脚本中的发送邮箱</li>\n<li>获取要发送到的邮箱，该邮箱跟上面的添加邮箱在同一个页面上，在“〖发送至Kindle〗电子邮箱”部分，该部分邮箱即为下文脚本中的接收邮箱</li>\n<li>到发送邮箱里面开启SMTP服务器，此处我使用的是163，该部分请自行百度</li>\n</ul>\n<h3 id=\"示例脚本\"><a href=\"#示例脚本\" class=\"headerlink\" title=\"示例脚本\"></a>示例脚本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\">import os</span><br><span class=\"line\">import smtplib  # 导入PyEmail</span><br><span class=\"line\"># 发送字符串的邮件</span><br><span class=\"line\">from email import encoders</span><br><span class=\"line\">from email.mime.application import MIMEApplication</span><br><span class=\"line\">from email.mime.base import MIMEBase</span><br><span class=\"line\">from email.mime.text import MIMEText</span><br><span class=\"line\"># 需要 MIMEMultipart 类</span><br><span class=\"line\">from email.mime.multipart import MIMEMultipart</span><br><span class=\"line\"></span><br><span class=\"line\">SENDER = &quot;fasongyouxiang@163.com&quot; # 发送邮箱</span><br><span class=\"line\">RECEIVE = &quot;jiehsouyouxiang1@kindle.cn;jiehsouyouxiang2@kindle.cn&quot; # 接收邮箱，多个用分号隔开</span><br><span class=\"line\">PASSWORD = &quot;youxiangmima&quot; #邮箱密码</span><br><span class=\"line\">SERVER = &quot;smtp.163.com&quot; # smtp服务地址</span><br><span class=\"line\">SERVER_PORT = 994 # smtp服务器端口</span><br><span class=\"line\"></span><br><span class=\"line\"># 邮件构建</span><br><span class=\"line\"></span><br><span class=\"line\">def send(file_path):</span><br><span class=\"line\"></span><br><span class=\"line\">    print(&quot;开始发送：&quot;, file_path)</span><br><span class=\"line\">    message = MIMEMultipart()</span><br><span class=\"line\">    message[&#x27;From&#x27;] = SENDER  # 发送方</span><br><span class=\"line\">    message[&#x27;To&#x27;] = RECEIVE  # 接收方</span><br><span class=\"line\"></span><br><span class=\"line\">    # 构建邮件附件</span><br><span class=\"line\">    part = MIMEApplication(open(file_path, &#x27;rb&#x27;).read())</span><br><span class=\"line\">    part.add_header(&#x27;Content-Disposition&#x27;, &#x27;attachment&#x27;, filename=get_last_filename(file_path))</span><br><span class=\"line\">    message.attach(part)</span><br><span class=\"line\"></span><br><span class=\"line\">    smtp = smtplib.SMTP_SSL(SERVER, SERVER_PORT)  # 实例化smtp服务器</span><br><span class=\"line\">    smtp.login(SENDER, PASSWORD)  # 发件人登录</span><br><span class=\"line\">    smtp.sendmail(SENDER, [RECEIVE], message.as_string())  # as_string 对 message 的消息进行了封装</span><br><span class=\"line\">    smtp.close()</span><br><span class=\"line\">    print(&quot;发送邮件成功：&quot;, file_path)</span><br><span class=\"line\"></span><br><span class=\"line\">def get_last_filename(filename):</span><br><span class=\"line\">    return filename[filename.rindex(&#x27;/&#x27;) + 1: len(filename)]</span><br><span class=\"line\"></span><br><span class=\"line\">def send_to_kindle():</span><br><span class=\"line\">    dir = os.walk(r&quot;./ebook&quot;)</span><br><span class=\"line\">    for path, dir_list, file_list in dir:</span><br><span class=\"line\">        for file_name in file_list:</span><br><span class=\"line\">            if &quot;DS_Store&quot; not in file_name:</span><br><span class=\"line\">                send(&quot;./ebook/&quot; + file_name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__==&#x27;__main__&#x27;:</span><br><span class=\"line\">    send_to_kindle()</span><br></pre></td></tr></table></figure>\n"},{"title":"IO流","date":"2021-11-29T07:35:40.000Z","_content":"\n## 参考资料\n* [资料1](https://cloud.tencent.com/developer/article/1461049)\n* [资料2](https://www.kancloud.cn/imnotdown1019/java_core_full/1012272)\n\n## 概念解释\n* IO模型、IO方法：即实现IO所采用的方式，BIO、NIO、AIO是Java官方支持的三种方式，比如读写文件、进程间交互等有IO操作的都可以使用官方支持的三种方式\n\n## IO流特点\n* 最基础的是字节\n* 单向\n* 顺序读写\n* 由InputStream、Writer、OutputStream、Reader四个基类为基础组成，Writer实际上是自带解码的OutputStream，Reader实际上是自带编码的OutputStream\n\n## IO流分类\n### 按数据流向分（以内存为基准）：\n  * 输入流：InputStream、Reader，即从其他位置输入到内存\n  * 输出流：OutputStream、Writer，即从内存输出给其他设备\n\n### 按数据类型分：\n  * 字节流\n  * 字符流\n\n### 按角色分：\n  * 节点流：可以从/向一个IO设备读/写数据的流，也称为低级流、主要流\n  * 高级流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写\n\n### 按功能分：\n  * 缓冲流：对应Buffer开头的那部分缓冲流泪，作用是增加一层缓冲，提高读写速度\n  * 转换流：对应InputStreamReader、OutputStreamWriter，作用是对字符和字节进行转换\n  * 序列化流：对应ObjectOutputStream、ObjectInputStream，作用是将一个对象序列化成文件，将序列化文件反序列化成对象\n  * 打印流：对应PrintStream、PrintWriter，作用是打印各种东西\n\n\n## IO流现有类\n### 按数据类型分：\n* 字节流：可用于任何类型的数据\n  * InputStream（从其他位置输入内存）\n    * FileInputStream\n    * FilterInputStram\n      * BufferedInputStream\n      * DataInputStream\n      * PushbackInputStream\n    * ObjectInputStream\n    * PipedInputStream\n    * ByteArrayInputStream\n  * OutputStream（从内存输出到其他位置）\n    * FileOutputStream\n    * FilterOutputStream\n      * BufferedOutputSteam\n      * DataOutputStream\n      * PrintStream\n    * ObjectOutputStream\n    * PipedOutputStream\n    * ByteArrayOutputStream\n\n\n* 字符流：只能处理字符或字符串\n  * Writer（从内存中把数据写入到其他位置）\n    * BufferedWriter\n    * StringWriter\n    * PipedWriter\n    * CharArrayWriter\n    * FilterWriter\n    * OutputStreamWriter\n      * FileWriter\n    * PrintWriter\n  * Reader（从其他位置把数据读到内存）\n    * BufferedReader\n    * StringReader\n    * PipedReader\n    * CharArrayReader\n    * FilterReader\n      * PushbackReader\n    * InputStreamReader\n      * FileReader\n\n### 按功能分：\n* 处理流：\n  * 缓冲操作类\n    * BufferedInputStream\n    * BufferedOutputSteam\n    * BufferedWriter\n    * BufferedReader\n  * 基本数据类型操作类\n    * DataInputStream\n    * DataOutputStream\n  * 对象序列化操作类\n    * ObjectInputStream\n    * ObjectOutputStream\n  * 转换操作类\n    * InputStreamReader\n    * OutputStreamWriter\n  * 打印操作类\n    * PrintStream\n    * PrintWriter\n\n* 节点流\n  * 文件操作类\n    * FileInputStream\n    * FileOutputStream\n    * FileReader\n    * FileWriter\n  * 管道操作类\n    * PipedInputStream\n    * PipedOutputStream\n    * PipedReader\n    * PipedWriter\n  * 数组操作类\n    * ByteArrayInputStream\n    * ByteArrayOutputStream\n    * CharArrayReader\n    * CharArrayWriter\n\n## Java支持的IO模型（即Java官方支持的IO方法）\n### BIO（Blocking I/O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\n* 使用场景：适合连接数较少且固定架构的情况\n* 特点：编程简单，不需要过多考虑系统过载、限流等问题；并发能力差，资源占用高，不能承受十万甚至百万级连接\n\n### NIO（Non-Blocking/New I/O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\n* 使用场景：适合高负载、高并发场景，适合连接数目多且连接比较短的情况\n* 实现NIO的三部分：\n  * 缓冲区Buffer：NIO基于块进行数据处理，这些数据块通过Buffer的实现类来进行读取，Buffer（接口）实现类有ByteBuffer、IntBuffer等\n  * 通道Channel：通过Channel实现数据的读写，通道是全双工，可同时读写，channel（接口）实现类有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等\n  * 多路复用器Selector：轮询注册在其上的channel，如果某个channel发出读写请求并处于就绪状态，会被其轮询到，然后通过selectionKey可以获取到就绪的channel集合，然后进行后续IO操作，\n    * Selector只能管理非阻塞channel，所以阻塞的FileChannel不能被其管理\n    * 监听事件注册：serviceSocketChannel.register(selector, SelectionKey.OP_ACCEPT)\n    * 监听事件：\n      * OP_ACCEPT：接受就绪，ServiceSocketChannel使用\n      * OP_READ：读取就绪，SocketChannel使用\n      * OP_WRITE：写入就绪，SocketChannel使用\n      * OP_CONNECT：连接就绪，SocketChannel使用\n\n### AIO（Asynchronous I/O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\n* 使用场景：适合高负载、高并发场景，适用于连接数多且时间长的场景\n* 特点：基于事件和回调机制实现；不会阻塞，当后台处理完成时，系统会通知相应线程继续操作\n\n### IO模型总结\n* 同步阻塞：一个线程，顺序执行\n* 同步非阻塞：一个线程，顺序执行，遇到暂时没执行结果的行，先跳过执行后面的，然后通过某种方式比如轮询来查看无执行结果行的结果\n* 异步阻塞：一个线程中异步执行多个任务，其中一个任务执行时，其他任务需要阻塞等待\n* 异步非阻塞：有多个线程执行任务，所有的线程互不干预，各自干各自的活\n\n## 相关问题\n### Files常用方法\n* exists()：检测文件路径是否存在\n* createFile()：创建文件\n* createDirectory()：创建目录\n* delete()：删除文件或目录\n* copy()：复制文件\n* move()：移动文件\n* size()：查看文件个数\n* read()：读取文件\n* write()：写入文件\n","source":"_posts/Q&A/Java/IO流.md","raw":"---\ntitle: IO流\ndate: 2021-11-29 15:35:40\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## 参考资料\n* [资料1](https://cloud.tencent.com/developer/article/1461049)\n* [资料2](https://www.kancloud.cn/imnotdown1019/java_core_full/1012272)\n\n## 概念解释\n* IO模型、IO方法：即实现IO所采用的方式，BIO、NIO、AIO是Java官方支持的三种方式，比如读写文件、进程间交互等有IO操作的都可以使用官方支持的三种方式\n\n## IO流特点\n* 最基础的是字节\n* 单向\n* 顺序读写\n* 由InputStream、Writer、OutputStream、Reader四个基类为基础组成，Writer实际上是自带解码的OutputStream，Reader实际上是自带编码的OutputStream\n\n## IO流分类\n### 按数据流向分（以内存为基准）：\n  * 输入流：InputStream、Reader，即从其他位置输入到内存\n  * 输出流：OutputStream、Writer，即从内存输出给其他设备\n\n### 按数据类型分：\n  * 字节流\n  * 字符流\n\n### 按角色分：\n  * 节点流：可以从/向一个IO设备读/写数据的流，也称为低级流、主要流\n  * 高级流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写\n\n### 按功能分：\n  * 缓冲流：对应Buffer开头的那部分缓冲流泪，作用是增加一层缓冲，提高读写速度\n  * 转换流：对应InputStreamReader、OutputStreamWriter，作用是对字符和字节进行转换\n  * 序列化流：对应ObjectOutputStream、ObjectInputStream，作用是将一个对象序列化成文件，将序列化文件反序列化成对象\n  * 打印流：对应PrintStream、PrintWriter，作用是打印各种东西\n\n\n## IO流现有类\n### 按数据类型分：\n* 字节流：可用于任何类型的数据\n  * InputStream（从其他位置输入内存）\n    * FileInputStream\n    * FilterInputStram\n      * BufferedInputStream\n      * DataInputStream\n      * PushbackInputStream\n    * ObjectInputStream\n    * PipedInputStream\n    * ByteArrayInputStream\n  * OutputStream（从内存输出到其他位置）\n    * FileOutputStream\n    * FilterOutputStream\n      * BufferedOutputSteam\n      * DataOutputStream\n      * PrintStream\n    * ObjectOutputStream\n    * PipedOutputStream\n    * ByteArrayOutputStream\n\n\n* 字符流：只能处理字符或字符串\n  * Writer（从内存中把数据写入到其他位置）\n    * BufferedWriter\n    * StringWriter\n    * PipedWriter\n    * CharArrayWriter\n    * FilterWriter\n    * OutputStreamWriter\n      * FileWriter\n    * PrintWriter\n  * Reader（从其他位置把数据读到内存）\n    * BufferedReader\n    * StringReader\n    * PipedReader\n    * CharArrayReader\n    * FilterReader\n      * PushbackReader\n    * InputStreamReader\n      * FileReader\n\n### 按功能分：\n* 处理流：\n  * 缓冲操作类\n    * BufferedInputStream\n    * BufferedOutputSteam\n    * BufferedWriter\n    * BufferedReader\n  * 基本数据类型操作类\n    * DataInputStream\n    * DataOutputStream\n  * 对象序列化操作类\n    * ObjectInputStream\n    * ObjectOutputStream\n  * 转换操作类\n    * InputStreamReader\n    * OutputStreamWriter\n  * 打印操作类\n    * PrintStream\n    * PrintWriter\n\n* 节点流\n  * 文件操作类\n    * FileInputStream\n    * FileOutputStream\n    * FileReader\n    * FileWriter\n  * 管道操作类\n    * PipedInputStream\n    * PipedOutputStream\n    * PipedReader\n    * PipedWriter\n  * 数组操作类\n    * ByteArrayInputStream\n    * ByteArrayOutputStream\n    * CharArrayReader\n    * CharArrayWriter\n\n## Java支持的IO模型（即Java官方支持的IO方法）\n### BIO（Blocking I/O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\n* 使用场景：适合连接数较少且固定架构的情况\n* 特点：编程简单，不需要过多考虑系统过载、限流等问题；并发能力差，资源占用高，不能承受十万甚至百万级连接\n\n### NIO（Non-Blocking/New I/O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\n* 使用场景：适合高负载、高并发场景，适合连接数目多且连接比较短的情况\n* 实现NIO的三部分：\n  * 缓冲区Buffer：NIO基于块进行数据处理，这些数据块通过Buffer的实现类来进行读取，Buffer（接口）实现类有ByteBuffer、IntBuffer等\n  * 通道Channel：通过Channel实现数据的读写，通道是全双工，可同时读写，channel（接口）实现类有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等\n  * 多路复用器Selector：轮询注册在其上的channel，如果某个channel发出读写请求并处于就绪状态，会被其轮询到，然后通过selectionKey可以获取到就绪的channel集合，然后进行后续IO操作，\n    * Selector只能管理非阻塞channel，所以阻塞的FileChannel不能被其管理\n    * 监听事件注册：serviceSocketChannel.register(selector, SelectionKey.OP_ACCEPT)\n    * 监听事件：\n      * OP_ACCEPT：接受就绪，ServiceSocketChannel使用\n      * OP_READ：读取就绪，SocketChannel使用\n      * OP_WRITE：写入就绪，SocketChannel使用\n      * OP_CONNECT：连接就绪，SocketChannel使用\n\n### AIO（Asynchronous I/O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\n* 使用场景：适合高负载、高并发场景，适用于连接数多且时间长的场景\n* 特点：基于事件和回调机制实现；不会阻塞，当后台处理完成时，系统会通知相应线程继续操作\n\n### IO模型总结\n* 同步阻塞：一个线程，顺序执行\n* 同步非阻塞：一个线程，顺序执行，遇到暂时没执行结果的行，先跳过执行后面的，然后通过某种方式比如轮询来查看无执行结果行的结果\n* 异步阻塞：一个线程中异步执行多个任务，其中一个任务执行时，其他任务需要阻塞等待\n* 异步非阻塞：有多个线程执行任务，所有的线程互不干预，各自干各自的活\n\n## 相关问题\n### Files常用方法\n* exists()：检测文件路径是否存在\n* createFile()：创建文件\n* createDirectory()：创建目录\n* delete()：删除文件或目录\n* copy()：复制文件\n* move()：移动文件\n* size()：查看文件个数\n* read()：读取文件\n* write()：写入文件\n","slug":"Q&A/Java/IO流","published":1,"updated":"2022-04-12T09:00:46.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0br002ywgtth009fgwn","content":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1461049\">资料1</a></li>\n<li><a href=\"https://www.kancloud.cn/imnotdown1019/java_core_full/1012272\">资料2</a></li>\n</ul>\n<h2 id=\"概念解释\"><a href=\"#概念解释\" class=\"headerlink\" title=\"概念解释\"></a>概念解释</h2><ul>\n<li>IO模型、IO方法：即实现IO所采用的方式，BIO、NIO、AIO是Java官方支持的三种方式，比如读写文件、进程间交互等有IO操作的都可以使用官方支持的三种方式</li>\n</ul>\n<h2 id=\"IO流特点\"><a href=\"#IO流特点\" class=\"headerlink\" title=\"IO流特点\"></a>IO流特点</h2><ul>\n<li>最基础的是字节</li>\n<li>单向</li>\n<li>顺序读写</li>\n<li>由InputStream、Writer、OutputStream、Reader四个基类为基础组成，Writer实际上是自带解码的OutputStream，Reader实际上是自带编码的OutputStream</li>\n</ul>\n<h2 id=\"IO流分类\"><a href=\"#IO流分类\" class=\"headerlink\" title=\"IO流分类\"></a>IO流分类</h2><h3 id=\"按数据流向分（以内存为基准）：\"><a href=\"#按数据流向分（以内存为基准）：\" class=\"headerlink\" title=\"按数据流向分（以内存为基准）：\"></a>按数据流向分（以内存为基准）：</h3><ul>\n<li>输入流：InputStream、Reader，即从其他位置输入到内存</li>\n<li>输出流：OutputStream、Writer，即从内存输出给其他设备</li>\n</ul>\n<h3 id=\"按数据类型分：\"><a href=\"#按数据类型分：\" class=\"headerlink\" title=\"按数据类型分：\"></a>按数据类型分：</h3><ul>\n<li>字节流</li>\n<li>字符流</li>\n</ul>\n<h3 id=\"按角色分：\"><a href=\"#按角色分：\" class=\"headerlink\" title=\"按角色分：\"></a>按角色分：</h3><ul>\n<li>节点流：可以从/向一个IO设备读/写数据的流，也称为低级流、主要流</li>\n<li>高级流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写</li>\n</ul>\n<h3 id=\"按功能分：\"><a href=\"#按功能分：\" class=\"headerlink\" title=\"按功能分：\"></a>按功能分：</h3><ul>\n<li>缓冲流：对应Buffer开头的那部分缓冲流泪，作用是增加一层缓冲，提高读写速度</li>\n<li>转换流：对应InputStreamReader、OutputStreamWriter，作用是对字符和字节进行转换</li>\n<li>序列化流：对应ObjectOutputStream、ObjectInputStream，作用是将一个对象序列化成文件，将序列化文件反序列化成对象</li>\n<li>打印流：对应PrintStream、PrintWriter，作用是打印各种东西</li>\n</ul>\n<h2 id=\"IO流现有类\"><a href=\"#IO流现有类\" class=\"headerlink\" title=\"IO流现有类\"></a>IO流现有类</h2><h3 id=\"按数据类型分：-1\"><a href=\"#按数据类型分：-1\" class=\"headerlink\" title=\"按数据类型分：\"></a>按数据类型分：</h3><ul>\n<li>字节流：可用于任何类型的数据<ul>\n<li>InputStream（从其他位置输入内存）<ul>\n<li>FileInputStream</li>\n<li>FilterInputStram<ul>\n<li>BufferedInputStream</li>\n<li>DataInputStream</li>\n<li>PushbackInputStream</li>\n</ul>\n</li>\n<li>ObjectInputStream</li>\n<li>PipedInputStream</li>\n<li>ByteArrayInputStream</li>\n</ul>\n</li>\n<li>OutputStream（从内存输出到其他位置）<ul>\n<li>FileOutputStream</li>\n<li>FilterOutputStream<ul>\n<li>BufferedOutputSteam</li>\n<li>DataOutputStream</li>\n<li>PrintStream</li>\n</ul>\n</li>\n<li>ObjectOutputStream</li>\n<li>PipedOutputStream</li>\n<li>ByteArrayOutputStream</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>字符流：只能处理字符或字符串<ul>\n<li>Writer（从内存中把数据写入到其他位置）<ul>\n<li>BufferedWriter</li>\n<li>StringWriter</li>\n<li>PipedWriter</li>\n<li>CharArrayWriter</li>\n<li>FilterWriter</li>\n<li>OutputStreamWriter<ul>\n<li>FileWriter</li>\n</ul>\n</li>\n<li>PrintWriter</li>\n</ul>\n</li>\n<li>Reader（从其他位置把数据读到内存）<ul>\n<li>BufferedReader</li>\n<li>StringReader</li>\n<li>PipedReader</li>\n<li>CharArrayReader</li>\n<li>FilterReader<ul>\n<li>PushbackReader</li>\n</ul>\n</li>\n<li>InputStreamReader<ul>\n<li>FileReader</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"按功能分：-1\"><a href=\"#按功能分：-1\" class=\"headerlink\" title=\"按功能分：\"></a>按功能分：</h3><ul>\n<li><p>处理流：</p>\n<ul>\n<li>缓冲操作类<ul>\n<li>BufferedInputStream</li>\n<li>BufferedOutputSteam</li>\n<li>BufferedWriter</li>\n<li>BufferedReader</li>\n</ul>\n</li>\n<li>基本数据类型操作类<ul>\n<li>DataInputStream</li>\n<li>DataOutputStream</li>\n</ul>\n</li>\n<li>对象序列化操作类<ul>\n<li>ObjectInputStream</li>\n<li>ObjectOutputStream</li>\n</ul>\n</li>\n<li>转换操作类<ul>\n<li>InputStreamReader</li>\n<li>OutputStreamWriter</li>\n</ul>\n</li>\n<li>打印操作类<ul>\n<li>PrintStream</li>\n<li>PrintWriter</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>节点流</p>\n<ul>\n<li>文件操作类<ul>\n<li>FileInputStream</li>\n<li>FileOutputStream</li>\n<li>FileReader</li>\n<li>FileWriter</li>\n</ul>\n</li>\n<li>管道操作类<ul>\n<li>PipedInputStream</li>\n<li>PipedOutputStream</li>\n<li>PipedReader</li>\n<li>PipedWriter</li>\n</ul>\n</li>\n<li>数组操作类<ul>\n<li>ByteArrayInputStream</li>\n<li>ByteArrayOutputStream</li>\n<li>CharArrayReader</li>\n<li>CharArrayWriter</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java支持的IO模型（即Java官方支持的IO方法）\"><a href=\"#Java支持的IO模型（即Java官方支持的IO方法）\" class=\"headerlink\" title=\"Java支持的IO模型（即Java官方支持的IO方法）\"></a>Java支持的IO模型（即Java官方支持的IO方法）</h2><h3 id=\"BIO（Blocking-I-O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\"><a href=\"#BIO（Blocking-I-O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\" class=\"headerlink\" title=\"BIO（Blocking I/O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\"></a>BIO（Blocking I/O）：同步且阻塞IO模式，同步且阻塞的实现IO处理</h3><ul>\n<li>使用场景：适合连接数较少且固定架构的情况</li>\n<li>特点：编程简单，不需要过多考虑系统过载、限流等问题；并发能力差，资源占用高，不能承受十万甚至百万级连接</li>\n</ul>\n<h3 id=\"NIO（Non-Blocking-New-I-O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\"><a href=\"#NIO（Non-Blocking-New-I-O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\" class=\"headerlink\" title=\"NIO（Non-Blocking/New I/O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\"></a>NIO（Non-Blocking/New I/O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理</h3><ul>\n<li>使用场景：适合高负载、高并发场景，适合连接数目多且连接比较短的情况</li>\n<li>实现NIO的三部分：<ul>\n<li>缓冲区Buffer：NIO基于块进行数据处理，这些数据块通过Buffer的实现类来进行读取，Buffer（接口）实现类有ByteBuffer、IntBuffer等</li>\n<li>通道Channel：通过Channel实现数据的读写，通道是全双工，可同时读写，channel（接口）实现类有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等</li>\n<li>多路复用器Selector：轮询注册在其上的channel，如果某个channel发出读写请求并处于就绪状态，会被其轮询到，然后通过selectionKey可以获取到就绪的channel集合，然后进行后续IO操作，<ul>\n<li>Selector只能管理非阻塞channel，所以阻塞的FileChannel不能被其管理</li>\n<li>监听事件注册：serviceSocketChannel.register(selector, SelectionKey.OP_ACCEPT)</li>\n<li>监听事件：<ul>\n<li>OP_ACCEPT：接受就绪，ServiceSocketChannel使用</li>\n<li>OP_READ：读取就绪，SocketChannel使用</li>\n<li>OP_WRITE：写入就绪，SocketChannel使用</li>\n<li>OP_CONNECT：连接就绪，SocketChannel使用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AIO（Asynchronous-I-O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\"><a href=\"#AIO（Asynchronous-I-O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\" class=\"headerlink\" title=\"AIO（Asynchronous I/O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\"></a>AIO（Asynchronous I/O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理</h3><ul>\n<li>使用场景：适合高负载、高并发场景，适用于连接数多且时间长的场景</li>\n<li>特点：基于事件和回调机制实现；不会阻塞，当后台处理完成时，系统会通知相应线程继续操作</li>\n</ul>\n<h3 id=\"IO模型总结\"><a href=\"#IO模型总结\" class=\"headerlink\" title=\"IO模型总结\"></a>IO模型总结</h3><ul>\n<li>同步阻塞：一个线程，顺序执行</li>\n<li>同步非阻塞：一个线程，顺序执行，遇到暂时没执行结果的行，先跳过执行后面的，然后通过某种方式比如轮询来查看无执行结果行的结果</li>\n<li>异步阻塞：一个线程中异步执行多个任务，其中一个任务执行时，其他任务需要阻塞等待</li>\n<li>异步非阻塞：有多个线程执行任务，所有的线程互不干预，各自干各自的活</li>\n</ul>\n<h2 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h2><h3 id=\"Files常用方法\"><a href=\"#Files常用方法\" class=\"headerlink\" title=\"Files常用方法\"></a>Files常用方法</h3><ul>\n<li>exists()：检测文件路径是否存在</li>\n<li>createFile()：创建文件</li>\n<li>createDirectory()：创建目录</li>\n<li>delete()：删除文件或目录</li>\n<li>copy()：复制文件</li>\n<li>move()：移动文件</li>\n<li>size()：查看文件个数</li>\n<li>read()：读取文件</li>\n<li>write()：写入文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1461049\">资料1</a></li>\n<li><a href=\"https://www.kancloud.cn/imnotdown1019/java_core_full/1012272\">资料2</a></li>\n</ul>\n<h2 id=\"概念解释\"><a href=\"#概念解释\" class=\"headerlink\" title=\"概念解释\"></a>概念解释</h2><ul>\n<li>IO模型、IO方法：即实现IO所采用的方式，BIO、NIO、AIO是Java官方支持的三种方式，比如读写文件、进程间交互等有IO操作的都可以使用官方支持的三种方式</li>\n</ul>\n<h2 id=\"IO流特点\"><a href=\"#IO流特点\" class=\"headerlink\" title=\"IO流特点\"></a>IO流特点</h2><ul>\n<li>最基础的是字节</li>\n<li>单向</li>\n<li>顺序读写</li>\n<li>由InputStream、Writer、OutputStream、Reader四个基类为基础组成，Writer实际上是自带解码的OutputStream，Reader实际上是自带编码的OutputStream</li>\n</ul>\n<h2 id=\"IO流分类\"><a href=\"#IO流分类\" class=\"headerlink\" title=\"IO流分类\"></a>IO流分类</h2><h3 id=\"按数据流向分（以内存为基准）：\"><a href=\"#按数据流向分（以内存为基准）：\" class=\"headerlink\" title=\"按数据流向分（以内存为基准）：\"></a>按数据流向分（以内存为基准）：</h3><ul>\n<li>输入流：InputStream、Reader，即从其他位置输入到内存</li>\n<li>输出流：OutputStream、Writer，即从内存输出给其他设备</li>\n</ul>\n<h3 id=\"按数据类型分：\"><a href=\"#按数据类型分：\" class=\"headerlink\" title=\"按数据类型分：\"></a>按数据类型分：</h3><ul>\n<li>字节流</li>\n<li>字符流</li>\n</ul>\n<h3 id=\"按角色分：\"><a href=\"#按角色分：\" class=\"headerlink\" title=\"按角色分：\"></a>按角色分：</h3><ul>\n<li>节点流：可以从/向一个IO设备读/写数据的流，也称为低级流、主要流</li>\n<li>高级流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写</li>\n</ul>\n<h3 id=\"按功能分：\"><a href=\"#按功能分：\" class=\"headerlink\" title=\"按功能分：\"></a>按功能分：</h3><ul>\n<li>缓冲流：对应Buffer开头的那部分缓冲流泪，作用是增加一层缓冲，提高读写速度</li>\n<li>转换流：对应InputStreamReader、OutputStreamWriter，作用是对字符和字节进行转换</li>\n<li>序列化流：对应ObjectOutputStream、ObjectInputStream，作用是将一个对象序列化成文件，将序列化文件反序列化成对象</li>\n<li>打印流：对应PrintStream、PrintWriter，作用是打印各种东西</li>\n</ul>\n<h2 id=\"IO流现有类\"><a href=\"#IO流现有类\" class=\"headerlink\" title=\"IO流现有类\"></a>IO流现有类</h2><h3 id=\"按数据类型分：-1\"><a href=\"#按数据类型分：-1\" class=\"headerlink\" title=\"按数据类型分：\"></a>按数据类型分：</h3><ul>\n<li>字节流：可用于任何类型的数据<ul>\n<li>InputStream（从其他位置输入内存）<ul>\n<li>FileInputStream</li>\n<li>FilterInputStram<ul>\n<li>BufferedInputStream</li>\n<li>DataInputStream</li>\n<li>PushbackInputStream</li>\n</ul>\n</li>\n<li>ObjectInputStream</li>\n<li>PipedInputStream</li>\n<li>ByteArrayInputStream</li>\n</ul>\n</li>\n<li>OutputStream（从内存输出到其他位置）<ul>\n<li>FileOutputStream</li>\n<li>FilterOutputStream<ul>\n<li>BufferedOutputSteam</li>\n<li>DataOutputStream</li>\n<li>PrintStream</li>\n</ul>\n</li>\n<li>ObjectOutputStream</li>\n<li>PipedOutputStream</li>\n<li>ByteArrayOutputStream</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>字符流：只能处理字符或字符串<ul>\n<li>Writer（从内存中把数据写入到其他位置）<ul>\n<li>BufferedWriter</li>\n<li>StringWriter</li>\n<li>PipedWriter</li>\n<li>CharArrayWriter</li>\n<li>FilterWriter</li>\n<li>OutputStreamWriter<ul>\n<li>FileWriter</li>\n</ul>\n</li>\n<li>PrintWriter</li>\n</ul>\n</li>\n<li>Reader（从其他位置把数据读到内存）<ul>\n<li>BufferedReader</li>\n<li>StringReader</li>\n<li>PipedReader</li>\n<li>CharArrayReader</li>\n<li>FilterReader<ul>\n<li>PushbackReader</li>\n</ul>\n</li>\n<li>InputStreamReader<ul>\n<li>FileReader</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"按功能分：-1\"><a href=\"#按功能分：-1\" class=\"headerlink\" title=\"按功能分：\"></a>按功能分：</h3><ul>\n<li><p>处理流：</p>\n<ul>\n<li>缓冲操作类<ul>\n<li>BufferedInputStream</li>\n<li>BufferedOutputSteam</li>\n<li>BufferedWriter</li>\n<li>BufferedReader</li>\n</ul>\n</li>\n<li>基本数据类型操作类<ul>\n<li>DataInputStream</li>\n<li>DataOutputStream</li>\n</ul>\n</li>\n<li>对象序列化操作类<ul>\n<li>ObjectInputStream</li>\n<li>ObjectOutputStream</li>\n</ul>\n</li>\n<li>转换操作类<ul>\n<li>InputStreamReader</li>\n<li>OutputStreamWriter</li>\n</ul>\n</li>\n<li>打印操作类<ul>\n<li>PrintStream</li>\n<li>PrintWriter</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>节点流</p>\n<ul>\n<li>文件操作类<ul>\n<li>FileInputStream</li>\n<li>FileOutputStream</li>\n<li>FileReader</li>\n<li>FileWriter</li>\n</ul>\n</li>\n<li>管道操作类<ul>\n<li>PipedInputStream</li>\n<li>PipedOutputStream</li>\n<li>PipedReader</li>\n<li>PipedWriter</li>\n</ul>\n</li>\n<li>数组操作类<ul>\n<li>ByteArrayInputStream</li>\n<li>ByteArrayOutputStream</li>\n<li>CharArrayReader</li>\n<li>CharArrayWriter</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java支持的IO模型（即Java官方支持的IO方法）\"><a href=\"#Java支持的IO模型（即Java官方支持的IO方法）\" class=\"headerlink\" title=\"Java支持的IO模型（即Java官方支持的IO方法）\"></a>Java支持的IO模型（即Java官方支持的IO方法）</h2><h3 id=\"BIO（Blocking-I-O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\"><a href=\"#BIO（Blocking-I-O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\" class=\"headerlink\" title=\"BIO（Blocking I/O）：同步且阻塞IO模式，同步且阻塞的实现IO处理\"></a>BIO（Blocking I/O）：同步且阻塞IO模式，同步且阻塞的实现IO处理</h3><ul>\n<li>使用场景：适合连接数较少且固定架构的情况</li>\n<li>特点：编程简单，不需要过多考虑系统过载、限流等问题；并发能力差，资源占用高，不能承受十万甚至百万级连接</li>\n</ul>\n<h3 id=\"NIO（Non-Blocking-New-I-O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\"><a href=\"#NIO（Non-Blocking-New-I-O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\" class=\"headerlink\" title=\"NIO（Non-Blocking/New I/O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理\"></a>NIO（Non-Blocking/New I/O）：同步非阻塞IO模型，client多个连接server开一个线程进行处理，客户端的请求会注册到多路复用器上，server会轮询多路复用器，发现请求后就进行处理</h3><ul>\n<li>使用场景：适合高负载、高并发场景，适合连接数目多且连接比较短的情况</li>\n<li>实现NIO的三部分：<ul>\n<li>缓冲区Buffer：NIO基于块进行数据处理，这些数据块通过Buffer的实现类来进行读取，Buffer（接口）实现类有ByteBuffer、IntBuffer等</li>\n<li>通道Channel：通过Channel实现数据的读写，通道是全双工，可同时读写，channel（接口）实现类有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等</li>\n<li>多路复用器Selector：轮询注册在其上的channel，如果某个channel发出读写请求并处于就绪状态，会被其轮询到，然后通过selectionKey可以获取到就绪的channel集合，然后进行后续IO操作，<ul>\n<li>Selector只能管理非阻塞channel，所以阻塞的FileChannel不能被其管理</li>\n<li>监听事件注册：serviceSocketChannel.register(selector, SelectionKey.OP_ACCEPT)</li>\n<li>监听事件：<ul>\n<li>OP_ACCEPT：接受就绪，ServiceSocketChannel使用</li>\n<li>OP_READ：读取就绪，SocketChannel使用</li>\n<li>OP_WRITE：写入就绪，SocketChannel使用</li>\n<li>OP_CONNECT：连接就绪，SocketChannel使用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AIO（Asynchronous-I-O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\"><a href=\"#AIO（Asynchronous-I-O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\" class=\"headerlink\" title=\"AIO（Asynchronous I/O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理\"></a>AIO（Asynchronous I/O）：也就是NIO2，异步非阻塞IO模型，多个有效的client请求才启动server多个线程，特点是系统处理完才通知server去创建线程处理</h3><ul>\n<li>使用场景：适合高负载、高并发场景，适用于连接数多且时间长的场景</li>\n<li>特点：基于事件和回调机制实现；不会阻塞，当后台处理完成时，系统会通知相应线程继续操作</li>\n</ul>\n<h3 id=\"IO模型总结\"><a href=\"#IO模型总结\" class=\"headerlink\" title=\"IO模型总结\"></a>IO模型总结</h3><ul>\n<li>同步阻塞：一个线程，顺序执行</li>\n<li>同步非阻塞：一个线程，顺序执行，遇到暂时没执行结果的行，先跳过执行后面的，然后通过某种方式比如轮询来查看无执行结果行的结果</li>\n<li>异步阻塞：一个线程中异步执行多个任务，其中一个任务执行时，其他任务需要阻塞等待</li>\n<li>异步非阻塞：有多个线程执行任务，所有的线程互不干预，各自干各自的活</li>\n</ul>\n<h2 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h2><h3 id=\"Files常用方法\"><a href=\"#Files常用方法\" class=\"headerlink\" title=\"Files常用方法\"></a>Files常用方法</h3><ul>\n<li>exists()：检测文件路径是否存在</li>\n<li>createFile()：创建文件</li>\n<li>createDirectory()：创建目录</li>\n<li>delete()：删除文件或目录</li>\n<li>copy()：复制文件</li>\n<li>move()：移动文件</li>\n<li>size()：查看文件个数</li>\n<li>read()：读取文件</li>\n<li>write()：写入文件</li>\n</ul>\n"},{"title":"Math静态方法","date":"2021-11-22T14:53:54.000Z","_content":"\n* round：返回四舍五入值，如-1.5返回-1\n* ceil：返回小数所在两整数间较大值，如-1.5返回-1\n* tail：返回小数所在两整数间较小值，如-1.5返回-2\n","source":"_posts/Q&A/Java/Math静态方法.md","raw":"---\ntitle: Math静态方法\ndate: 2021-11-22 22:53:54\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n* round：返回四舍五入值，如-1.5返回-1\n* ceil：返回小数所在两整数间较大值，如-1.5返回-1\n* tail：返回小数所在两整数间较小值，如-1.5返回-2\n","slug":"Q&A/Java/Math静态方法","published":1,"updated":"2022-04-12T09:00:46.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bs002zwgtt8tz1e5a8","content":"<ul>\n<li>round：返回四舍五入值，如-1.5返回-1</li>\n<li>ceil：返回小数所在两整数间较大值，如-1.5返回-1</li>\n<li>tail：返回小数所在两整数间较小值，如-1.5返回-2</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>round：返回四舍五入值，如-1.5返回-1</li>\n<li>ceil：返回小数所在两整数间较大值，如-1.5返回-1</li>\n<li>tail：返回小数所在两整数间较小值，如-1.5返回-2</li>\n</ul>\n"},{"title":"JDK、JRE、JVM","date":"2021-11-22T14:35:05.000Z","_content":"\n* JDK（Java Development Kit：开发Java程序）：\n  * JRE（Java Runtime Environment：运行Java程序）：\n    * JVM（Java Virtual Machine：实现Java程序跨平台运行）\n    * 运行时需要的核心类库\n  * 开发人员工具\n    * 编译工具（javac.exe）\n    * 运行工具（java.exe）\n","source":"_posts/Q&A/Java/JDK、JRE、JVM.md","raw":"---\ntitle: JDK、JRE、JVM\ndate: 2021-11-22 22:35:05\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n* JDK（Java Development Kit：开发Java程序）：\n  * JRE（Java Runtime Environment：运行Java程序）：\n    * JVM（Java Virtual Machine：实现Java程序跨平台运行）\n    * 运行时需要的核心类库\n  * 开发人员工具\n    * 编译工具（javac.exe）\n    * 运行工具（java.exe）\n","slug":"Q&A/Java/JDK、JRE、JVM","published":1,"updated":"2022-04-12T09:00:46.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bt0031wgtt11aqhojh","content":"<ul>\n<li>JDK（Java Development Kit：开发Java程序）：<ul>\n<li>JRE（Java Runtime Environment：运行Java程序）：<ul>\n<li>JVM（Java Virtual Machine：实现Java程序跨平台运行）</li>\n<li>运行时需要的核心类库</li>\n</ul>\n</li>\n<li>开发人员工具<ul>\n<li>编译工具（javac.exe）</li>\n<li>运行工具（java.exe）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>JDK（Java Development Kit：开发Java程序）：<ul>\n<li>JRE（Java Runtime Environment：运行Java程序）：<ul>\n<li>JVM（Java Virtual Machine：实现Java程序跨平台运行）</li>\n<li>运行时需要的核心类库</li>\n</ul>\n</li>\n<li>开发人员工具<ul>\n<li>编译工具（javac.exe）</li>\n<li>运行工具（java.exe）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"String、StringBuffer、StringBuilder","date":"2021-11-22T14:50:43.000Z","_content":"\n## String、StringBuffer、StringBuilder\n### 相关结论\n* 字符串直接相加（\"a\" + \"b\"）性能高，间接相加（str1 + str2）性能低\n* 多数场景下执行效率：StringBuilder > StringBuffer > String\n* 使用场景：\n    * string：简单字符串直接相加且改动少\n    * stringBuilder：字符串操作比较多\n    * stringBuffer：多线程且操作比较多\n\n## String：常量字符串类\n* 使用场景：简单常量字符串\n* 特点：\n    * 有新操作就会生成一个新对象\n    * 性能较差\n    * 被final修饰，不能被继承\n    * 下面的情况，两个string对象指向同一个地址，JVM会优先查找常量池中有没有，有的话直接将已存在的地址赋值给新对象\n    ```\n    String string1 = \"111\";\n    String string2 = \"111\";\n    // true\n    System.out.println(string1==string2);\n    ```\n    * 下面的情况，两个string对象是新开辟的内存空间，所以不相等\n    ```\n    String string1 = new String(\"111\");\n    String string2 = new String(\"222\");\n    // false\n    System.out.println(string1==string2);\n    ```\n\n## StringBuffer：线程安全的可变字符串类\n* 使用场景：需要频繁变化且需要线程安全\n* 特点：\n    * 每次变更都是在原来对象上去修改，不产生新对象\n    * 大部分场景下性能比String好\n    * 与StringBuffer基本相同，多了一个synchronized修饰，所以线程安全\n\n## StringBuilder：线程不安全的可变字符串类\n* 使用场景：不需要考虑线程安全问题场景，建议首选该类，然后是StringBuffer，然后是String\n* 特点：\n    * 与StringBuffer类似，不产生新对象\n    * 大部分场景性能比StringBuffer更好\n\n## string常见面试题\n### 下面这段代码的输出结果？\n```\n    String a = \"hello2\"; 　　\n    String b = \"hello\" + 2; 　　\n    System.out.println((a == b));\n```\n* true, 编译期间\"hello\" + 2被优化为hello2，所以两个对象都指向了同一个常量地址\n\n### 下面这段代码输出结果？\n```\n    String a = \"hello2\"; 　  \n    String b = \"hello\";       \n    String c = b + 2;       \n    System.out.println((a == c));\n```\n* false，因为有对象引用，所以c指向的地址是在堆中，而a和b都是指向了常量地址\n\n### 下面这段代码的输出结果？\n```\nString a = \"hello2\";   　\nfinal String b = \"hello\";       \nString c = b + 2;      \nSystem.out.println((a == c));\n```\n* true，final变量会在编译期间替换成具体的值，即c=\"hello\"+2，所以a和c指向了同一个常量地址\n\n### 下面这段代码的输出结果？\n```\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"hello2\";\n        final String b = getHello();\n        String c = b + 2;\n        System.out.println((a == c));\n    }\n\n    public static String getHello() {\n        return \"hello\";\n    }\n}\n```\n* false，b是通过调用方法赋值，调用方法需要在运行时执行，所以c保存的地址是在运行时确定，而a保存的地址在编译时已经确认\n\n### 下面这段代码的输出结果？\n```\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"hello\";\n        String b =  new String(\"hello\");\n        String c =  new String(\"hello\");\n        String d = b.intern();\n\n        System.out.println(a==b);\n        System.out.println(b==c);\n        System.out.println(b==d);\n        System.out.println(a==d);\n    }\n}\n```\n* false、false、false、true，intern作用是运行时在常量池中查找，有返回一个该常量的引用，没有创建一个常量，然后返回一个该常量的引用\n\n### String str = new String(\"abc\")创建了哪些对象？\n* 类加载时创建了\"abc\"对象，代码执行时创建了str对象\n\n### 下面这段代码1）和2）的区别是什么？\n```\npublic class Main {\n    public static void main(String[] args) {\n        String str1 = \"I\";\n        //str1 += \"love\"+\"java\";        1)\n        //str1 = str1+\"love\"+\"java\";    2)      \n    }\n}\n```\n* 1中只有一次append操作，2中有两次\n* 1中的字符串会在编译期间被合并\n* 1的效率比2高\n\n### String是不是基本数据类型?\n* 不是基本数据类型，继承Object\n\n\n### String str=\"i\"与 String str=new String(“i”)一样吗？\n* 不一样，str=\"i\"会分配到常量池里面，new String(“i”)会创建一个新对象\n\n### 如何将字符串反转？\n* 方案1：将字符串按字符放到栈中，然后从栈中输出\n* 方案2：StringBuffer 或 StringBuilder 的 reverse 成员方法\n* 方案3：利用toCharArray方法转化成数组，然后倒序输出\n* 方案4：利用 String 的 CharAt 方法倒序输出\n* 方案5：利用递归加二分实现\n```\npublic String testStringReverse(String string) {\n        if (string.length() <= 1) {\n            System.out.println(\"----\" + string + \"-----\");\n            return string;\n        }\n\n        String leftString = string.substring(0, string.length()/2);\n        String rightString = string.substring(string.length()/2, string.length());\n        String reverseString = testStringReverse(rightString) + testStringReverse(leftString);\n        System.out.println(\"====\" + reverseString + \"=====\");\n        return reverseString;\n    }\n```\n\n### String 类的常用方法都有那些？\n* 长度相关：\n  * public int length()\n* 数组相关：\n  * public byte[] getBytes()\n  * public char[] toCharArray()\n  * 按照regex分割为字符串数组：public String[] split(String regex)\n* 判断相关：\n  * public boolean isEmpty()\n  * public boolean equals(Object anObject)\n* 查找相关：\n  * public char charAt(int index)\n* 变更相关：\n  * public String replace(char oldChar, char newChar)\n","source":"_posts/Q&A/Java/String、StringBuffer、StringBuilder.md","raw":"---\ntitle: String、StringBuffer、StringBuilder\ndate: 2021-11-22 22:50:43\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## String、StringBuffer、StringBuilder\n### 相关结论\n* 字符串直接相加（\"a\" + \"b\"）性能高，间接相加（str1 + str2）性能低\n* 多数场景下执行效率：StringBuilder > StringBuffer > String\n* 使用场景：\n    * string：简单字符串直接相加且改动少\n    * stringBuilder：字符串操作比较多\n    * stringBuffer：多线程且操作比较多\n\n## String：常量字符串类\n* 使用场景：简单常量字符串\n* 特点：\n    * 有新操作就会生成一个新对象\n    * 性能较差\n    * 被final修饰，不能被继承\n    * 下面的情况，两个string对象指向同一个地址，JVM会优先查找常量池中有没有，有的话直接将已存在的地址赋值给新对象\n    ```\n    String string1 = \"111\";\n    String string2 = \"111\";\n    // true\n    System.out.println(string1==string2);\n    ```\n    * 下面的情况，两个string对象是新开辟的内存空间，所以不相等\n    ```\n    String string1 = new String(\"111\");\n    String string2 = new String(\"222\");\n    // false\n    System.out.println(string1==string2);\n    ```\n\n## StringBuffer：线程安全的可变字符串类\n* 使用场景：需要频繁变化且需要线程安全\n* 特点：\n    * 每次变更都是在原来对象上去修改，不产生新对象\n    * 大部分场景下性能比String好\n    * 与StringBuffer基本相同，多了一个synchronized修饰，所以线程安全\n\n## StringBuilder：线程不安全的可变字符串类\n* 使用场景：不需要考虑线程安全问题场景，建议首选该类，然后是StringBuffer，然后是String\n* 特点：\n    * 与StringBuffer类似，不产生新对象\n    * 大部分场景性能比StringBuffer更好\n\n## string常见面试题\n### 下面这段代码的输出结果？\n```\n    String a = \"hello2\"; 　　\n    String b = \"hello\" + 2; 　　\n    System.out.println((a == b));\n```\n* true, 编译期间\"hello\" + 2被优化为hello2，所以两个对象都指向了同一个常量地址\n\n### 下面这段代码输出结果？\n```\n    String a = \"hello2\"; 　  \n    String b = \"hello\";       \n    String c = b + 2;       \n    System.out.println((a == c));\n```\n* false，因为有对象引用，所以c指向的地址是在堆中，而a和b都是指向了常量地址\n\n### 下面这段代码的输出结果？\n```\nString a = \"hello2\";   　\nfinal String b = \"hello\";       \nString c = b + 2;      \nSystem.out.println((a == c));\n```\n* true，final变量会在编译期间替换成具体的值，即c=\"hello\"+2，所以a和c指向了同一个常量地址\n\n### 下面这段代码的输出结果？\n```\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"hello2\";\n        final String b = getHello();\n        String c = b + 2;\n        System.out.println((a == c));\n    }\n\n    public static String getHello() {\n        return \"hello\";\n    }\n}\n```\n* false，b是通过调用方法赋值，调用方法需要在运行时执行，所以c保存的地址是在运行时确定，而a保存的地址在编译时已经确认\n\n### 下面这段代码的输出结果？\n```\npublic class Main {\n    public static void main(String[] args) {\n        String a = \"hello\";\n        String b =  new String(\"hello\");\n        String c =  new String(\"hello\");\n        String d = b.intern();\n\n        System.out.println(a==b);\n        System.out.println(b==c);\n        System.out.println(b==d);\n        System.out.println(a==d);\n    }\n}\n```\n* false、false、false、true，intern作用是运行时在常量池中查找，有返回一个该常量的引用，没有创建一个常量，然后返回一个该常量的引用\n\n### String str = new String(\"abc\")创建了哪些对象？\n* 类加载时创建了\"abc\"对象，代码执行时创建了str对象\n\n### 下面这段代码1）和2）的区别是什么？\n```\npublic class Main {\n    public static void main(String[] args) {\n        String str1 = \"I\";\n        //str1 += \"love\"+\"java\";        1)\n        //str1 = str1+\"love\"+\"java\";    2)      \n    }\n}\n```\n* 1中只有一次append操作，2中有两次\n* 1中的字符串会在编译期间被合并\n* 1的效率比2高\n\n### String是不是基本数据类型?\n* 不是基本数据类型，继承Object\n\n\n### String str=\"i\"与 String str=new String(“i”)一样吗？\n* 不一样，str=\"i\"会分配到常量池里面，new String(“i”)会创建一个新对象\n\n### 如何将字符串反转？\n* 方案1：将字符串按字符放到栈中，然后从栈中输出\n* 方案2：StringBuffer 或 StringBuilder 的 reverse 成员方法\n* 方案3：利用toCharArray方法转化成数组，然后倒序输出\n* 方案4：利用 String 的 CharAt 方法倒序输出\n* 方案5：利用递归加二分实现\n```\npublic String testStringReverse(String string) {\n        if (string.length() <= 1) {\n            System.out.println(\"----\" + string + \"-----\");\n            return string;\n        }\n\n        String leftString = string.substring(0, string.length()/2);\n        String rightString = string.substring(string.length()/2, string.length());\n        String reverseString = testStringReverse(rightString) + testStringReverse(leftString);\n        System.out.println(\"====\" + reverseString + \"=====\");\n        return reverseString;\n    }\n```\n\n### String 类的常用方法都有那些？\n* 长度相关：\n  * public int length()\n* 数组相关：\n  * public byte[] getBytes()\n  * public char[] toCharArray()\n  * 按照regex分割为字符串数组：public String[] split(String regex)\n* 判断相关：\n  * public boolean isEmpty()\n  * public boolean equals(Object anObject)\n* 查找相关：\n  * public char charAt(int index)\n* 变更相关：\n  * public String replace(char oldChar, char newChar)\n","slug":"Q&A/Java/String、StringBuffer、StringBuilder","published":1,"updated":"2022-04-12T09:00:46.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bu0035wgttfeev03w6","content":"<h2 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h2><h3 id=\"相关结论\"><a href=\"#相关结论\" class=\"headerlink\" title=\"相关结论\"></a>相关结论</h3><ul>\n<li>字符串直接相加（”a” + “b”）性能高，间接相加（str1 + str2）性能低</li>\n<li>多数场景下执行效率：StringBuilder &gt; StringBuffer &gt; String</li>\n<li>使用场景：<ul>\n<li>string：简单字符串直接相加且改动少</li>\n<li>stringBuilder：字符串操作比较多</li>\n<li>stringBuffer：多线程且操作比较多</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"String：常量字符串类\"><a href=\"#String：常量字符串类\" class=\"headerlink\" title=\"String：常量字符串类\"></a>String：常量字符串类</h2><ul>\n<li>使用场景：简单常量字符串</li>\n<li>特点：<ul>\n<li>有新操作就会生成一个新对象</li>\n<li>性能较差</li>\n<li>被final修饰，不能被继承</li>\n<li>下面的情况，两个string对象指向同一个地址，JVM会优先查找常量池中有没有，有的话直接将已存在的地址赋值给新对象<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String string1 = &quot;111&quot;;</span><br><span class=\"line\">String string2 = &quot;111&quot;;</span><br><span class=\"line\">// true</span><br><span class=\"line\">System.out.println(string1==string2);</span><br></pre></td></tr></table></figure></li>\n<li>下面的情况，两个string对象是新开辟的内存空间，所以不相等<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String string1 = new String(&quot;111&quot;);</span><br><span class=\"line\">String string2 = new String(&quot;222&quot;);</span><br><span class=\"line\">// false</span><br><span class=\"line\">System.out.println(string1==string2);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"StringBuffer：线程安全的可变字符串类\"><a href=\"#StringBuffer：线程安全的可变字符串类\" class=\"headerlink\" title=\"StringBuffer：线程安全的可变字符串类\"></a>StringBuffer：线程安全的可变字符串类</h2><ul>\n<li>使用场景：需要频繁变化且需要线程安全</li>\n<li>特点：<ul>\n<li>每次变更都是在原来对象上去修改，不产生新对象</li>\n<li>大部分场景下性能比String好</li>\n<li>与StringBuffer基本相同，多了一个synchronized修饰，所以线程安全</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"StringBuilder：线程不安全的可变字符串类\"><a href=\"#StringBuilder：线程不安全的可变字符串类\" class=\"headerlink\" title=\"StringBuilder：线程不安全的可变字符串类\"></a>StringBuilder：线程不安全的可变字符串类</h2><ul>\n<li>使用场景：不需要考虑线程安全问题场景，建议首选该类，然后是StringBuffer，然后是String</li>\n<li>特点：<ul>\n<li>与StringBuffer类似，不产生新对象</li>\n<li>大部分场景性能比StringBuffer更好</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"string常见面试题\"><a href=\"#string常见面试题\" class=\"headerlink\" title=\"string常见面试题\"></a>string常见面试题</h2><h3 id=\"下面这段代码的输出结果？\"><a href=\"#下面这段代码的输出结果？\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;hello2&quot;; 　　</span><br><span class=\"line\">String b = &quot;hello&quot; + 2; 　　</span><br><span class=\"line\">System.out.println((a == b));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>true, 编译期间”hello” + 2被优化为hello2，所以两个对象都指向了同一个常量地址</li>\n</ul>\n<h3 id=\"下面这段代码输出结果？\"><a href=\"#下面这段代码输出结果？\" class=\"headerlink\" title=\"下面这段代码输出结果？\"></a>下面这段代码输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;hello2&quot;; 　  </span><br><span class=\"line\">String b = &quot;hello&quot;;       </span><br><span class=\"line\">String c = b + 2;       </span><br><span class=\"line\">System.out.println((a == c));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>false，因为有对象引用，所以c指向的地址是在堆中，而a和b都是指向了常量地址</li>\n</ul>\n<h3 id=\"下面这段代码的输出结果？-1\"><a href=\"#下面这段代码的输出结果？-1\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;hello2&quot;;   　</span><br><span class=\"line\">final String b = &quot;hello&quot;;       </span><br><span class=\"line\">String c = b + 2;      </span><br><span class=\"line\">System.out.println((a == c));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>true，final变量会在编译期间替换成具体的值，即c=”hello”+2，所以a和c指向了同一个常量地址</li>\n</ul>\n<h3 id=\"下面这段代码的输出结果？-2\"><a href=\"#下面这段代码的输出结果？-2\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = &quot;hello2&quot;;</span><br><span class=\"line\">        final String b = getHello();</span><br><span class=\"line\">        String c = b + 2;</span><br><span class=\"line\">        System.out.println((a == c));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String getHello() &#123;</span><br><span class=\"line\">        return &quot;hello&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>false，b是通过调用方法赋值，调用方法需要在运行时执行，所以c保存的地址是在运行时确定，而a保存的地址在编译时已经确认</li>\n</ul>\n<h3 id=\"下面这段代码的输出结果？-3\"><a href=\"#下面这段代码的输出结果？-3\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = &quot;hello&quot;;</span><br><span class=\"line\">        String b =  new String(&quot;hello&quot;);</span><br><span class=\"line\">        String c =  new String(&quot;hello&quot;);</span><br><span class=\"line\">        String d = b.intern();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(a==b);</span><br><span class=\"line\">        System.out.println(b==c);</span><br><span class=\"line\">        System.out.println(b==d);</span><br><span class=\"line\">        System.out.println(a==d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>false、false、false、true，intern作用是运行时在常量池中查找，有返回一个该常量的引用，没有创建一个常量，然后返回一个该常量的引用</li>\n</ul>\n<h3 id=\"String-str-new-String-“abc”-创建了哪些对象？\"><a href=\"#String-str-new-String-“abc”-创建了哪些对象？\" class=\"headerlink\" title=\"String str = new String(“abc”)创建了哪些对象？\"></a>String str = new String(“abc”)创建了哪些对象？</h3><ul>\n<li>类加载时创建了”abc”对象，代码执行时创建了str对象</li>\n</ul>\n<h3 id=\"下面这段代码1）和2）的区别是什么？\"><a href=\"#下面这段代码1）和2）的区别是什么？\" class=\"headerlink\" title=\"下面这段代码1）和2）的区别是什么？\"></a>下面这段代码1）和2）的区别是什么？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String str1 = &quot;I&quot;;</span><br><span class=\"line\">        //str1 += &quot;love&quot;+&quot;java&quot;;        1)</span><br><span class=\"line\">        //str1 = str1+&quot;love&quot;+&quot;java&quot;;    2)      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1中只有一次append操作，2中有两次</li>\n<li>1中的字符串会在编译期间被合并</li>\n<li>1的效率比2高</li>\n</ul>\n<h3 id=\"String是不是基本数据类型\"><a href=\"#String是不是基本数据类型\" class=\"headerlink\" title=\"String是不是基本数据类型?\"></a>String是不是基本数据类型?</h3><ul>\n<li>不是基本数据类型，继承Object</li>\n</ul>\n<h3 id=\"String-str-”i”与-String-str-new-String-“i”-一样吗？\"><a href=\"#String-str-”i”与-String-str-new-String-“i”-一样吗？\" class=\"headerlink\" title=\"String str=”i”与 String str=new String(“i”)一样吗？\"></a>String str=”i”与 String str=new String(“i”)一样吗？</h3><ul>\n<li>不一样，str=”i”会分配到常量池里面，new String(“i”)会创建一个新对象</li>\n</ul>\n<h3 id=\"如何将字符串反转？\"><a href=\"#如何将字符串反转？\" class=\"headerlink\" title=\"如何将字符串反转？\"></a>如何将字符串反转？</h3><ul>\n<li>方案1：将字符串按字符放到栈中，然后从栈中输出</li>\n<li>方案2：StringBuffer 或 StringBuilder 的 reverse 成员方法</li>\n<li>方案3：利用toCharArray方法转化成数组，然后倒序输出</li>\n<li>方案4：利用 String 的 CharAt 方法倒序输出</li>\n<li>方案5：利用递归加二分实现<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String testStringReverse(String string) &#123;</span><br><span class=\"line\">        if (string.length() &lt;= 1) &#123;</span><br><span class=\"line\">            System.out.println(&quot;----&quot; + string + &quot;-----&quot;);</span><br><span class=\"line\">            return string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String leftString = string.substring(0, string.length()/2);</span><br><span class=\"line\">        String rightString = string.substring(string.length()/2, string.length());</span><br><span class=\"line\">        String reverseString = testStringReverse(rightString) + testStringReverse(leftString);</span><br><span class=\"line\">        System.out.println(&quot;====&quot; + reverseString + &quot;=====&quot;);</span><br><span class=\"line\">        return reverseString;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"String-类的常用方法都有那些？\"><a href=\"#String-类的常用方法都有那些？\" class=\"headerlink\" title=\"String 类的常用方法都有那些？\"></a>String 类的常用方法都有那些？</h3><ul>\n<li>长度相关：<ul>\n<li>public int length()</li>\n</ul>\n</li>\n<li>数组相关：<ul>\n<li>public byte[] getBytes()</li>\n<li>public char[] toCharArray()</li>\n<li>按照regex分割为字符串数组：public String[] split(String regex)</li>\n</ul>\n</li>\n<li>判断相关：<ul>\n<li>public boolean isEmpty()</li>\n<li>public boolean equals(Object anObject)</li>\n</ul>\n</li>\n<li>查找相关：<ul>\n<li>public char charAt(int index)</li>\n</ul>\n</li>\n<li>变更相关：<ul>\n<li>public String replace(char oldChar, char newChar)</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"String、StringBuffer、StringBuilder\"><a href=\"#String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder\"></a>String、StringBuffer、StringBuilder</h2><h3 id=\"相关结论\"><a href=\"#相关结论\" class=\"headerlink\" title=\"相关结论\"></a>相关结论</h3><ul>\n<li>字符串直接相加（”a” + “b”）性能高，间接相加（str1 + str2）性能低</li>\n<li>多数场景下执行效率：StringBuilder &gt; StringBuffer &gt; String</li>\n<li>使用场景：<ul>\n<li>string：简单字符串直接相加且改动少</li>\n<li>stringBuilder：字符串操作比较多</li>\n<li>stringBuffer：多线程且操作比较多</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"String：常量字符串类\"><a href=\"#String：常量字符串类\" class=\"headerlink\" title=\"String：常量字符串类\"></a>String：常量字符串类</h2><ul>\n<li>使用场景：简单常量字符串</li>\n<li>特点：<ul>\n<li>有新操作就会生成一个新对象</li>\n<li>性能较差</li>\n<li>被final修饰，不能被继承</li>\n<li>下面的情况，两个string对象指向同一个地址，JVM会优先查找常量池中有没有，有的话直接将已存在的地址赋值给新对象<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String string1 = &quot;111&quot;;</span><br><span class=\"line\">String string2 = &quot;111&quot;;</span><br><span class=\"line\">// true</span><br><span class=\"line\">System.out.println(string1==string2);</span><br></pre></td></tr></table></figure></li>\n<li>下面的情况，两个string对象是新开辟的内存空间，所以不相等<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String string1 = new String(&quot;111&quot;);</span><br><span class=\"line\">String string2 = new String(&quot;222&quot;);</span><br><span class=\"line\">// false</span><br><span class=\"line\">System.out.println(string1==string2);</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"StringBuffer：线程安全的可变字符串类\"><a href=\"#StringBuffer：线程安全的可变字符串类\" class=\"headerlink\" title=\"StringBuffer：线程安全的可变字符串类\"></a>StringBuffer：线程安全的可变字符串类</h2><ul>\n<li>使用场景：需要频繁变化且需要线程安全</li>\n<li>特点：<ul>\n<li>每次变更都是在原来对象上去修改，不产生新对象</li>\n<li>大部分场景下性能比String好</li>\n<li>与StringBuffer基本相同，多了一个synchronized修饰，所以线程安全</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"StringBuilder：线程不安全的可变字符串类\"><a href=\"#StringBuilder：线程不安全的可变字符串类\" class=\"headerlink\" title=\"StringBuilder：线程不安全的可变字符串类\"></a>StringBuilder：线程不安全的可变字符串类</h2><ul>\n<li>使用场景：不需要考虑线程安全问题场景，建议首选该类，然后是StringBuffer，然后是String</li>\n<li>特点：<ul>\n<li>与StringBuffer类似，不产生新对象</li>\n<li>大部分场景性能比StringBuffer更好</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"string常见面试题\"><a href=\"#string常见面试题\" class=\"headerlink\" title=\"string常见面试题\"></a>string常见面试题</h2><h3 id=\"下面这段代码的输出结果？\"><a href=\"#下面这段代码的输出结果？\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;hello2&quot;; 　　</span><br><span class=\"line\">String b = &quot;hello&quot; + 2; 　　</span><br><span class=\"line\">System.out.println((a == b));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>true, 编译期间”hello” + 2被优化为hello2，所以两个对象都指向了同一个常量地址</li>\n</ul>\n<h3 id=\"下面这段代码输出结果？\"><a href=\"#下面这段代码输出结果？\" class=\"headerlink\" title=\"下面这段代码输出结果？\"></a>下面这段代码输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;hello2&quot;; 　  </span><br><span class=\"line\">String b = &quot;hello&quot;;       </span><br><span class=\"line\">String c = b + 2;       </span><br><span class=\"line\">System.out.println((a == c));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>false，因为有对象引用，所以c指向的地址是在堆中，而a和b都是指向了常量地址</li>\n</ul>\n<h3 id=\"下面这段代码的输出结果？-1\"><a href=\"#下面这段代码的输出结果？-1\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a = &quot;hello2&quot;;   　</span><br><span class=\"line\">final String b = &quot;hello&quot;;       </span><br><span class=\"line\">String c = b + 2;      </span><br><span class=\"line\">System.out.println((a == c));</span><br></pre></td></tr></table></figure>\n<ul>\n<li>true，final变量会在编译期间替换成具体的值，即c=”hello”+2，所以a和c指向了同一个常量地址</li>\n</ul>\n<h3 id=\"下面这段代码的输出结果？-2\"><a href=\"#下面这段代码的输出结果？-2\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = &quot;hello2&quot;;</span><br><span class=\"line\">        final String b = getHello();</span><br><span class=\"line\">        String c = b + 2;</span><br><span class=\"line\">        System.out.println((a == c));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String getHello() &#123;</span><br><span class=\"line\">        return &quot;hello&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>false，b是通过调用方法赋值，调用方法需要在运行时执行，所以c保存的地址是在运行时确定，而a保存的地址在编译时已经确认</li>\n</ul>\n<h3 id=\"下面这段代码的输出结果？-3\"><a href=\"#下面这段代码的输出结果？-3\" class=\"headerlink\" title=\"下面这段代码的输出结果？\"></a>下面这段代码的输出结果？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String a = &quot;hello&quot;;</span><br><span class=\"line\">        String b =  new String(&quot;hello&quot;);</span><br><span class=\"line\">        String c =  new String(&quot;hello&quot;);</span><br><span class=\"line\">        String d = b.intern();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(a==b);</span><br><span class=\"line\">        System.out.println(b==c);</span><br><span class=\"line\">        System.out.println(b==d);</span><br><span class=\"line\">        System.out.println(a==d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>false、false、false、true，intern作用是运行时在常量池中查找，有返回一个该常量的引用，没有创建一个常量，然后返回一个该常量的引用</li>\n</ul>\n<h3 id=\"String-str-new-String-“abc”-创建了哪些对象？\"><a href=\"#String-str-new-String-“abc”-创建了哪些对象？\" class=\"headerlink\" title=\"String str = new String(“abc”)创建了哪些对象？\"></a>String str = new String(“abc”)创建了哪些对象？</h3><ul>\n<li>类加载时创建了”abc”对象，代码执行时创建了str对象</li>\n</ul>\n<h3 id=\"下面这段代码1）和2）的区别是什么？\"><a href=\"#下面这段代码1）和2）的区别是什么？\" class=\"headerlink\" title=\"下面这段代码1）和2）的区别是什么？\"></a>下面这段代码1）和2）的区别是什么？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String str1 = &quot;I&quot;;</span><br><span class=\"line\">        //str1 += &quot;love&quot;+&quot;java&quot;;        1)</span><br><span class=\"line\">        //str1 = str1+&quot;love&quot;+&quot;java&quot;;    2)      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1中只有一次append操作，2中有两次</li>\n<li>1中的字符串会在编译期间被合并</li>\n<li>1的效率比2高</li>\n</ul>\n<h3 id=\"String是不是基本数据类型\"><a href=\"#String是不是基本数据类型\" class=\"headerlink\" title=\"String是不是基本数据类型?\"></a>String是不是基本数据类型?</h3><ul>\n<li>不是基本数据类型，继承Object</li>\n</ul>\n<h3 id=\"String-str-”i”与-String-str-new-String-“i”-一样吗？\"><a href=\"#String-str-”i”与-String-str-new-String-“i”-一样吗？\" class=\"headerlink\" title=\"String str=”i”与 String str=new String(“i”)一样吗？\"></a>String str=”i”与 String str=new String(“i”)一样吗？</h3><ul>\n<li>不一样，str=”i”会分配到常量池里面，new String(“i”)会创建一个新对象</li>\n</ul>\n<h3 id=\"如何将字符串反转？\"><a href=\"#如何将字符串反转？\" class=\"headerlink\" title=\"如何将字符串反转？\"></a>如何将字符串反转？</h3><ul>\n<li>方案1：将字符串按字符放到栈中，然后从栈中输出</li>\n<li>方案2：StringBuffer 或 StringBuilder 的 reverse 成员方法</li>\n<li>方案3：利用toCharArray方法转化成数组，然后倒序输出</li>\n<li>方案4：利用 String 的 CharAt 方法倒序输出</li>\n<li>方案5：利用递归加二分实现<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String testStringReverse(String string) &#123;</span><br><span class=\"line\">        if (string.length() &lt;= 1) &#123;</span><br><span class=\"line\">            System.out.println(&quot;----&quot; + string + &quot;-----&quot;);</span><br><span class=\"line\">            return string;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String leftString = string.substring(0, string.length()/2);</span><br><span class=\"line\">        String rightString = string.substring(string.length()/2, string.length());</span><br><span class=\"line\">        String reverseString = testStringReverse(rightString) + testStringReverse(leftString);</span><br><span class=\"line\">        System.out.println(&quot;====&quot; + reverseString + &quot;=====&quot;);</span><br><span class=\"line\">        return reverseString;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"String-类的常用方法都有那些？\"><a href=\"#String-类的常用方法都有那些？\" class=\"headerlink\" title=\"String 类的常用方法都有那些？\"></a>String 类的常用方法都有那些？</h3><ul>\n<li>长度相关：<ul>\n<li>public int length()</li>\n</ul>\n</li>\n<li>数组相关：<ul>\n<li>public byte[] getBytes()</li>\n<li>public char[] toCharArray()</li>\n<li>按照regex分割为字符串数组：public String[] split(String regex)</li>\n</ul>\n</li>\n<li>判断相关：<ul>\n<li>public boolean isEmpty()</li>\n<li>public boolean equals(Object anObject)</li>\n</ul>\n</li>\n<li>查找相关：<ul>\n<li>public char charAt(int index)</li>\n</ul>\n</li>\n<li>变更相关：<ul>\n<li>public String replace(char oldChar, char newChar)</li>\n</ul>\n</li>\n</ul>\n"},{"title":"final","date":"2021-11-22T14:49:58.000Z","_content":"\n## final：用于修饰类、方法、数据，使其内存的内容不变\n* 类：该类不能被继承\n* 方法：该方法不能被重写。与private有相同功能\n* 数据：\n    * 基本数据类型、String：其值不能修改，String在修改时会重新创建一个对象，即其内存中的地址会指向新的对象，所以String被final修饰时，其值不能修改\n    * 引用数据类型：该引用地址不能变，但地址指向的对象内部的变量可以变\n","source":"_posts/Q&A/Java/final.md","raw":"---\ntitle: final\ndate: 2021-11-22 22:49:58\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## final：用于修饰类、方法、数据，使其内存的内容不变\n* 类：该类不能被继承\n* 方法：该方法不能被重写。与private有相同功能\n* 数据：\n    * 基本数据类型、String：其值不能修改，String在修改时会重新创建一个对象，即其内存中的地址会指向新的对象，所以String被final修饰时，其值不能修改\n    * 引用数据类型：该引用地址不能变，但地址指向的对象内部的变量可以变\n","slug":"Q&A/Java/final","published":1,"updated":"2022-04-12T09:00:46.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bv0037wgttfwo01cd3","content":"<h2 id=\"final：用于修饰类、方法、数据，使其内存的内容不变\"><a href=\"#final：用于修饰类、方法、数据，使其内存的内容不变\" class=\"headerlink\" title=\"final：用于修饰类、方法、数据，使其内存的内容不变\"></a>final：用于修饰类、方法、数据，使其内存的内容不变</h2><ul>\n<li>类：该类不能被继承</li>\n<li>方法：该方法不能被重写。与private有相同功能</li>\n<li>数据：<ul>\n<li>基本数据类型、String：其值不能修改，String在修改时会重新创建一个对象，即其内存中的地址会指向新的对象，所以String被final修饰时，其值不能修改</li>\n<li>引用数据类型：该引用地址不能变，但地址指向的对象内部的变量可以变</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"final：用于修饰类、方法、数据，使其内存的内容不变\"><a href=\"#final：用于修饰类、方法、数据，使其内存的内容不变\" class=\"headerlink\" title=\"final：用于修饰类、方法、数据，使其内存的内容不变\"></a>final：用于修饰类、方法、数据，使其内存的内容不变</h2><ul>\n<li>类：该类不能被继承</li>\n<li>方法：该方法不能被重写。与private有相同功能</li>\n<li>数据：<ul>\n<li>基本数据类型、String：其值不能修改，String在修改时会重新创建一个对象，即其内存中的地址会指向新的对象，所以String被final修饰时，其值不能修改</li>\n<li>引用数据类型：该引用地址不能变，但地址指向的对象内部的变量可以变</li>\n</ul>\n</li>\n</ul>\n"},{"title":"javaWeb","date":"2022-03-28T08:25:19.000Z","_content":"\n### servlet是什么？\n* 是一个java web应用服务器，servlet就是一个java官方封装好的HTTP应用服务器功能集合（也可以说规范，比如实现了识别http请求，复用TCP连接等底层操作），即是一个Java官方提供的HTTP服务器功能集合或者规范，方便我们基于此进行应用服务的开发，将精力集中在业务层的编码中即可\n* 诞生的原因或者目的：方便开发者快速开发java web服务，为java web服务提供一套规范\n\n### jsp是什么？\n* [参考文章](https://www.liaoxuefeng.com/wiki/1252599548343744/1266262958498784)\n* 是一个java web应用服务器，全称Java server Pages\n* 样子是一个html文件，然后里面内嵌着java代码，用来实现动态网页的开发，这种方式更适合前后端融合的形式，一个人编写比较方便\n* 用来开发动态网页应用的一种方式，静态网页之中包含java代码，以实现动态响应能力\n* 实际运行时会被编译成servlet，本质是servlet的另一种形式\n\n### Tomcat是什么？\n* Tomcat是集合了Servlet、JSP、Java WebSocket等多种网络服务功能的一个更大的java web 服务器，并且还具有可视化配置页面等功能\n\n### Apache是什么？\n* 是一个web服务功能集合，全称Apache HTTP Server，只支持HTTP服务\n\n### Nginx是什么？\n* 一款轻量级web服务器，跟Apache核心功能类似，都是HTTP服务器，特点是更适合高并发场景等\n\n### 正向代理、反向代理\n* 正向代理：VPN即正向代理，即代理会真的替代客户端发请求，而非转发，此时客户端的请求是被整整替代的，所以正向代理，代理的是客户端\n* 反向代理：即代理只是转发请求，并没有代理客户端发请求，然后服务器响应，此时服务器被代理\n* 总结：正向代理，即客户端被代理的情况，反向代理是服务端被代理的情况\n\n### jsp 和 servlet 有什么区别？\n||jsp|servlet|\n|---|---|---|\n|本质|jsp本质就是servlet，是servlet的一种简易实现方式，或者说是servlet的拓展，JVM只能识别java代码，是web服务器将jsp代码编译成java代码|servlet是java官方提供你的一套http服务器功能集合，或者说一种http服务器规范，方便开发者快速开发应用服务，将精力集中在业务上|\n|适用场景|jsp是在HTML中包含了java代码，所以本身包含可视化页面，更容易实现动态网页应用|servlet内部更多地是各种逻辑层，没有可视化相关的内容，更适合做逻辑层、控制层等|\n|特点|jsp侧重于可视化部分|servlet侧重于逻辑控制部分|\n|诞生目的|简化servlet的使用，使servlet跟HTML更好的结合起来，更好的实现java web应用|为开发者提供java web应用服务开发的规范或者工具，提高开发者效率|\n\n\n### jsp 有哪些内置对象？作用分别是什么？\n|jsp内置对象名称|对应servlet类|作用|\n|---|---|---|\n|request|javax.servlet.http.HttpServletRequest|client请求信息，http协议头信息、cookie、请求参数等|\n|response|javax.servlet.http.HttpServletResponse|server响应client请求，返回信息|\n|pageContent|javax.servlet.jsp.PageContext|页面上下文|\n|session|javax.servlet.http.HttpSession|client与server之间的会话|\n|application|javax.servlet.ServletContext|获取服务端应用生命周期信息|\n|out|javax.servlet.jsp.JspWriter|server给client传输内容的输出流|\n|config|javax.servlet.ServletConfig|初始化是，jsp引擎向jsp页面传递的信息|\n|page|java.lang.Object|指向jsp页面本身|\n|exception|\tjava.lang.Throwable|页面异常对象|\n\n\n### 说一下 jsp 的 4 种作用域？\n* 作用域：即信息共享范围，类似于public、private这种\n* 四种作用域介绍：\n|作用域范围|信息传递类|\n|---|---|\n|application：即服务启动到停止的时间|ServletContext|\n|session：http会话开始到结束的时间|session|\n|request：http请求到结束的时间|request|\n|page：当前页面打开到关闭的时间|pageContext|\n\n### session 和 cookie 有什么区别？\n||cookie|session|\n|---|---|---|\n|简介|是放在client上给server端做相关逻辑使用的，server会在response中返给client，server可以对cookie进行读写，比如可以使用cookie来保存用户信息，以便于server端校验用户信息|是放在server上，可以用来跟cookie的搭配做一些比如用户信息校验的逻辑|\n|存放位置|client|server|\n|容易|较小|较大|\n|安全性|较差|较强|\n\n### 说一下 session 的工作原理？\n* 简要说明：用户注册之后生成session，然后保存到内存或者硬盘中，供cookie过来之后的校验\n* 举例：比如用户登录校验这种，用户登录成功后，server将待seesionId的cookie返回给client，当client发起新的请求时，将cookie发送给server，然后server使用cookie和seesion进行用户登录校验，比如可以匹配一下seesionId这种方式验证\n\n### 如果客户端禁止 cookie 能实现 session 还能用吗？\n* 当然能用，cookie只是一个保存信息的数据结构而已，我们可以自己设计另一个跟cookie功能一致的东西，办法很多，根据场景选择即可，比如此时client只保存一个sessionid给server做用户登录校验即可\n\n### spring mvc 和 struts 的区别是什么？\n||spring mvc|struts|\n|---|---|---|\n|简介|spring MVC是一个web开发框架，本质上相当于servlet，方便开发者更高效的开发web应用|是一个web开发框架，基于servlet与MVC设计模式实现|\n|机制|spring mvc的入口是servlet|入口是filter|\n|性能|较好，基于方法设计，粒度更细|较差，基于类设计，每收到一个请求，都会实例一个action|\n|参数传递|形参传递，方法之间是独立的|可以使用属性接收参数|\n|设计思想|在servlet上进行拓展，AOP|OOP|\n|开发效率|高|低|\n|配置量|接近0|较多|\n|拦截器实现机制|AOP方式，方法级别拦截|自己的interceptor机制，类级别拦截|\n|Ajax支持|继承了Ajax，使用@ResponseBody即可实现|拦截器中继承了Ajax，在action中处理时必须安装插件或者写代码集成进去，使用较为不方便|\n|验证机制|支持JSR303（一种参数校验规范），处理简单|繁琐|\n\n### 如何避免 sql 注入？\n* 定义：输入数据中包含非法sql语句，且此sql语句被非法执行\n* 避免策略：\n  * 过滤输入内容，校验字符串\n  * 参数化查询\n  * 安全测试、安全审计（CR）\n  * 避免使用动态sql\n  * 数据库重要数据加密\n  * 数据库权限控制\n  * 避免数据库直接跟用户产生交互\n\n### 什么是 XSS 攻击，如何避免？\n* 定义：又称CSS，全称Cross Site Script（跨站脚本攻击），即输入一段HTML来攻击应用\n* 避免策略：\n  * 对输入、输出进行过滤、转义处理\n  * 对HTML标签、CSS属性复制的地方进行校验\n\n### 什么是 CSRF 攻击，如何避免？\n* 定义：全称Cross Site Request Forgery（跨站请求伪造），即攻击者盗用身份，发送恶意请求\n* 避免策略：\n  * 阻止不明外域访问，比如验证请求地址等策略\n  * 关键操作添加验证码\n  * 增加token、cookie校验策略\n","source":"_posts/Q&A/Java/javaWeb.md","raw":"---\ntitle: javaWeb\ndate: 2022-03-28 16:25:19\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n### servlet是什么？\n* 是一个java web应用服务器，servlet就是一个java官方封装好的HTTP应用服务器功能集合（也可以说规范，比如实现了识别http请求，复用TCP连接等底层操作），即是一个Java官方提供的HTTP服务器功能集合或者规范，方便我们基于此进行应用服务的开发，将精力集中在业务层的编码中即可\n* 诞生的原因或者目的：方便开发者快速开发java web服务，为java web服务提供一套规范\n\n### jsp是什么？\n* [参考文章](https://www.liaoxuefeng.com/wiki/1252599548343744/1266262958498784)\n* 是一个java web应用服务器，全称Java server Pages\n* 样子是一个html文件，然后里面内嵌着java代码，用来实现动态网页的开发，这种方式更适合前后端融合的形式，一个人编写比较方便\n* 用来开发动态网页应用的一种方式，静态网页之中包含java代码，以实现动态响应能力\n* 实际运行时会被编译成servlet，本质是servlet的另一种形式\n\n### Tomcat是什么？\n* Tomcat是集合了Servlet、JSP、Java WebSocket等多种网络服务功能的一个更大的java web 服务器，并且还具有可视化配置页面等功能\n\n### Apache是什么？\n* 是一个web服务功能集合，全称Apache HTTP Server，只支持HTTP服务\n\n### Nginx是什么？\n* 一款轻量级web服务器，跟Apache核心功能类似，都是HTTP服务器，特点是更适合高并发场景等\n\n### 正向代理、反向代理\n* 正向代理：VPN即正向代理，即代理会真的替代客户端发请求，而非转发，此时客户端的请求是被整整替代的，所以正向代理，代理的是客户端\n* 反向代理：即代理只是转发请求，并没有代理客户端发请求，然后服务器响应，此时服务器被代理\n* 总结：正向代理，即客户端被代理的情况，反向代理是服务端被代理的情况\n\n### jsp 和 servlet 有什么区别？\n||jsp|servlet|\n|---|---|---|\n|本质|jsp本质就是servlet，是servlet的一种简易实现方式，或者说是servlet的拓展，JVM只能识别java代码，是web服务器将jsp代码编译成java代码|servlet是java官方提供你的一套http服务器功能集合，或者说一种http服务器规范，方便开发者快速开发应用服务，将精力集中在业务上|\n|适用场景|jsp是在HTML中包含了java代码，所以本身包含可视化页面，更容易实现动态网页应用|servlet内部更多地是各种逻辑层，没有可视化相关的内容，更适合做逻辑层、控制层等|\n|特点|jsp侧重于可视化部分|servlet侧重于逻辑控制部分|\n|诞生目的|简化servlet的使用，使servlet跟HTML更好的结合起来，更好的实现java web应用|为开发者提供java web应用服务开发的规范或者工具，提高开发者效率|\n\n\n### jsp 有哪些内置对象？作用分别是什么？\n|jsp内置对象名称|对应servlet类|作用|\n|---|---|---|\n|request|javax.servlet.http.HttpServletRequest|client请求信息，http协议头信息、cookie、请求参数等|\n|response|javax.servlet.http.HttpServletResponse|server响应client请求，返回信息|\n|pageContent|javax.servlet.jsp.PageContext|页面上下文|\n|session|javax.servlet.http.HttpSession|client与server之间的会话|\n|application|javax.servlet.ServletContext|获取服务端应用生命周期信息|\n|out|javax.servlet.jsp.JspWriter|server给client传输内容的输出流|\n|config|javax.servlet.ServletConfig|初始化是，jsp引擎向jsp页面传递的信息|\n|page|java.lang.Object|指向jsp页面本身|\n|exception|\tjava.lang.Throwable|页面异常对象|\n\n\n### 说一下 jsp 的 4 种作用域？\n* 作用域：即信息共享范围，类似于public、private这种\n* 四种作用域介绍：\n|作用域范围|信息传递类|\n|---|---|\n|application：即服务启动到停止的时间|ServletContext|\n|session：http会话开始到结束的时间|session|\n|request：http请求到结束的时间|request|\n|page：当前页面打开到关闭的时间|pageContext|\n\n### session 和 cookie 有什么区别？\n||cookie|session|\n|---|---|---|\n|简介|是放在client上给server端做相关逻辑使用的，server会在response中返给client，server可以对cookie进行读写，比如可以使用cookie来保存用户信息，以便于server端校验用户信息|是放在server上，可以用来跟cookie的搭配做一些比如用户信息校验的逻辑|\n|存放位置|client|server|\n|容易|较小|较大|\n|安全性|较差|较强|\n\n### 说一下 session 的工作原理？\n* 简要说明：用户注册之后生成session，然后保存到内存或者硬盘中，供cookie过来之后的校验\n* 举例：比如用户登录校验这种，用户登录成功后，server将待seesionId的cookie返回给client，当client发起新的请求时，将cookie发送给server，然后server使用cookie和seesion进行用户登录校验，比如可以匹配一下seesionId这种方式验证\n\n### 如果客户端禁止 cookie 能实现 session 还能用吗？\n* 当然能用，cookie只是一个保存信息的数据结构而已，我们可以自己设计另一个跟cookie功能一致的东西，办法很多，根据场景选择即可，比如此时client只保存一个sessionid给server做用户登录校验即可\n\n### spring mvc 和 struts 的区别是什么？\n||spring mvc|struts|\n|---|---|---|\n|简介|spring MVC是一个web开发框架，本质上相当于servlet，方便开发者更高效的开发web应用|是一个web开发框架，基于servlet与MVC设计模式实现|\n|机制|spring mvc的入口是servlet|入口是filter|\n|性能|较好，基于方法设计，粒度更细|较差，基于类设计，每收到一个请求，都会实例一个action|\n|参数传递|形参传递，方法之间是独立的|可以使用属性接收参数|\n|设计思想|在servlet上进行拓展，AOP|OOP|\n|开发效率|高|低|\n|配置量|接近0|较多|\n|拦截器实现机制|AOP方式，方法级别拦截|自己的interceptor机制，类级别拦截|\n|Ajax支持|继承了Ajax，使用@ResponseBody即可实现|拦截器中继承了Ajax，在action中处理时必须安装插件或者写代码集成进去，使用较为不方便|\n|验证机制|支持JSR303（一种参数校验规范），处理简单|繁琐|\n\n### 如何避免 sql 注入？\n* 定义：输入数据中包含非法sql语句，且此sql语句被非法执行\n* 避免策略：\n  * 过滤输入内容，校验字符串\n  * 参数化查询\n  * 安全测试、安全审计（CR）\n  * 避免使用动态sql\n  * 数据库重要数据加密\n  * 数据库权限控制\n  * 避免数据库直接跟用户产生交互\n\n### 什么是 XSS 攻击，如何避免？\n* 定义：又称CSS，全称Cross Site Script（跨站脚本攻击），即输入一段HTML来攻击应用\n* 避免策略：\n  * 对输入、输出进行过滤、转义处理\n  * 对HTML标签、CSS属性复制的地方进行校验\n\n### 什么是 CSRF 攻击，如何避免？\n* 定义：全称Cross Site Request Forgery（跨站请求伪造），即攻击者盗用身份，发送恶意请求\n* 避免策略：\n  * 阻止不明外域访问，比如验证请求地址等策略\n  * 关键操作添加验证码\n  * 增加token、cookie校验策略\n","slug":"Q&A/Java/javaWeb","published":1,"updated":"2022-04-12T09:00:46.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bx003awgtt2mum8gh0","content":"<h3 id=\"servlet是什么？\"><a href=\"#servlet是什么？\" class=\"headerlink\" title=\"servlet是什么？\"></a>servlet是什么？</h3><ul>\n<li>是一个java web应用服务器，servlet就是一个java官方封装好的HTTP应用服务器功能集合（也可以说规范，比如实现了识别http请求，复用TCP连接等底层操作），即是一个Java官方提供的HTTP服务器功能集合或者规范，方便我们基于此进行应用服务的开发，将精力集中在业务层的编码中即可</li>\n<li>诞生的原因或者目的：方便开发者快速开发java web服务，为java web服务提供一套规范</li>\n</ul>\n<h3 id=\"jsp是什么？\"><a href=\"#jsp是什么？\" class=\"headerlink\" title=\"jsp是什么？\"></a>jsp是什么？</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266262958498784\">参考文章</a></li>\n<li>是一个java web应用服务器，全称Java server Pages</li>\n<li>样子是一个html文件，然后里面内嵌着java代码，用来实现动态网页的开发，这种方式更适合前后端融合的形式，一个人编写比较方便</li>\n<li>用来开发动态网页应用的一种方式，静态网页之中包含java代码，以实现动态响应能力</li>\n<li>实际运行时会被编译成servlet，本质是servlet的另一种形式</li>\n</ul>\n<h3 id=\"Tomcat是什么？\"><a href=\"#Tomcat是什么？\" class=\"headerlink\" title=\"Tomcat是什么？\"></a>Tomcat是什么？</h3><ul>\n<li>Tomcat是集合了Servlet、JSP、Java WebSocket等多种网络服务功能的一个更大的java web 服务器，并且还具有可视化配置页面等功能</li>\n</ul>\n<h3 id=\"Apache是什么？\"><a href=\"#Apache是什么？\" class=\"headerlink\" title=\"Apache是什么？\"></a>Apache是什么？</h3><ul>\n<li>是一个web服务功能集合，全称Apache HTTP Server，只支持HTTP服务</li>\n</ul>\n<h3 id=\"Nginx是什么？\"><a href=\"#Nginx是什么？\" class=\"headerlink\" title=\"Nginx是什么？\"></a>Nginx是什么？</h3><ul>\n<li>一款轻量级web服务器，跟Apache核心功能类似，都是HTTP服务器，特点是更适合高并发场景等</li>\n</ul>\n<h3 id=\"正向代理、反向代理\"><a href=\"#正向代理、反向代理\" class=\"headerlink\" title=\"正向代理、反向代理\"></a>正向代理、反向代理</h3><ul>\n<li>正向代理：VPN即正向代理，即代理会真的替代客户端发请求，而非转发，此时客户端的请求是被整整替代的，所以正向代理，代理的是客户端</li>\n<li>反向代理：即代理只是转发请求，并没有代理客户端发请求，然后服务器响应，此时服务器被代理</li>\n<li>总结：正向代理，即客户端被代理的情况，反向代理是服务端被代理的情况</li>\n</ul>\n<h3 id=\"jsp-和-servlet-有什么区别？\"><a href=\"#jsp-和-servlet-有什么区别？\" class=\"headerlink\" title=\"jsp 和 servlet 有什么区别？\"></a>jsp 和 servlet 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>jsp</th>\n<th>servlet</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>本质</td>\n<td>jsp本质就是servlet，是servlet的一种简易实现方式，或者说是servlet的拓展，JVM只能识别java代码，是web服务器将jsp代码编译成java代码</td>\n<td>servlet是java官方提供你的一套http服务器功能集合，或者说一种http服务器规范，方便开发者快速开发应用服务，将精力集中在业务上</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>jsp是在HTML中包含了java代码，所以本身包含可视化页面，更容易实现动态网页应用</td>\n<td>servlet内部更多地是各种逻辑层，没有可视化相关的内容，更适合做逻辑层、控制层等</td>\n</tr>\n<tr>\n<td>特点</td>\n<td>jsp侧重于可视化部分</td>\n<td>servlet侧重于逻辑控制部分</td>\n</tr>\n<tr>\n<td>诞生目的</td>\n<td>简化servlet的使用，使servlet跟HTML更好的结合起来，更好的实现java web应用</td>\n<td>为开发者提供java web应用服务开发的规范或者工具，提高开发者效率</td>\n</tr>\n</tbody></table>\n<h3 id=\"jsp-有哪些内置对象？作用分别是什么？\"><a href=\"#jsp-有哪些内置对象？作用分别是什么？\" class=\"headerlink\" title=\"jsp 有哪些内置对象？作用分别是什么？\"></a>jsp 有哪些内置对象？作用分别是什么？</h3><table>\n<thead>\n<tr>\n<th>jsp内置对象名称</th>\n<th>对应servlet类</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>request</td>\n<td>javax.servlet.http.HttpServletRequest</td>\n<td>client请求信息，http协议头信息、cookie、请求参数等</td>\n</tr>\n<tr>\n<td>response</td>\n<td>javax.servlet.http.HttpServletResponse</td>\n<td>server响应client请求，返回信息</td>\n</tr>\n<tr>\n<td>pageContent</td>\n<td>javax.servlet.jsp.PageContext</td>\n<td>页面上下文</td>\n</tr>\n<tr>\n<td>session</td>\n<td>javax.servlet.http.HttpSession</td>\n<td>client与server之间的会话</td>\n</tr>\n<tr>\n<td>application</td>\n<td>javax.servlet.ServletContext</td>\n<td>获取服务端应用生命周期信息</td>\n</tr>\n<tr>\n<td>out</td>\n<td>javax.servlet.jsp.JspWriter</td>\n<td>server给client传输内容的输出流</td>\n</tr>\n<tr>\n<td>config</td>\n<td>javax.servlet.ServletConfig</td>\n<td>初始化是，jsp引擎向jsp页面传递的信息</td>\n</tr>\n<tr>\n<td>page</td>\n<td>java.lang.Object</td>\n<td>指向jsp页面本身</td>\n</tr>\n<tr>\n<td>exception</td>\n<td>java.lang.Throwable</td>\n<td>页面异常对象</td>\n</tr>\n</tbody></table>\n<h3 id=\"说一下-jsp-的-4-种作用域？\"><a href=\"#说一下-jsp-的-4-种作用域？\" class=\"headerlink\" title=\"说一下 jsp 的 4 种作用域？\"></a>说一下 jsp 的 4 种作用域？</h3><ul>\n<li>作用域：即信息共享范围，类似于public、private这种</li>\n<li>四种作用域介绍：<table>\n<thead>\n<tr>\n<th>作用域范围</th>\n<th>信息传递类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>application：即服务启动到停止的时间</td>\n<td>ServletContext</td>\n</tr>\n<tr>\n<td>session：http会话开始到结束的时间</td>\n<td>session</td>\n</tr>\n<tr>\n<td>request：http请求到结束的时间</td>\n<td>request</td>\n</tr>\n<tr>\n<td>page：当前页面打开到关闭的时间</td>\n<td>pageContext</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"session-和-cookie-有什么区别？\"><a href=\"#session-和-cookie-有什么区别？\" class=\"headerlink\" title=\"session 和 cookie 有什么区别？\"></a>session 和 cookie 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>cookie</th>\n<th>session</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简介</td>\n<td>是放在client上给server端做相关逻辑使用的，server会在response中返给client，server可以对cookie进行读写，比如可以使用cookie来保存用户信息，以便于server端校验用户信息</td>\n<td>是放在server上，可以用来跟cookie的搭配做一些比如用户信息校验的逻辑</td>\n</tr>\n<tr>\n<td>存放位置</td>\n<td>client</td>\n<td>server</td>\n</tr>\n<tr>\n<td>容易</td>\n<td>较小</td>\n<td>较大</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>较差</td>\n<td>较强</td>\n</tr>\n</tbody></table>\n<h3 id=\"说一下-session-的工作原理？\"><a href=\"#说一下-session-的工作原理？\" class=\"headerlink\" title=\"说一下 session 的工作原理？\"></a>说一下 session 的工作原理？</h3><ul>\n<li>简要说明：用户注册之后生成session，然后保存到内存或者硬盘中，供cookie过来之后的校验</li>\n<li>举例：比如用户登录校验这种，用户登录成功后，server将待seesionId的cookie返回给client，当client发起新的请求时，将cookie发送给server，然后server使用cookie和seesion进行用户登录校验，比如可以匹配一下seesionId这种方式验证</li>\n</ul>\n<h3 id=\"如果客户端禁止-cookie-能实现-session-还能用吗？\"><a href=\"#如果客户端禁止-cookie-能实现-session-还能用吗？\" class=\"headerlink\" title=\"如果客户端禁止 cookie 能实现 session 还能用吗？\"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><ul>\n<li>当然能用，cookie只是一个保存信息的数据结构而已，我们可以自己设计另一个跟cookie功能一致的东西，办法很多，根据场景选择即可，比如此时client只保存一个sessionid给server做用户登录校验即可</li>\n</ul>\n<h3 id=\"spring-mvc-和-struts-的区别是什么？\"><a href=\"#spring-mvc-和-struts-的区别是什么？\" class=\"headerlink\" title=\"spring mvc 和 struts 的区别是什么？\"></a>spring mvc 和 struts 的区别是什么？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>spring mvc</th>\n<th>struts</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简介</td>\n<td>spring MVC是一个web开发框架，本质上相当于servlet，方便开发者更高效的开发web应用</td>\n<td>是一个web开发框架，基于servlet与MVC设计模式实现</td>\n</tr>\n<tr>\n<td>机制</td>\n<td>spring mvc的入口是servlet</td>\n<td>入口是filter</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>较好，基于方法设计，粒度更细</td>\n<td>较差，基于类设计，每收到一个请求，都会实例一个action</td>\n</tr>\n<tr>\n<td>参数传递</td>\n<td>形参传递，方法之间是独立的</td>\n<td>可以使用属性接收参数</td>\n</tr>\n<tr>\n<td>设计思想</td>\n<td>在servlet上进行拓展，AOP</td>\n<td>OOP</td>\n</tr>\n<tr>\n<td>开发效率</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>配置量</td>\n<td>接近0</td>\n<td>较多</td>\n</tr>\n<tr>\n<td>拦截器实现机制</td>\n<td>AOP方式，方法级别拦截</td>\n<td>自己的interceptor机制，类级别拦截</td>\n</tr>\n<tr>\n<td>Ajax支持</td>\n<td>继承了Ajax，使用@ResponseBody即可实现</td>\n<td>拦截器中继承了Ajax，在action中处理时必须安装插件或者写代码集成进去，使用较为不方便</td>\n</tr>\n<tr>\n<td>验证机制</td>\n<td>支持JSR303（一种参数校验规范），处理简单</td>\n<td>繁琐</td>\n</tr>\n</tbody></table>\n<h3 id=\"如何避免-sql-注入？\"><a href=\"#如何避免-sql-注入？\" class=\"headerlink\" title=\"如何避免 sql 注入？\"></a>如何避免 sql 注入？</h3><ul>\n<li>定义：输入数据中包含非法sql语句，且此sql语句被非法执行</li>\n<li>避免策略：<ul>\n<li>过滤输入内容，校验字符串</li>\n<li>参数化查询</li>\n<li>安全测试、安全审计（CR）</li>\n<li>避免使用动态sql</li>\n<li>数据库重要数据加密</li>\n<li>数据库权限控制</li>\n<li>避免数据库直接跟用户产生交互</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是-XSS-攻击，如何避免？\"><a href=\"#什么是-XSS-攻击，如何避免？\" class=\"headerlink\" title=\"什么是 XSS 攻击，如何避免？\"></a>什么是 XSS 攻击，如何避免？</h3><ul>\n<li>定义：又称CSS，全称Cross Site Script（跨站脚本攻击），即输入一段HTML来攻击应用</li>\n<li>避免策略：<ul>\n<li>对输入、输出进行过滤、转义处理</li>\n<li>对HTML标签、CSS属性复制的地方进行校验</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是-CSRF-攻击，如何避免？\"><a href=\"#什么是-CSRF-攻击，如何避免？\" class=\"headerlink\" title=\"什么是 CSRF 攻击，如何避免？\"></a>什么是 CSRF 攻击，如何避免？</h3><ul>\n<li>定义：全称Cross Site Request Forgery（跨站请求伪造），即攻击者盗用身份，发送恶意请求</li>\n<li>避免策略：<ul>\n<li>阻止不明外域访问，比如验证请求地址等策略</li>\n<li>关键操作添加验证码</li>\n<li>增加token、cookie校验策略</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"servlet是什么？\"><a href=\"#servlet是什么？\" class=\"headerlink\" title=\"servlet是什么？\"></a>servlet是什么？</h3><ul>\n<li>是一个java web应用服务器，servlet就是一个java官方封装好的HTTP应用服务器功能集合（也可以说规范，比如实现了识别http请求，复用TCP连接等底层操作），即是一个Java官方提供的HTTP服务器功能集合或者规范，方便我们基于此进行应用服务的开发，将精力集中在业务层的编码中即可</li>\n<li>诞生的原因或者目的：方便开发者快速开发java web服务，为java web服务提供一套规范</li>\n</ul>\n<h3 id=\"jsp是什么？\"><a href=\"#jsp是什么？\" class=\"headerlink\" title=\"jsp是什么？\"></a>jsp是什么？</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266262958498784\">参考文章</a></li>\n<li>是一个java web应用服务器，全称Java server Pages</li>\n<li>样子是一个html文件，然后里面内嵌着java代码，用来实现动态网页的开发，这种方式更适合前后端融合的形式，一个人编写比较方便</li>\n<li>用来开发动态网页应用的一种方式，静态网页之中包含java代码，以实现动态响应能力</li>\n<li>实际运行时会被编译成servlet，本质是servlet的另一种形式</li>\n</ul>\n<h3 id=\"Tomcat是什么？\"><a href=\"#Tomcat是什么？\" class=\"headerlink\" title=\"Tomcat是什么？\"></a>Tomcat是什么？</h3><ul>\n<li>Tomcat是集合了Servlet、JSP、Java WebSocket等多种网络服务功能的一个更大的java web 服务器，并且还具有可视化配置页面等功能</li>\n</ul>\n<h3 id=\"Apache是什么？\"><a href=\"#Apache是什么？\" class=\"headerlink\" title=\"Apache是什么？\"></a>Apache是什么？</h3><ul>\n<li>是一个web服务功能集合，全称Apache HTTP Server，只支持HTTP服务</li>\n</ul>\n<h3 id=\"Nginx是什么？\"><a href=\"#Nginx是什么？\" class=\"headerlink\" title=\"Nginx是什么？\"></a>Nginx是什么？</h3><ul>\n<li>一款轻量级web服务器，跟Apache核心功能类似，都是HTTP服务器，特点是更适合高并发场景等</li>\n</ul>\n<h3 id=\"正向代理、反向代理\"><a href=\"#正向代理、反向代理\" class=\"headerlink\" title=\"正向代理、反向代理\"></a>正向代理、反向代理</h3><ul>\n<li>正向代理：VPN即正向代理，即代理会真的替代客户端发请求，而非转发，此时客户端的请求是被整整替代的，所以正向代理，代理的是客户端</li>\n<li>反向代理：即代理只是转发请求，并没有代理客户端发请求，然后服务器响应，此时服务器被代理</li>\n<li>总结：正向代理，即客户端被代理的情况，反向代理是服务端被代理的情况</li>\n</ul>\n<h3 id=\"jsp-和-servlet-有什么区别？\"><a href=\"#jsp-和-servlet-有什么区别？\" class=\"headerlink\" title=\"jsp 和 servlet 有什么区别？\"></a>jsp 和 servlet 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>jsp</th>\n<th>servlet</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>本质</td>\n<td>jsp本质就是servlet，是servlet的一种简易实现方式，或者说是servlet的拓展，JVM只能识别java代码，是web服务器将jsp代码编译成java代码</td>\n<td>servlet是java官方提供你的一套http服务器功能集合，或者说一种http服务器规范，方便开发者快速开发应用服务，将精力集中在业务上</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>jsp是在HTML中包含了java代码，所以本身包含可视化页面，更容易实现动态网页应用</td>\n<td>servlet内部更多地是各种逻辑层，没有可视化相关的内容，更适合做逻辑层、控制层等</td>\n</tr>\n<tr>\n<td>特点</td>\n<td>jsp侧重于可视化部分</td>\n<td>servlet侧重于逻辑控制部分</td>\n</tr>\n<tr>\n<td>诞生目的</td>\n<td>简化servlet的使用，使servlet跟HTML更好的结合起来，更好的实现java web应用</td>\n<td>为开发者提供java web应用服务开发的规范或者工具，提高开发者效率</td>\n</tr>\n</tbody></table>\n<h3 id=\"jsp-有哪些内置对象？作用分别是什么？\"><a href=\"#jsp-有哪些内置对象？作用分别是什么？\" class=\"headerlink\" title=\"jsp 有哪些内置对象？作用分别是什么？\"></a>jsp 有哪些内置对象？作用分别是什么？</h3><table>\n<thead>\n<tr>\n<th>jsp内置对象名称</th>\n<th>对应servlet类</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>request</td>\n<td>javax.servlet.http.HttpServletRequest</td>\n<td>client请求信息，http协议头信息、cookie、请求参数等</td>\n</tr>\n<tr>\n<td>response</td>\n<td>javax.servlet.http.HttpServletResponse</td>\n<td>server响应client请求，返回信息</td>\n</tr>\n<tr>\n<td>pageContent</td>\n<td>javax.servlet.jsp.PageContext</td>\n<td>页面上下文</td>\n</tr>\n<tr>\n<td>session</td>\n<td>javax.servlet.http.HttpSession</td>\n<td>client与server之间的会话</td>\n</tr>\n<tr>\n<td>application</td>\n<td>javax.servlet.ServletContext</td>\n<td>获取服务端应用生命周期信息</td>\n</tr>\n<tr>\n<td>out</td>\n<td>javax.servlet.jsp.JspWriter</td>\n<td>server给client传输内容的输出流</td>\n</tr>\n<tr>\n<td>config</td>\n<td>javax.servlet.ServletConfig</td>\n<td>初始化是，jsp引擎向jsp页面传递的信息</td>\n</tr>\n<tr>\n<td>page</td>\n<td>java.lang.Object</td>\n<td>指向jsp页面本身</td>\n</tr>\n<tr>\n<td>exception</td>\n<td>java.lang.Throwable</td>\n<td>页面异常对象</td>\n</tr>\n</tbody></table>\n<h3 id=\"说一下-jsp-的-4-种作用域？\"><a href=\"#说一下-jsp-的-4-种作用域？\" class=\"headerlink\" title=\"说一下 jsp 的 4 种作用域？\"></a>说一下 jsp 的 4 种作用域？</h3><ul>\n<li>作用域：即信息共享范围，类似于public、private这种</li>\n<li>四种作用域介绍：<table>\n<thead>\n<tr>\n<th>作用域范围</th>\n<th>信息传递类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>application：即服务启动到停止的时间</td>\n<td>ServletContext</td>\n</tr>\n<tr>\n<td>session：http会话开始到结束的时间</td>\n<td>session</td>\n</tr>\n<tr>\n<td>request：http请求到结束的时间</td>\n<td>request</td>\n</tr>\n<tr>\n<td>page：当前页面打开到关闭的时间</td>\n<td>pageContext</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"session-和-cookie-有什么区别？\"><a href=\"#session-和-cookie-有什么区别？\" class=\"headerlink\" title=\"session 和 cookie 有什么区别？\"></a>session 和 cookie 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>cookie</th>\n<th>session</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简介</td>\n<td>是放在client上给server端做相关逻辑使用的，server会在response中返给client，server可以对cookie进行读写，比如可以使用cookie来保存用户信息，以便于server端校验用户信息</td>\n<td>是放在server上，可以用来跟cookie的搭配做一些比如用户信息校验的逻辑</td>\n</tr>\n<tr>\n<td>存放位置</td>\n<td>client</td>\n<td>server</td>\n</tr>\n<tr>\n<td>容易</td>\n<td>较小</td>\n<td>较大</td>\n</tr>\n<tr>\n<td>安全性</td>\n<td>较差</td>\n<td>较强</td>\n</tr>\n</tbody></table>\n<h3 id=\"说一下-session-的工作原理？\"><a href=\"#说一下-session-的工作原理？\" class=\"headerlink\" title=\"说一下 session 的工作原理？\"></a>说一下 session 的工作原理？</h3><ul>\n<li>简要说明：用户注册之后生成session，然后保存到内存或者硬盘中，供cookie过来之后的校验</li>\n<li>举例：比如用户登录校验这种，用户登录成功后，server将待seesionId的cookie返回给client，当client发起新的请求时，将cookie发送给server，然后server使用cookie和seesion进行用户登录校验，比如可以匹配一下seesionId这种方式验证</li>\n</ul>\n<h3 id=\"如果客户端禁止-cookie-能实现-session-还能用吗？\"><a href=\"#如果客户端禁止-cookie-能实现-session-还能用吗？\" class=\"headerlink\" title=\"如果客户端禁止 cookie 能实现 session 还能用吗？\"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><ul>\n<li>当然能用，cookie只是一个保存信息的数据结构而已，我们可以自己设计另一个跟cookie功能一致的东西，办法很多，根据场景选择即可，比如此时client只保存一个sessionid给server做用户登录校验即可</li>\n</ul>\n<h3 id=\"spring-mvc-和-struts-的区别是什么？\"><a href=\"#spring-mvc-和-struts-的区别是什么？\" class=\"headerlink\" title=\"spring mvc 和 struts 的区别是什么？\"></a>spring mvc 和 struts 的区别是什么？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>spring mvc</th>\n<th>struts</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>简介</td>\n<td>spring MVC是一个web开发框架，本质上相当于servlet，方便开发者更高效的开发web应用</td>\n<td>是一个web开发框架，基于servlet与MVC设计模式实现</td>\n</tr>\n<tr>\n<td>机制</td>\n<td>spring mvc的入口是servlet</td>\n<td>入口是filter</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>较好，基于方法设计，粒度更细</td>\n<td>较差，基于类设计，每收到一个请求，都会实例一个action</td>\n</tr>\n<tr>\n<td>参数传递</td>\n<td>形参传递，方法之间是独立的</td>\n<td>可以使用属性接收参数</td>\n</tr>\n<tr>\n<td>设计思想</td>\n<td>在servlet上进行拓展，AOP</td>\n<td>OOP</td>\n</tr>\n<tr>\n<td>开发效率</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>配置量</td>\n<td>接近0</td>\n<td>较多</td>\n</tr>\n<tr>\n<td>拦截器实现机制</td>\n<td>AOP方式，方法级别拦截</td>\n<td>自己的interceptor机制，类级别拦截</td>\n</tr>\n<tr>\n<td>Ajax支持</td>\n<td>继承了Ajax，使用@ResponseBody即可实现</td>\n<td>拦截器中继承了Ajax，在action中处理时必须安装插件或者写代码集成进去，使用较为不方便</td>\n</tr>\n<tr>\n<td>验证机制</td>\n<td>支持JSR303（一种参数校验规范），处理简单</td>\n<td>繁琐</td>\n</tr>\n</tbody></table>\n<h3 id=\"如何避免-sql-注入？\"><a href=\"#如何避免-sql-注入？\" class=\"headerlink\" title=\"如何避免 sql 注入？\"></a>如何避免 sql 注入？</h3><ul>\n<li>定义：输入数据中包含非法sql语句，且此sql语句被非法执行</li>\n<li>避免策略：<ul>\n<li>过滤输入内容，校验字符串</li>\n<li>参数化查询</li>\n<li>安全测试、安全审计（CR）</li>\n<li>避免使用动态sql</li>\n<li>数据库重要数据加密</li>\n<li>数据库权限控制</li>\n<li>避免数据库直接跟用户产生交互</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是-XSS-攻击，如何避免？\"><a href=\"#什么是-XSS-攻击，如何避免？\" class=\"headerlink\" title=\"什么是 XSS 攻击，如何避免？\"></a>什么是 XSS 攻击，如何避免？</h3><ul>\n<li>定义：又称CSS，全称Cross Site Script（跨站脚本攻击），即输入一段HTML来攻击应用</li>\n<li>避免策略：<ul>\n<li>对输入、输出进行过滤、转义处理</li>\n<li>对HTML标签、CSS属性复制的地方进行校验</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是-CSRF-攻击，如何避免？\"><a href=\"#什么是-CSRF-攻击，如何避免？\" class=\"headerlink\" title=\"什么是 CSRF 攻击，如何避免？\"></a>什么是 CSRF 攻击，如何避免？</h3><ul>\n<li>定义：全称Cross Site Request Forgery（跨站请求伪造），即攻击者盗用身份，发送恶意请求</li>\n<li>避免策略：<ul>\n<li>阻止不明外域访问，比如验证请求地址等策略</li>\n<li>关键操作添加验证码</li>\n<li>增加token、cookie校验策略</li>\n</ul>\n</li>\n</ul>\n"},{"title":"双等号、equals、hashCode区别","date":"2021-11-22T14:47:01.000Z","_content":"\n## 参考资料\n* [参考文章1](https://www.jianshu.com/p/5a7f5f786b75)\n\n## ==：判断的是两个变量对应的内存中的值是否相等\n* 基本数据类型比较值\n* 引用类型比较内存地址\n\n## equals：不重写时与\"==\"功能一致，其在Object方法列表中，可重写该方法\n* 特点：\n    * 重写需要遵循java对该方法重写的规范（对称性、反射性、类推性、一致性、非空性）\n    * 未重写时与\"==\"功能一致\n    * 当某个类要在散列表中使用时，重写该方法的同时必须重写hashCode方法，否则该方法无效\n\n## HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\n* 特点：\n    * 该方法在Object的方法，所以所有类都继承该方法\n    * 该方法只在该对象被散列表（例如HashMap、HaskTable、HashSet）所使用时，才会使用到该方法，其他情况下没用\n    * 该方法可以通过重写进行自定义\n    * 当同时使用到该方法和equals时，hashcode相等，但equals不一定相等，但equals相等，hashcode一定相等\n","source":"_posts/Q&A/Java/双等号、equals、hashCode区别.md","raw":"---\ntitle: 双等号、equals、hashCode区别\ndate: 2021-11-22 22:47:01\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## 参考资料\n* [参考文章1](https://www.jianshu.com/p/5a7f5f786b75)\n\n## ==：判断的是两个变量对应的内存中的值是否相等\n* 基本数据类型比较值\n* 引用类型比较内存地址\n\n## equals：不重写时与\"==\"功能一致，其在Object方法列表中，可重写该方法\n* 特点：\n    * 重写需要遵循java对该方法重写的规范（对称性、反射性、类推性、一致性、非空性）\n    * 未重写时与\"==\"功能一致\n    * 当某个类要在散列表中使用时，重写该方法的同时必须重写hashCode方法，否则该方法无效\n\n## HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\n* 特点：\n    * 该方法在Object的方法，所以所有类都继承该方法\n    * 该方法只在该对象被散列表（例如HashMap、HaskTable、HashSet）所使用时，才会使用到该方法，其他情况下没用\n    * 该方法可以通过重写进行自定义\n    * 当同时使用到该方法和equals时，hashcode相等，但equals不一定相等，但equals相等，hashcode一定相等\n","slug":"Q&A/Java/双等号、equals、hashCode区别","published":1,"updated":"2022-04-12T09:00:46.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0by003dwgtt68xac3g6","content":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/5a7f5f786b75\">参考文章1</a></li>\n</ul>\n<h2 id=\"：判断的是两个变量对应的内存中的值是否相等\"><a href=\"#：判断的是两个变量对应的内存中的值是否相等\" class=\"headerlink\" title=\"==：判断的是两个变量对应的内存中的值是否相等\"></a>==：判断的是两个变量对应的内存中的值是否相等</h2><ul>\n<li>基本数据类型比较值</li>\n<li>引用类型比较内存地址</li>\n</ul>\n<h2 id=\"equals：不重写时与”-”功能一致，其在Object方法列表中，可重写该方法\"><a href=\"#equals：不重写时与”-”功能一致，其在Object方法列表中，可重写该方法\" class=\"headerlink\" title=\"equals：不重写时与”==”功能一致，其在Object方法列表中，可重写该方法\"></a>equals：不重写时与”==”功能一致，其在Object方法列表中，可重写该方法</h2><ul>\n<li>特点：<ul>\n<li>重写需要遵循java对该方法重写的规范（对称性、反射性、类推性、一致性、非空性）</li>\n<li>未重写时与”==”功能一致</li>\n<li>当某个类要在散列表中使用时，重写该方法的同时必须重写hashCode方法，否则该方法无效</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\"><a href=\"#HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\" class=\"headerlink\" title=\"HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\"></a>HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置</h2><ul>\n<li>特点：<ul>\n<li>该方法在Object的方法，所以所有类都继承该方法</li>\n<li>该方法只在该对象被散列表（例如HashMap、HaskTable、HashSet）所使用时，才会使用到该方法，其他情况下没用</li>\n<li>该方法可以通过重写进行自定义</li>\n<li>当同时使用到该方法和equals时，hashcode相等，但equals不一定相等，但equals相等，hashcode一定相等</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/5a7f5f786b75\">参考文章1</a></li>\n</ul>\n<h2 id=\"：判断的是两个变量对应的内存中的值是否相等\"><a href=\"#：判断的是两个变量对应的内存中的值是否相等\" class=\"headerlink\" title=\"==：判断的是两个变量对应的内存中的值是否相等\"></a>==：判断的是两个变量对应的内存中的值是否相等</h2><ul>\n<li>基本数据类型比较值</li>\n<li>引用类型比较内存地址</li>\n</ul>\n<h2 id=\"equals：不重写时与”-”功能一致，其在Object方法列表中，可重写该方法\"><a href=\"#equals：不重写时与”-”功能一致，其在Object方法列表中，可重写该方法\" class=\"headerlink\" title=\"equals：不重写时与”==”功能一致，其在Object方法列表中，可重写该方法\"></a>equals：不重写时与”==”功能一致，其在Object方法列表中，可重写该方法</h2><ul>\n<li>特点：<ul>\n<li>重写需要遵循java对该方法重写的规范（对称性、反射性、类推性、一致性、非空性）</li>\n<li>未重写时与”==”功能一致</li>\n<li>当某个类要在散列表中使用时，重写该方法的同时必须重写hashCode方法，否则该方法无效</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\"><a href=\"#HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\" class=\"headerlink\" title=\"HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置\"></a>HashCode：获取哈希码（散列码，为了提升散列表查找性能），该哈希码作用是确定该对象在哈希表中索引位置</h2><ul>\n<li>特点：<ul>\n<li>该方法在Object的方法，所以所有类都继承该方法</li>\n<li>该方法只在该对象被散列表（例如HashMap、HaskTable、HashSet）所使用时，才会使用到该方法，其他情况下没用</li>\n<li>该方法可以通过重写进行自定义</li>\n<li>当同时使用到该方法和equals时，hashcode相等，但equals不一定相等，但equals相等，hashcode一定相等</li>\n</ul>\n</li>\n</ul>\n"},{"title":"反射","date":"2022-03-24T11:17:28.000Z","_content":"\n### 什么是反射？\n* 定义：即Reflection，意思是在程序运行期间拿到对象的所有信息\n* 作用：为了解决在运行期间，对某个对象一无所知的情况下，调用其方法\n\n### 什么是 java 序列化？什么情况下需要序列化？\n* 名词定义：\n  * 序列化：将java对象转换成字节流的过程\n  * 反序列化：将字节流转换成java对象的过程\n* 序列化场景：\n  * 将java对象持久化\n  * 在网络中传输java对象\n\n### 动态代理是什么？有哪些应用？\n* [参考文章](https://www.yukx.com/jing/article/details/1453.html)\n* 代理：代理类与委托类具有相同接口，即代理类需要实现委托类规定的接口，跟OC delegate一样，代理类按照委托类的规定做一些预处理，事后处理等操作\n* 代理分类：\n  * 静态代理：使用自己创建的特定代理类，即需要实际编写代理类，在编译器就确定好代理类的情况\n  * 动态代理：运行时动态创建代理类，实现只需要编写好某个被代理方法的处理逻辑即可\n* 应用场景：\n  * 编写一些三方工具库，比如spring AOP、RPC\n  * 想在已有行为执行前后添加逻辑\n\n\n### 怎么实现动态代理？\n* 实现过程（以示例举例）：\n  1、创建接口类（Person接口）、被代理类（Student）、被代理方法处理类（StuInvocationHandler<T>，该类中加入新增逻辑），\n  2、创建一个被代理对象，创建被代理方法处理类的对象，然后使用该对象创建一个代理对象，然后使用代理对象调用代理方法即可\n\n\n* 代码示例：\n```\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class MyTest {\n\n\n    /** * 创建Person接口\n     * @author Gonjan\n     */\n    public interface Person {\n        //上交班费\n        void giveMoney();\n    }\n\n    public class Student implements Person {\n        private String name;\n        public Student(String name) {\n            this.name = name;\n        }\n        @Override\n        public void giveMoney() {\n            System.out.println(name + \"上交班费50元\");\n        }\n    }\n\n    public class StuInvocationHandler<T> implements InvocationHandler {\n        //invocationHandler持有的被代理对象\n        T target;\n        public StuInvocationHandler(T target) {\n            this.target = target;\n        }\n        /**\n         * proxy:代表动态代理对象\n         * method：代表正在执行的方法\n         * args：代表调用目标方法时传入的实参\n         */\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println(\"代理执行\" +method.getName() + \"方法\");\n            //代理过程中插入监测方法,计算该方法耗时\n            System.out.println(\"我是在被代理方法执行前的部分\");\n            Object result = method.invoke(target, args);\n            System.out.println(\"我是在被代理方法执行后的部分\");\n            return result;\n        }\n    }\n\n\n    @Test\n    public void testMyCode() {\n        //创建一个实例对象，这个对象是被代理的对象\n        Person zhangsan = new Student(\"张三\");\n        //创建一个与代理对象相关联的InvocationHandler\n        InvocationHandler stuHandler = new StuInvocationHandler<Person>(zhangsan);\n        //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法\n        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),\n                new Class<?>[]{Person.class}, stuHandler);\n        //代理执行上交班费的方法\n        stuProxy.giveMoney();\n    }\n}\n\n```\n","source":"_posts/Q&A/Java/反射.md","raw":"---\ntitle: 反射\ndate: 2022-03-24 19:17:28\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n### 什么是反射？\n* 定义：即Reflection，意思是在程序运行期间拿到对象的所有信息\n* 作用：为了解决在运行期间，对某个对象一无所知的情况下，调用其方法\n\n### 什么是 java 序列化？什么情况下需要序列化？\n* 名词定义：\n  * 序列化：将java对象转换成字节流的过程\n  * 反序列化：将字节流转换成java对象的过程\n* 序列化场景：\n  * 将java对象持久化\n  * 在网络中传输java对象\n\n### 动态代理是什么？有哪些应用？\n* [参考文章](https://www.yukx.com/jing/article/details/1453.html)\n* 代理：代理类与委托类具有相同接口，即代理类需要实现委托类规定的接口，跟OC delegate一样，代理类按照委托类的规定做一些预处理，事后处理等操作\n* 代理分类：\n  * 静态代理：使用自己创建的特定代理类，即需要实际编写代理类，在编译器就确定好代理类的情况\n  * 动态代理：运行时动态创建代理类，实现只需要编写好某个被代理方法的处理逻辑即可\n* 应用场景：\n  * 编写一些三方工具库，比如spring AOP、RPC\n  * 想在已有行为执行前后添加逻辑\n\n\n### 怎么实现动态代理？\n* 实现过程（以示例举例）：\n  1、创建接口类（Person接口）、被代理类（Student）、被代理方法处理类（StuInvocationHandler<T>，该类中加入新增逻辑），\n  2、创建一个被代理对象，创建被代理方法处理类的对象，然后使用该对象创建一个代理对象，然后使用代理对象调用代理方法即可\n\n\n* 代码示例：\n```\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class MyTest {\n\n\n    /** * 创建Person接口\n     * @author Gonjan\n     */\n    public interface Person {\n        //上交班费\n        void giveMoney();\n    }\n\n    public class Student implements Person {\n        private String name;\n        public Student(String name) {\n            this.name = name;\n        }\n        @Override\n        public void giveMoney() {\n            System.out.println(name + \"上交班费50元\");\n        }\n    }\n\n    public class StuInvocationHandler<T> implements InvocationHandler {\n        //invocationHandler持有的被代理对象\n        T target;\n        public StuInvocationHandler(T target) {\n            this.target = target;\n        }\n        /**\n         * proxy:代表动态代理对象\n         * method：代表正在执行的方法\n         * args：代表调用目标方法时传入的实参\n         */\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println(\"代理执行\" +method.getName() + \"方法\");\n            //代理过程中插入监测方法,计算该方法耗时\n            System.out.println(\"我是在被代理方法执行前的部分\");\n            Object result = method.invoke(target, args);\n            System.out.println(\"我是在被代理方法执行后的部分\");\n            return result;\n        }\n    }\n\n\n    @Test\n    public void testMyCode() {\n        //创建一个实例对象，这个对象是被代理的对象\n        Person zhangsan = new Student(\"张三\");\n        //创建一个与代理对象相关联的InvocationHandler\n        InvocationHandler stuHandler = new StuInvocationHandler<Person>(zhangsan);\n        //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法\n        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),\n                new Class<?>[]{Person.class}, stuHandler);\n        //代理执行上交班费的方法\n        stuProxy.giveMoney();\n    }\n}\n\n```\n","slug":"Q&A/Java/反射","published":1,"updated":"2022-04-12T09:00:46.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0bz003hwgtt4b7jb8cn","content":"<h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><ul>\n<li>定义：即Reflection，意思是在程序运行期间拿到对象的所有信息</li>\n<li>作用：为了解决在运行期间，对某个对象一无所知的情况下，调用其方法</li>\n</ul>\n<h3 id=\"什么是-java-序列化？什么情况下需要序列化？\"><a href=\"#什么是-java-序列化？什么情况下需要序列化？\" class=\"headerlink\" title=\"什么是 java 序列化？什么情况下需要序列化？\"></a>什么是 java 序列化？什么情况下需要序列化？</h3><ul>\n<li>名词定义：<ul>\n<li>序列化：将java对象转换成字节流的过程</li>\n<li>反序列化：将字节流转换成java对象的过程</li>\n</ul>\n</li>\n<li>序列化场景：<ul>\n<li>将java对象持久化</li>\n<li>在网络中传输java对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动态代理是什么？有哪些应用？\"><a href=\"#动态代理是什么？有哪些应用？\" class=\"headerlink\" title=\"动态代理是什么？有哪些应用？\"></a>动态代理是什么？有哪些应用？</h3><ul>\n<li><a href=\"https://www.yukx.com/jing/article/details/1453.html\">参考文章</a></li>\n<li>代理：代理类与委托类具有相同接口，即代理类需要实现委托类规定的接口，跟OC delegate一样，代理类按照委托类的规定做一些预处理，事后处理等操作</li>\n<li>代理分类：<ul>\n<li>静态代理：使用自己创建的特定代理类，即需要实际编写代理类，在编译器就确定好代理类的情况</li>\n<li>动态代理：运行时动态创建代理类，实现只需要编写好某个被代理方法的处理逻辑即可</li>\n</ul>\n</li>\n<li>应用场景：<ul>\n<li>编写一些三方工具库，比如spring AOP、RPC</li>\n<li>想在已有行为执行前后添加逻辑</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"怎么实现动态代理？\"><a href=\"#怎么实现动态代理？\" class=\"headerlink\" title=\"怎么实现动态代理？\"></a>怎么实现动态代理？</h3><ul>\n<li>实现过程（以示例举例）：<br>1、创建接口类（Person接口）、被代理类（Student）、被代理方法处理类（StuInvocationHandler<T>，该类中加入新增逻辑），<br>2、创建一个被代理对象，创建被代理方法处理类的对象，然后使用该对象创建一个代理对象，然后使用代理对象调用代理方法即可</li>\n</ul>\n<ul>\n<li>代码示例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.junit.jupiter.api.Test;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.reflect.InvocationHandler;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /** * 创建Person接口</span><br><span class=\"line\">     * @author Gonjan</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public interface Person &#123;</span><br><span class=\"line\">        //上交班费</span><br><span class=\"line\">        void giveMoney();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class Student implements Person &#123;</span><br><span class=\"line\">        private String name;</span><br><span class=\"line\">        public Student(String name) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void giveMoney() &#123;</span><br><span class=\"line\">            System.out.println(name + &quot;上交班费50元&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123;</span><br><span class=\"line\">        //invocationHandler持有的被代理对象</span><br><span class=\"line\">        T target;</span><br><span class=\"line\">        public StuInvocationHandler(T target) &#123;</span><br><span class=\"line\">            this.target = target;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * proxy:代表动态代理对象</span><br><span class=\"line\">         * method：代表正在执行的方法</span><br><span class=\"line\">         * args：代表调用目标方法时传入的实参</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">            System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;);</span><br><span class=\"line\">            //代理过程中插入监测方法,计算该方法耗时</span><br><span class=\"line\">            System.out.println(&quot;我是在被代理方法执行前的部分&quot;);</span><br><span class=\"line\">            Object result = method.invoke(target, args);</span><br><span class=\"line\">            System.out.println(&quot;我是在被代理方法执行后的部分&quot;);</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testMyCode() &#123;</span><br><span class=\"line\">        //创建一个实例对象，这个对象是被代理的对象</span><br><span class=\"line\">        Person zhangsan = new Student(&quot;张三&quot;);</span><br><span class=\"line\">        //创建一个与代理对象相关联的InvocationHandler</span><br><span class=\"line\">        InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class=\"line\">        //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span><br><span class=\"line\">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),</span><br><span class=\"line\">                new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br><span class=\"line\">        //代理执行上交班费的方法</span><br><span class=\"line\">        stuProxy.giveMoney();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><ul>\n<li>定义：即Reflection，意思是在程序运行期间拿到对象的所有信息</li>\n<li>作用：为了解决在运行期间，对某个对象一无所知的情况下，调用其方法</li>\n</ul>\n<h3 id=\"什么是-java-序列化？什么情况下需要序列化？\"><a href=\"#什么是-java-序列化？什么情况下需要序列化？\" class=\"headerlink\" title=\"什么是 java 序列化？什么情况下需要序列化？\"></a>什么是 java 序列化？什么情况下需要序列化？</h3><ul>\n<li>名词定义：<ul>\n<li>序列化：将java对象转换成字节流的过程</li>\n<li>反序列化：将字节流转换成java对象的过程</li>\n</ul>\n</li>\n<li>序列化场景：<ul>\n<li>将java对象持久化</li>\n<li>在网络中传输java对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动态代理是什么？有哪些应用？\"><a href=\"#动态代理是什么？有哪些应用？\" class=\"headerlink\" title=\"动态代理是什么？有哪些应用？\"></a>动态代理是什么？有哪些应用？</h3><ul>\n<li><a href=\"https://www.yukx.com/jing/article/details/1453.html\">参考文章</a></li>\n<li>代理：代理类与委托类具有相同接口，即代理类需要实现委托类规定的接口，跟OC delegate一样，代理类按照委托类的规定做一些预处理，事后处理等操作</li>\n<li>代理分类：<ul>\n<li>静态代理：使用自己创建的特定代理类，即需要实际编写代理类，在编译器就确定好代理类的情况</li>\n<li>动态代理：运行时动态创建代理类，实现只需要编写好某个被代理方法的处理逻辑即可</li>\n</ul>\n</li>\n<li>应用场景：<ul>\n<li>编写一些三方工具库，比如spring AOP、RPC</li>\n<li>想在已有行为执行前后添加逻辑</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"怎么实现动态代理？\"><a href=\"#怎么实现动态代理？\" class=\"headerlink\" title=\"怎么实现动态代理？\"></a>怎么实现动态代理？</h3><ul>\n<li>实现过程（以示例举例）：<br>1、创建接口类（Person接口）、被代理类（Student）、被代理方法处理类（StuInvocationHandler<T>，该类中加入新增逻辑），<br>2、创建一个被代理对象，创建被代理方法处理类的对象，然后使用该对象创建一个代理对象，然后使用代理对象调用代理方法即可</li>\n</ul>\n<ul>\n<li>代码示例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.junit.jupiter.api.Test;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.reflect.InvocationHandler;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /** * 创建Person接口</span><br><span class=\"line\">     * @author Gonjan</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public interface Person &#123;</span><br><span class=\"line\">        //上交班费</span><br><span class=\"line\">        void giveMoney();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class Student implements Person &#123;</span><br><span class=\"line\">        private String name;</span><br><span class=\"line\">        public Student(String name) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void giveMoney() &#123;</span><br><span class=\"line\">            System.out.println(name + &quot;上交班费50元&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class StuInvocationHandler&lt;T&gt; implements InvocationHandler &#123;</span><br><span class=\"line\">        //invocationHandler持有的被代理对象</span><br><span class=\"line\">        T target;</span><br><span class=\"line\">        public StuInvocationHandler(T target) &#123;</span><br><span class=\"line\">            this.target = target;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * proxy:代表动态代理对象</span><br><span class=\"line\">         * method：代表正在执行的方法</span><br><span class=\"line\">         * args：代表调用目标方法时传入的实参</span><br><span class=\"line\">         */</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class=\"line\">            System.out.println(&quot;代理执行&quot; +method.getName() + &quot;方法&quot;);</span><br><span class=\"line\">            //代理过程中插入监测方法,计算该方法耗时</span><br><span class=\"line\">            System.out.println(&quot;我是在被代理方法执行前的部分&quot;);</span><br><span class=\"line\">            Object result = method.invoke(target, args);</span><br><span class=\"line\">            System.out.println(&quot;我是在被代理方法执行后的部分&quot;);</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testMyCode() &#123;</span><br><span class=\"line\">        //创建一个实例对象，这个对象是被代理的对象</span><br><span class=\"line\">        Person zhangsan = new Student(&quot;张三&quot;);</span><br><span class=\"line\">        //创建一个与代理对象相关联的InvocationHandler</span><br><span class=\"line\">        InvocationHandler stuHandler = new StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class=\"line\">        //创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span><br><span class=\"line\">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),</span><br><span class=\"line\">                new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br><span class=\"line\">        //代理执行上交班费的方法</span><br><span class=\"line\">        stuProxy.giveMoney();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"多线程","date":"2022-01-17T12:40:20.000Z","_content":"\n### 并行和并发有什么区别？\n#### 并发：\n* 在操作系统中，一个时间段内在同一个处理机上处于开始到结束之间的多个任务之间的状态，window的时间片分时调度即并发，实际是串行，但是多个任务在不停地切换，每个任务运行一小会，以实现多个任务的同时运行即并发\n\n#### 并行：\n* 互不抢占资源的两个任务同时运行时，即并行\n\n#### 区别：\n* 并发实际上是串行\n* 并发需要共享运算资源，并行不需要\n* 单cpu可以实现并发，但不能实现并行\n* 并行是真正的同时运行\n\n\n### 线程和进程的区别？\n#### 线程：\n* 是进程的子任务\n* 是操作系统可识别的最小执行和调度单位\n* 是CPU调度和分配的基本单位\n\n#### 进程：\n* 是对运行时程序的封装\n* 是系统进行资源调度和分配的基本单位\n\n#### 区别：\n* 一个线程只能属于一个进程，一个进程可以包含多个线程，且至少有一个线程\n* 进程用友独立的内存单元，多个线程共享这部分内存\n* 进程是资源分配的最小单位，线程是cpu调度的最小单位\n* 创建、撤销、切换等操作，进程的开销要远大于线程\n* 线程间可以使用共享内存进行通信，实现起来较简单，进程间通信实现较复杂，进程间通信依赖线程\n* 进程间互相不会影响，线程挂掉时会导致整个进程挂掉\n\n### 进程间通信方式？\n* 管道：\n  * 匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系\n  * 高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。\n  * 有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信\n* 消息队列\n* 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n* 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生\n* 共享内存：\n* 套接字\n\n### 线程间通信方式？\n* 各种锁：互斥锁\n* 信号量：\n* 信号：\n* 进程间通信也能用于线程间通信，进程间通信本质上都是线程在干活\n\n### 守护线程是什么？\n#### 定义:\n* 为其他线程服务的线程，比如垃圾回收线程\n\n#### 特点：\n* JVM结束进程时，不关心守护线程，但是用户线程存在的话，JVM不会结束进程\n* 守护线程不能持有任何需要关闭的资源，进程结束时会导致该资源出错\n* 守护线程优先级低，守护线程中创建的新线程同样是守护线程，用户线程同样，其中创建的新线程也是用户线程\n\n### 线程分类?\n#### 按照是否为用户自定义来区分\n* 守护线程\n* 用户线程\n\n### 创建线程有哪几种方式？\n* 本质上都是一样的，都需要new thread\n* 继承Thread类，重写run方法\n* 通过实现Runnable接口中的run方法\n* 通过实现Callable接口中的call方法，然后使用FutureTask进行调用\n```\n    @Test\n    public void testCode() throws ExecutionException, InterruptedException {\n        FutureTask<Integer> futureTask = new FutureTask<>(new TestThread());\n        new Thread(futureTask).start();\n        Integer result = futureTask.get();\n        System.out.println(result);\n    }\n\n    class TestThread implements Callable<Integer> {\n\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(\"啦啦啦啦\");\n            return 1;\n        }\n    }\n```\n* 通过线程池创建线程：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式\n  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限\n  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限\n  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务\n  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程\n\n\n### 说一下 runnable 和 callable 有什么区别？\n* 相同点：\n  * 都是接口\n  * 都可以实现多线程\n  * 都采用thread.start启动\n* 不同：\n  * Runnable的run方法没有返回值，Callable的call方法可以自定义返回值\n  * Runnable的run方法只能抛出运行时一场，且无法捕获，Callable的run方法允许抛出异常，且可以捕获\n  * Executor使用Runnable使用execute方法，使用Callable时使用submit方法\n\n### 线程有哪些状态？\n* new：创建\n* Runnable：运行中，正在执行run方法\n* Blocked： 运行中，因被阻塞而挂起\n* Waiting：运行中，因为某些操作在等待中，join方法会阻塞当前线程，等待该线程对象执行完成，如果已完成，就立即返回\n* Timed Waiting：运行中，因为执行sleep，在计时等待\n* Terminated：终止，run方法执行完毕或调用Thread的stop\n\n### sleep() 和 wait() 有什么区别？\n* 调用方面：\n  * sleep是静态方法，wait是实例方法\n  * wait只能在同步情况下调用，sleep不需要\n  * wait是用于线程间通信的，sleep是用于当前线程\n* 锁及资源：\n  * 线程进入wait状态时会释放持有的对象锁，但sleep不会\n  * 进入wait状态的线程使用notify和notifyAll可以再次唤醒，进入sleep状态的线程不能被唤醒\n* 异常捕获：\n  * sleep需要捕获或者抛出异常，wait/notify/notifyAll不需要\n\n### notify()和 notifyAll()有什么区别？\n* notify唤醒对象的等待池中的一个线程进入锁池，notifyAll唤醒等待池中的所有线程进入锁池\n* 等待池：线程A调用了对象o的wait方法，A就会释放o的锁，进入o的等待池，等待池中的线程不会竞争o的锁\n* 锁池：获取了对象o的锁，才能执行synchronized代码，同一时间内，只有一个线程可以获得该锁，其他线程只能在锁池中等待，锁池中的线程会竞争对象锁，等待池中的线程不会\n\n### 线程的 run()和 start()有什么区别？\n* run里面是线程需要计算的内容，start就是创建新线程然后调用一下run，基于此区别自己说就好了\n\n### 创建线程池有哪几种方式？\n* 使用Executors创建线程池：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式\n  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限\n  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限\n  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务\n  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程\n* 通过ThreadPoolExecutor创建自定义线程池\n\n### 线程池都有哪些状态？\n* running：接收新任务，处理队列任务\n* shutdown：停止接收新任务，处理队列任务\n* stop：停止接收新任务，停止处理队列任务，停止正在处理的任务\n* tidying：所有任务被终结，有效线程为0，会触发terminated方法\n* terminated：当terminated执行结束，销毁状态\n\n### 线程池中 submit()和 execute()方法有什么区别？\n* 同\n  * 都是线程池的方法\n* 异\n  * execute只能传入Runnable任务，submit可以传入Runnable和Callable任务\n  * execute会直接抛出异常，submit会吃掉异常，但是可以通过future的get方法将异常重新抛出\n  * execute所属顶层接口是Executor，submit所属顶层接口是ExecutorService\n\n### 在 java 程序中怎么保证多线程的运行安全？\n* 保证安全需要遵守的特性：\n  * 原子性：一个或者多个操作在CPU执行的过程中不被中断的特性\n  * 可见性：一个线程对共享变量的修改，另一个线程能立刻看到\n  * 有序性：程序按照代码顺序进行执行\n* 安全隐患：\n  * 缓存对可见性的影响\n  * 线程切换导致CPU执行终端，对原子性的影响\n  * 编译优化带来的有序性问题\n* 解决方案：\n  * JDK Atomic开头的原子类、synchronized、lock，可解决原子性问题\n  * synchronized、volatile、lock可以解决可见性问题\n  * Happen-before可解决有序性问题\n* Happen-before：\n  * 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作发生早于后面的操作\n  * 管道锁定规则：unlock操作发生遭遇后面对同一个锁的lock操作\n  * volatile规则：对一个变量的写操作早于后面的读操作\n  * 线程启动规则：Thread的start操作早于线程的任何其他行为\n  * 线程终止规则：Thread的销毁操作发生与线程的所有其他行为之后\n  * 线程中断规则：对线程的interrupt的调用发生于被中断线程的代码检测到中断之前\n  * 对象销毁规则：对象的初始化完成、构造完成早于销毁\n\n### 多线程锁的升级原理是什么？\n* [参考文章](https://www.cnblogs.com/jxxblogs/p/11890563.html)\n* 锁分级原因：降低资源消耗，没有优化之前，synchronized是重量级锁（悲观锁），wait、notify、notifyAll切换线程状态非常消耗资源，而线程的挂起和唤醒时间很短，这样会导致浪费资源，影响应能，所以JVM对synchronized进行了优化，把锁分成了无锁、偏向锁、轻量级锁、重量级锁\n  * 切换原因：当JVM检测到不同的竞争状态时，会根据需要自动切换到合适的锁\n  * 特点：只能从低到高，不能从高到低\n  * 位置：对象头的Mark Word里\n\n\n* CAS：compareAndSwap，比较并替换\n  * CAS包含三个操作数：内存地址V、预期值A、即将更新的目标值B\n  * 使用场景：当一个线程要修改某个变量的值时，发现被其他线程修改过了，此时就会放弃修改，实现逻辑加锁\n  * 特点：逻辑上避免加锁\n  * 作用：比较并替换\n\n\n* 锁级别从低到高：无锁->偏向锁->轻量级锁->重量级锁\n  * 无锁：不对资源进行锁定，所有线程都可以同时读写同一资源、但只有一个线程可以成功，其他线程需要不断重试才能成功\n  * 偏向锁：对象代码一致被同一线程执行，不存在多个线程竞争，该线程在后续执行中自动获取锁，降低获取锁带来的性能开销。偏向指的就是偏向第一个加锁线程，该线程不会主动释放锁，当其他线程尝试竞争偏向锁时才会被释放。\n    * 撤销：在没有字节码执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否被锁定，如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，如果线程处于活跃状态，就升级为轻量级锁\n  * 轻量级锁：当对象锁时偏向锁，且对象被第二个线程访问时，此时偏向锁会升级为轻量级锁，第二个线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。\n    * 升级重量级锁1：当只有一个等待线程时，该线程会通过自旋进行等待，但是当自旋超过一定次数时，轻量级锁会升级成重量级锁\n    * 升级重量级锁2：当一个线程持有锁，另一个线程在自旋等待，此时再有一个线程来访问时，轻量级锁会升级为重量级锁\n  * 重量级锁：当一个线程获取锁之后，其余所有等待线程都处于阻塞状态\n    * 实现：重量级锁通过对象内的监视器（monitor）实现，monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户状态切换为内核态，切换成本很高\n  * synchronized优化之锁消除：编译时对上线文进行扫描，去除不可能存在共享资源竞争的锁，消除没必要的锁，节约资源\n\n\n* 锁升级过程：\n\n|  |  | |\n| -------- | --------- | ----------- |\n| 默认无锁，当程序执行到同步块时，***判断对象头中保存的threadId是否是当前线程*** |\n| 是：该线程获得偏向锁，此时不需要CAS来加、撤销锁，偏向锁是最简单的线程锁，适合某线程频繁访问同一对象场景 | 否：***判断偏向锁标识*** |\n| | 0：即无锁状态，此时需使用CAS竞争锁 | 1：即偏向锁状态，使用CAS将对象头中的锁信息指向当前线程，并触发偏向锁撤销（有竞争才会有偏向锁撤销）|\n| 当其它线程尝试竞争偏向锁，且程序到达全局安全点（即无正在运行代码），此时JVM会***判断对象头中记录的线程是否存活*** |\n| 未存活：对象被重置为无锁状态，其他线程可竞争偏向锁 | 存活：查找该线程栈帧信息，***判断是否需要继续持有该对象*** |\n|| 需要：暂停该线程，撤销偏向锁，升级为轻量级锁 | 不需要：将该对象设置为无锁状态，其他线程可竞争偏向锁 |\n|| 轻量级锁：当有多个线程竞争一个偏向锁时，会频繁产生偏向锁撤销，此时JVM会将对象头中的锁标识升级为轻量级锁，多个线程通过自旋来继续获取锁 |\n|| 重量级锁：有多个线程通过自旋获取锁，进入到非常激烈状态时，会非常消耗cpu资源，当自旋达到一定次数时（轻量级切换重量级的判断逻辑），JVM会将轻量级锁升级为重量级锁，重量级锁当获取锁失败时会让线程阻塞，重量级锁缺点是线程会频繁进行上下文切换 |\n\n\n\n\n* 锁比较：\n\n\n  |         | 偏向锁       | 轻量级锁         | 重量级锁            |\n  | ------------ | ----------- | -------------- | ------------------ |\n  | 使用场景      | 一个同步代码块只有一个线程频繁访问 | 多条线程进入同步块，线程进入时间错开因而并未争抢 | 发生了争抢，多个线程进入同步块并竞争锁 |\n  | 本质 | 取消同步操作 | CAS操作代替互斥同步 | 互斥同步 |\n  | 优点 | 不阻塞，执行效率高 (不需要使用CAS来获取锁和撤销锁，只需要对比threadId，效率高) | 不会阻塞 | 不会空耗cpu |\n  | 缺点 | 使用场景局限，若竞争产生，会有偏向锁撤销的消耗 | 长时间获取不到会空耗cpu | 阻塞，上下文切换，重量级操作，消耗系统资源 |\n\n\n\n### 什么是死锁？\n#### 线程死锁\n* 定义：两个及以上的线程因为互相等待而被阻塞的现象即死锁\n* 死锁示例：两个线程互相等待对方持有的锁，即死锁\n  ```\n  public void add(int m) {\n    synchronized(lockA) { // 获得lockA的锁\n        this.value += m;\n        synchronized(lockB) { // 获得lockB的锁\n            this.another += m;\n        } // 释放lockB的锁\n    } // 释放lockA的锁\n}\n\npublic void dec(int m) {\n    synchronized(lockB) { // 获得lockB的锁\n        this.another -= m;\n        synchronized(lockA) { // 获得lockA的锁\n            this.value -= m;\n        } // 释放lockA的锁\n    } // 释放lockB的锁\n}\n  ```\n* 导致死锁的原因：\n  * 已持有锁的线程请求新锁\n  * 两个及以上的线程同时发出新锁请求\n  * 两个及以上的线程形成一个新锁申请循环链，每个线程都在等待链中下一个线程持有的锁\n* 分类：\n  * 潜在死锁：不一定发生，但可能在程序运行的任何阶段发生\n  * 实际死锁：程序执行过程中的死锁，实际死锁会导致线程挂起，但进程不一定挂起\n* java线程锁是可重入锁，即同一个锁可以被同一线程多次获取到，线程对锁有记录，获取到加1，完成代码块减一，减到0时，释放锁\n  * 例：\n  ```\n  public class Counter {\n    private int count = 0;\n\n    public synchronized void add(int n) {\n        if (n < 0) {\n            dec(-n);\n        } else {\n            count += n;\n        }\n    }\n\n    public synchronized void dec(int n) {\n        count += n;\n    }\n}\n  ```\n#### 进程死锁\n* 定义：进程竞争共享资源时出现的无线循环等待问题\n* 产生进程死锁必要条件：\n  * 互斥条件：共享资源单位时间内只能被一个进程占有\n  * 不可抢占条件：某进程占有的资源未使用完之前，其他进程不得抢夺\n  * 占有且申请条件：进程已占用的资源，在申请新资源时，仍继续占有已占有资源\n  * 循环等待条件：存在一个循环等待环，第一个依赖第二个，第n个依赖第1个\n* 预防死锁：打破产生的四个条件之中的一个或多个\n\n### 怎么防止死锁？\n* 规避四个产生条件来设计代码，以避免\n\n\n#### 避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\n* [参考文章1](https://blog.csdn.net/qq_33414271/article/details/80245715)\n[参考文章2](https://baike.baidu.com/item/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1679781)\n* 安全状态：某一时刻，某进程序列中的进程都可以顺利完成，则此时状态为安全状态，系统中安全状态与不安全状态是共存的，安全状态一定不死锁，不安全状态不一定会死锁\n* 安全状态检测：系统先尝试分配资源给申请进程，然后使用剩余资源计算是否能满足进程队列中的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态，如果有进程都可以执行完毕，然后假设回收资源后，也可以让其他所有进程队列中的进程都执行完毕，则系统处于安全状态，然后会根据分配顺序生成安全序列，然后执行\n* 判断某个状态是否安全：根据安全性算法进行计算，如果可以找到某种安全序列即安全\n* 判断某个请求系统是否可满足：根据安全性算法进行检查，如果分配后剩余的资源无法满足进程队列中的任一进程需求的话，即不能分配，否则可分配\n\n### ThreadLocal 是什么？有哪些使用场景？\n* ThreadLocal：线程本地存储，每个线程中都会有一个ThreadLcoalMap对象，用来保存各种数据\n* 作用：避免资源在多线程中共享时产生各种异常，所以每个线程自己独立存储一份进行使用\n* 使用场景:\n  * 比如JDBC的链接，每个线程可独立对数据库进行操作，某个线程进行close操作时不会对其他线程造成影响\n  * session管理等\n* 实现：这个Map是Thread的属性，而ThreadLocal是一个代理工具类，用来持有这个map并对其进行操作\n* 注意点：使用时需要手动调用ThreadLocal的remove方法，尤其是当使用到线程池时，线程可能会一直存在，所以会导致内存泄漏\n\n### 说一下 synchronized 底层实现原理？\n* 特性：\n  * 原子性\n  * 可见性\n  * 有序性\n  * 可重入性：同一线程可以多次申请同一锁\n* 使用场景：\n  * 修饰静态方法、成员函数、代码块\n  * 真正可以锁的资源：对象\n* 通过在对象头当中增加线程标记、锁标记等记录，然后三种锁（偏向锁、轻量级锁、重量级锁）根据程序运行情况使用来实现\n\n### synchronized 和 volatile 的区别是什么？\n|| synchronized | volatitle |\n|----|----|-----|\n| 本质 | 锁定对象只能由一个线程访问 | 告诉jvm某个变量值时不确定的，需要实时读取 |\n| 修饰内容 | 变量、方法、类、代码块 | 变量 |\n| 可见性、原子性 | 只能保证可见性 | 可见性、原子性 |\n| 会不会造成线程阻塞 | 会 | 不会 |\n| 编译器优化 | 会 | 不会 |\n\n### synchronized 和 Lock 有什么区别？\n|| synchronized | lock |\n|----|----|-----|\n| 使用场景 | 简单场景使用，并发情况简单 | 并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断 |\n| 存在层次 | 是java关键字，可修饰变量、方法、类、代码块 | 一个类，使用时需要主动调用上锁和解锁 |\n| 锁实现 | JVM实现 | 自己写代码调用lock API实现 |\n| 释放锁 | jvm自动释放(获取锁线程执行完；程序执行异常) | 手动unlock，不释放会造成死锁 |\n| 获取锁 | jvm自己获取，根据锁升级规则来获取 | trylock，可以设置等待时间 |\n| 锁状态 | 无法判断 | 可以获取 |\n| 锁类型 | 可重入、不可中断、非公平 | 可重入、可中断、可公平（不公平皆可） |\n| 阻塞性 | 少量阻塞 | 大量阻塞 |\n| 性能 | 简单场景两者相似，复杂场景lock好 |\n\n### synchronized 和 ReentrantLock 区别是什么？\n|| synchronized | ReentrantLock |\n|----|----|-----|\n| 使用场景 | 简单场景使用，并发情况简单 | 并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断 |\n| 存在层次 | 是java关键字，可修饰变量、方法、类、代码块 | 一个类，使用时需要主动调用上锁和解锁 |\n| 锁实现 | JVM实现 | 自己写代码调用lock API实现 |\n| 释放锁 | jvm自动释放(获取锁线程执行完；程序执行异常) | 手动unlock，不释放会造成死锁 |\n| 获取锁 | jvm自己获取，根据锁升级规则来获取 | trylock，可以设置等待时间 |\n| 锁状态 | 无法判断 | 可以获取 |\n| 锁类型 | 可重入、不可中断、非公平 | 可重入、可中断、可公平（不公平皆可） |\n| 阻塞性 | 少量阻塞 | 大量阻塞 |\n| 性能 | 简单场景两者相似，复杂场景lock好 |\n| 特点 | 使用简单 | 可以制定公平锁、非公平锁；提供Condition类来精细控制；提供等待获取锁功能 |  \n\n\n### atomic 的原理？\n* 作用：在多线程环境中保证同一时间内变量写操作只能由一个线程完成\n* 原理：基于unsafe类提供的硬件级别的原子操作实现的\n* 核心原理：即CAS操作，比如有个变量num（比如此时值为1），首先执行操作的开始会先将num的值复制一份为numCopy（值也是1）用于一会的对比，然后将num放到运算单元中进行计算，此时不会改变内存中num的值，当计算完成后得到numTmp（比如执行了加1操作，此时numTmp为2），将复制的值即numCopy与内存中现有的num的值进行比较，如果numCopy与num相等，则将numTmp复制给num，不想等就放弃赋值，意思就是防止num在执行本次操作过程中被别人改过\n","source":"_posts/Q&A/Java/多线程.md","raw":"---\ntitle: 多线程\ndate: 2022-01-17 20:40:20\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n### 并行和并发有什么区别？\n#### 并发：\n* 在操作系统中，一个时间段内在同一个处理机上处于开始到结束之间的多个任务之间的状态，window的时间片分时调度即并发，实际是串行，但是多个任务在不停地切换，每个任务运行一小会，以实现多个任务的同时运行即并发\n\n#### 并行：\n* 互不抢占资源的两个任务同时运行时，即并行\n\n#### 区别：\n* 并发实际上是串行\n* 并发需要共享运算资源，并行不需要\n* 单cpu可以实现并发，但不能实现并行\n* 并行是真正的同时运行\n\n\n### 线程和进程的区别？\n#### 线程：\n* 是进程的子任务\n* 是操作系统可识别的最小执行和调度单位\n* 是CPU调度和分配的基本单位\n\n#### 进程：\n* 是对运行时程序的封装\n* 是系统进行资源调度和分配的基本单位\n\n#### 区别：\n* 一个线程只能属于一个进程，一个进程可以包含多个线程，且至少有一个线程\n* 进程用友独立的内存单元，多个线程共享这部分内存\n* 进程是资源分配的最小单位，线程是cpu调度的最小单位\n* 创建、撤销、切换等操作，进程的开销要远大于线程\n* 线程间可以使用共享内存进行通信，实现起来较简单，进程间通信实现较复杂，进程间通信依赖线程\n* 进程间互相不会影响，线程挂掉时会导致整个进程挂掉\n\n### 进程间通信方式？\n* 管道：\n  * 匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系\n  * 高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。\n  * 有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信\n* 消息队列\n* 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n* 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生\n* 共享内存：\n* 套接字\n\n### 线程间通信方式？\n* 各种锁：互斥锁\n* 信号量：\n* 信号：\n* 进程间通信也能用于线程间通信，进程间通信本质上都是线程在干活\n\n### 守护线程是什么？\n#### 定义:\n* 为其他线程服务的线程，比如垃圾回收线程\n\n#### 特点：\n* JVM结束进程时，不关心守护线程，但是用户线程存在的话，JVM不会结束进程\n* 守护线程不能持有任何需要关闭的资源，进程结束时会导致该资源出错\n* 守护线程优先级低，守护线程中创建的新线程同样是守护线程，用户线程同样，其中创建的新线程也是用户线程\n\n### 线程分类?\n#### 按照是否为用户自定义来区分\n* 守护线程\n* 用户线程\n\n### 创建线程有哪几种方式？\n* 本质上都是一样的，都需要new thread\n* 继承Thread类，重写run方法\n* 通过实现Runnable接口中的run方法\n* 通过实现Callable接口中的call方法，然后使用FutureTask进行调用\n```\n    @Test\n    public void testCode() throws ExecutionException, InterruptedException {\n        FutureTask<Integer> futureTask = new FutureTask<>(new TestThread());\n        new Thread(futureTask).start();\n        Integer result = futureTask.get();\n        System.out.println(result);\n    }\n\n    class TestThread implements Callable<Integer> {\n\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(\"啦啦啦啦\");\n            return 1;\n        }\n    }\n```\n* 通过线程池创建线程：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式\n  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限\n  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限\n  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务\n  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程\n\n\n### 说一下 runnable 和 callable 有什么区别？\n* 相同点：\n  * 都是接口\n  * 都可以实现多线程\n  * 都采用thread.start启动\n* 不同：\n  * Runnable的run方法没有返回值，Callable的call方法可以自定义返回值\n  * Runnable的run方法只能抛出运行时一场，且无法捕获，Callable的run方法允许抛出异常，且可以捕获\n  * Executor使用Runnable使用execute方法，使用Callable时使用submit方法\n\n### 线程有哪些状态？\n* new：创建\n* Runnable：运行中，正在执行run方法\n* Blocked： 运行中，因被阻塞而挂起\n* Waiting：运行中，因为某些操作在等待中，join方法会阻塞当前线程，等待该线程对象执行完成，如果已完成，就立即返回\n* Timed Waiting：运行中，因为执行sleep，在计时等待\n* Terminated：终止，run方法执行完毕或调用Thread的stop\n\n### sleep() 和 wait() 有什么区别？\n* 调用方面：\n  * sleep是静态方法，wait是实例方法\n  * wait只能在同步情况下调用，sleep不需要\n  * wait是用于线程间通信的，sleep是用于当前线程\n* 锁及资源：\n  * 线程进入wait状态时会释放持有的对象锁，但sleep不会\n  * 进入wait状态的线程使用notify和notifyAll可以再次唤醒，进入sleep状态的线程不能被唤醒\n* 异常捕获：\n  * sleep需要捕获或者抛出异常，wait/notify/notifyAll不需要\n\n### notify()和 notifyAll()有什么区别？\n* notify唤醒对象的等待池中的一个线程进入锁池，notifyAll唤醒等待池中的所有线程进入锁池\n* 等待池：线程A调用了对象o的wait方法，A就会释放o的锁，进入o的等待池，等待池中的线程不会竞争o的锁\n* 锁池：获取了对象o的锁，才能执行synchronized代码，同一时间内，只有一个线程可以获得该锁，其他线程只能在锁池中等待，锁池中的线程会竞争对象锁，等待池中的线程不会\n\n### 线程的 run()和 start()有什么区别？\n* run里面是线程需要计算的内容，start就是创建新线程然后调用一下run，基于此区别自己说就好了\n\n### 创建线程池有哪几种方式？\n* 使用Executors创建线程池：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式\n  * newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限\n  * newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限\n  * newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务\n  * newSingleThreadExecutor()：单例线程，任何时刻只有一个线程\n* 通过ThreadPoolExecutor创建自定义线程池\n\n### 线程池都有哪些状态？\n* running：接收新任务，处理队列任务\n* shutdown：停止接收新任务，处理队列任务\n* stop：停止接收新任务，停止处理队列任务，停止正在处理的任务\n* tidying：所有任务被终结，有效线程为0，会触发terminated方法\n* terminated：当terminated执行结束，销毁状态\n\n### 线程池中 submit()和 execute()方法有什么区别？\n* 同\n  * 都是线程池的方法\n* 异\n  * execute只能传入Runnable任务，submit可以传入Runnable和Callable任务\n  * execute会直接抛出异常，submit会吃掉异常，但是可以通过future的get方法将异常重新抛出\n  * execute所属顶层接口是Executor，submit所属顶层接口是ExecutorService\n\n### 在 java 程序中怎么保证多线程的运行安全？\n* 保证安全需要遵守的特性：\n  * 原子性：一个或者多个操作在CPU执行的过程中不被中断的特性\n  * 可见性：一个线程对共享变量的修改，另一个线程能立刻看到\n  * 有序性：程序按照代码顺序进行执行\n* 安全隐患：\n  * 缓存对可见性的影响\n  * 线程切换导致CPU执行终端，对原子性的影响\n  * 编译优化带来的有序性问题\n* 解决方案：\n  * JDK Atomic开头的原子类、synchronized、lock，可解决原子性问题\n  * synchronized、volatile、lock可以解决可见性问题\n  * Happen-before可解决有序性问题\n* Happen-before：\n  * 程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作发生早于后面的操作\n  * 管道锁定规则：unlock操作发生遭遇后面对同一个锁的lock操作\n  * volatile规则：对一个变量的写操作早于后面的读操作\n  * 线程启动规则：Thread的start操作早于线程的任何其他行为\n  * 线程终止规则：Thread的销毁操作发生与线程的所有其他行为之后\n  * 线程中断规则：对线程的interrupt的调用发生于被中断线程的代码检测到中断之前\n  * 对象销毁规则：对象的初始化完成、构造完成早于销毁\n\n### 多线程锁的升级原理是什么？\n* [参考文章](https://www.cnblogs.com/jxxblogs/p/11890563.html)\n* 锁分级原因：降低资源消耗，没有优化之前，synchronized是重量级锁（悲观锁），wait、notify、notifyAll切换线程状态非常消耗资源，而线程的挂起和唤醒时间很短，这样会导致浪费资源，影响应能，所以JVM对synchronized进行了优化，把锁分成了无锁、偏向锁、轻量级锁、重量级锁\n  * 切换原因：当JVM检测到不同的竞争状态时，会根据需要自动切换到合适的锁\n  * 特点：只能从低到高，不能从高到低\n  * 位置：对象头的Mark Word里\n\n\n* CAS：compareAndSwap，比较并替换\n  * CAS包含三个操作数：内存地址V、预期值A、即将更新的目标值B\n  * 使用场景：当一个线程要修改某个变量的值时，发现被其他线程修改过了，此时就会放弃修改，实现逻辑加锁\n  * 特点：逻辑上避免加锁\n  * 作用：比较并替换\n\n\n* 锁级别从低到高：无锁->偏向锁->轻量级锁->重量级锁\n  * 无锁：不对资源进行锁定，所有线程都可以同时读写同一资源、但只有一个线程可以成功，其他线程需要不断重试才能成功\n  * 偏向锁：对象代码一致被同一线程执行，不存在多个线程竞争，该线程在后续执行中自动获取锁，降低获取锁带来的性能开销。偏向指的就是偏向第一个加锁线程，该线程不会主动释放锁，当其他线程尝试竞争偏向锁时才会被释放。\n    * 撤销：在没有字节码执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否被锁定，如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，如果线程处于活跃状态，就升级为轻量级锁\n  * 轻量级锁：当对象锁时偏向锁，且对象被第二个线程访问时，此时偏向锁会升级为轻量级锁，第二个线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。\n    * 升级重量级锁1：当只有一个等待线程时，该线程会通过自旋进行等待，但是当自旋超过一定次数时，轻量级锁会升级成重量级锁\n    * 升级重量级锁2：当一个线程持有锁，另一个线程在自旋等待，此时再有一个线程来访问时，轻量级锁会升级为重量级锁\n  * 重量级锁：当一个线程获取锁之后，其余所有等待线程都处于阻塞状态\n    * 实现：重量级锁通过对象内的监视器（monitor）实现，monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户状态切换为内核态，切换成本很高\n  * synchronized优化之锁消除：编译时对上线文进行扫描，去除不可能存在共享资源竞争的锁，消除没必要的锁，节约资源\n\n\n* 锁升级过程：\n\n|  |  | |\n| -------- | --------- | ----------- |\n| 默认无锁，当程序执行到同步块时，***判断对象头中保存的threadId是否是当前线程*** |\n| 是：该线程获得偏向锁，此时不需要CAS来加、撤销锁，偏向锁是最简单的线程锁，适合某线程频繁访问同一对象场景 | 否：***判断偏向锁标识*** |\n| | 0：即无锁状态，此时需使用CAS竞争锁 | 1：即偏向锁状态，使用CAS将对象头中的锁信息指向当前线程，并触发偏向锁撤销（有竞争才会有偏向锁撤销）|\n| 当其它线程尝试竞争偏向锁，且程序到达全局安全点（即无正在运行代码），此时JVM会***判断对象头中记录的线程是否存活*** |\n| 未存活：对象被重置为无锁状态，其他线程可竞争偏向锁 | 存活：查找该线程栈帧信息，***判断是否需要继续持有该对象*** |\n|| 需要：暂停该线程，撤销偏向锁，升级为轻量级锁 | 不需要：将该对象设置为无锁状态，其他线程可竞争偏向锁 |\n|| 轻量级锁：当有多个线程竞争一个偏向锁时，会频繁产生偏向锁撤销，此时JVM会将对象头中的锁标识升级为轻量级锁，多个线程通过自旋来继续获取锁 |\n|| 重量级锁：有多个线程通过自旋获取锁，进入到非常激烈状态时，会非常消耗cpu资源，当自旋达到一定次数时（轻量级切换重量级的判断逻辑），JVM会将轻量级锁升级为重量级锁，重量级锁当获取锁失败时会让线程阻塞，重量级锁缺点是线程会频繁进行上下文切换 |\n\n\n\n\n* 锁比较：\n\n\n  |         | 偏向锁       | 轻量级锁         | 重量级锁            |\n  | ------------ | ----------- | -------------- | ------------------ |\n  | 使用场景      | 一个同步代码块只有一个线程频繁访问 | 多条线程进入同步块，线程进入时间错开因而并未争抢 | 发生了争抢，多个线程进入同步块并竞争锁 |\n  | 本质 | 取消同步操作 | CAS操作代替互斥同步 | 互斥同步 |\n  | 优点 | 不阻塞，执行效率高 (不需要使用CAS来获取锁和撤销锁，只需要对比threadId，效率高) | 不会阻塞 | 不会空耗cpu |\n  | 缺点 | 使用场景局限，若竞争产生，会有偏向锁撤销的消耗 | 长时间获取不到会空耗cpu | 阻塞，上下文切换，重量级操作，消耗系统资源 |\n\n\n\n### 什么是死锁？\n#### 线程死锁\n* 定义：两个及以上的线程因为互相等待而被阻塞的现象即死锁\n* 死锁示例：两个线程互相等待对方持有的锁，即死锁\n  ```\n  public void add(int m) {\n    synchronized(lockA) { // 获得lockA的锁\n        this.value += m;\n        synchronized(lockB) { // 获得lockB的锁\n            this.another += m;\n        } // 释放lockB的锁\n    } // 释放lockA的锁\n}\n\npublic void dec(int m) {\n    synchronized(lockB) { // 获得lockB的锁\n        this.another -= m;\n        synchronized(lockA) { // 获得lockA的锁\n            this.value -= m;\n        } // 释放lockA的锁\n    } // 释放lockB的锁\n}\n  ```\n* 导致死锁的原因：\n  * 已持有锁的线程请求新锁\n  * 两个及以上的线程同时发出新锁请求\n  * 两个及以上的线程形成一个新锁申请循环链，每个线程都在等待链中下一个线程持有的锁\n* 分类：\n  * 潜在死锁：不一定发生，但可能在程序运行的任何阶段发生\n  * 实际死锁：程序执行过程中的死锁，实际死锁会导致线程挂起，但进程不一定挂起\n* java线程锁是可重入锁，即同一个锁可以被同一线程多次获取到，线程对锁有记录，获取到加1，完成代码块减一，减到0时，释放锁\n  * 例：\n  ```\n  public class Counter {\n    private int count = 0;\n\n    public synchronized void add(int n) {\n        if (n < 0) {\n            dec(-n);\n        } else {\n            count += n;\n        }\n    }\n\n    public synchronized void dec(int n) {\n        count += n;\n    }\n}\n  ```\n#### 进程死锁\n* 定义：进程竞争共享资源时出现的无线循环等待问题\n* 产生进程死锁必要条件：\n  * 互斥条件：共享资源单位时间内只能被一个进程占有\n  * 不可抢占条件：某进程占有的资源未使用完之前，其他进程不得抢夺\n  * 占有且申请条件：进程已占用的资源，在申请新资源时，仍继续占有已占有资源\n  * 循环等待条件：存在一个循环等待环，第一个依赖第二个，第n个依赖第1个\n* 预防死锁：打破产生的四个条件之中的一个或多个\n\n### 怎么防止死锁？\n* 规避四个产生条件来设计代码，以避免\n\n\n#### 避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\n* [参考文章1](https://blog.csdn.net/qq_33414271/article/details/80245715)\n[参考文章2](https://baike.baidu.com/item/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1679781)\n* 安全状态：某一时刻，某进程序列中的进程都可以顺利完成，则此时状态为安全状态，系统中安全状态与不安全状态是共存的，安全状态一定不死锁，不安全状态不一定会死锁\n* 安全状态检测：系统先尝试分配资源给申请进程，然后使用剩余资源计算是否能满足进程队列中的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态，如果有进程都可以执行完毕，然后假设回收资源后，也可以让其他所有进程队列中的进程都执行完毕，则系统处于安全状态，然后会根据分配顺序生成安全序列，然后执行\n* 判断某个状态是否安全：根据安全性算法进行计算，如果可以找到某种安全序列即安全\n* 判断某个请求系统是否可满足：根据安全性算法进行检查，如果分配后剩余的资源无法满足进程队列中的任一进程需求的话，即不能分配，否则可分配\n\n### ThreadLocal 是什么？有哪些使用场景？\n* ThreadLocal：线程本地存储，每个线程中都会有一个ThreadLcoalMap对象，用来保存各种数据\n* 作用：避免资源在多线程中共享时产生各种异常，所以每个线程自己独立存储一份进行使用\n* 使用场景:\n  * 比如JDBC的链接，每个线程可独立对数据库进行操作，某个线程进行close操作时不会对其他线程造成影响\n  * session管理等\n* 实现：这个Map是Thread的属性，而ThreadLocal是一个代理工具类，用来持有这个map并对其进行操作\n* 注意点：使用时需要手动调用ThreadLocal的remove方法，尤其是当使用到线程池时，线程可能会一直存在，所以会导致内存泄漏\n\n### 说一下 synchronized 底层实现原理？\n* 特性：\n  * 原子性\n  * 可见性\n  * 有序性\n  * 可重入性：同一线程可以多次申请同一锁\n* 使用场景：\n  * 修饰静态方法、成员函数、代码块\n  * 真正可以锁的资源：对象\n* 通过在对象头当中增加线程标记、锁标记等记录，然后三种锁（偏向锁、轻量级锁、重量级锁）根据程序运行情况使用来实现\n\n### synchronized 和 volatile 的区别是什么？\n|| synchronized | volatitle |\n|----|----|-----|\n| 本质 | 锁定对象只能由一个线程访问 | 告诉jvm某个变量值时不确定的，需要实时读取 |\n| 修饰内容 | 变量、方法、类、代码块 | 变量 |\n| 可见性、原子性 | 只能保证可见性 | 可见性、原子性 |\n| 会不会造成线程阻塞 | 会 | 不会 |\n| 编译器优化 | 会 | 不会 |\n\n### synchronized 和 Lock 有什么区别？\n|| synchronized | lock |\n|----|----|-----|\n| 使用场景 | 简单场景使用，并发情况简单 | 并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断 |\n| 存在层次 | 是java关键字，可修饰变量、方法、类、代码块 | 一个类，使用时需要主动调用上锁和解锁 |\n| 锁实现 | JVM实现 | 自己写代码调用lock API实现 |\n| 释放锁 | jvm自动释放(获取锁线程执行完；程序执行异常) | 手动unlock，不释放会造成死锁 |\n| 获取锁 | jvm自己获取，根据锁升级规则来获取 | trylock，可以设置等待时间 |\n| 锁状态 | 无法判断 | 可以获取 |\n| 锁类型 | 可重入、不可中断、非公平 | 可重入、可中断、可公平（不公平皆可） |\n| 阻塞性 | 少量阻塞 | 大量阻塞 |\n| 性能 | 简单场景两者相似，复杂场景lock好 |\n\n### synchronized 和 ReentrantLock 区别是什么？\n|| synchronized | ReentrantLock |\n|----|----|-----|\n| 使用场景 | 简单场景使用，并发情况简单 | 并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断 |\n| 存在层次 | 是java关键字，可修饰变量、方法、类、代码块 | 一个类，使用时需要主动调用上锁和解锁 |\n| 锁实现 | JVM实现 | 自己写代码调用lock API实现 |\n| 释放锁 | jvm自动释放(获取锁线程执行完；程序执行异常) | 手动unlock，不释放会造成死锁 |\n| 获取锁 | jvm自己获取，根据锁升级规则来获取 | trylock，可以设置等待时间 |\n| 锁状态 | 无法判断 | 可以获取 |\n| 锁类型 | 可重入、不可中断、非公平 | 可重入、可中断、可公平（不公平皆可） |\n| 阻塞性 | 少量阻塞 | 大量阻塞 |\n| 性能 | 简单场景两者相似，复杂场景lock好 |\n| 特点 | 使用简单 | 可以制定公平锁、非公平锁；提供Condition类来精细控制；提供等待获取锁功能 |  \n\n\n### atomic 的原理？\n* 作用：在多线程环境中保证同一时间内变量写操作只能由一个线程完成\n* 原理：基于unsafe类提供的硬件级别的原子操作实现的\n* 核心原理：即CAS操作，比如有个变量num（比如此时值为1），首先执行操作的开始会先将num的值复制一份为numCopy（值也是1）用于一会的对比，然后将num放到运算单元中进行计算，此时不会改变内存中num的值，当计算完成后得到numTmp（比如执行了加1操作，此时numTmp为2），将复制的值即numCopy与内存中现有的num的值进行比较，如果numCopy与num相等，则将numTmp复制给num，不想等就放弃赋值，意思就是防止num在执行本次操作过程中被别人改过\n","slug":"Q&A/Java/多线程","published":1,"updated":"2022-04-12T09:00:46.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c0003kwgtt59c2f5kx","content":"<h3 id=\"并行和并发有什么区别？\"><a href=\"#并行和并发有什么区别？\" class=\"headerlink\" title=\"并行和并发有什么区别？\"></a>并行和并发有什么区别？</h3><h4 id=\"并发：\"><a href=\"#并发：\" class=\"headerlink\" title=\"并发：\"></a>并发：</h4><ul>\n<li>在操作系统中，一个时间段内在同一个处理机上处于开始到结束之间的多个任务之间的状态，window的时间片分时调度即并发，实际是串行，但是多个任务在不停地切换，每个任务运行一小会，以实现多个任务的同时运行即并发</li>\n</ul>\n<h4 id=\"并行：\"><a href=\"#并行：\" class=\"headerlink\" title=\"并行：\"></a>并行：</h4><ul>\n<li>互不抢占资源的两个任务同时运行时，即并行</li>\n</ul>\n<h4 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h4><ul>\n<li>并发实际上是串行</li>\n<li>并发需要共享运算资源，并行不需要</li>\n<li>单cpu可以实现并发，但不能实现并行</li>\n<li>并行是真正的同时运行</li>\n</ul>\n<h3 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h3><h4 id=\"线程：\"><a href=\"#线程：\" class=\"headerlink\" title=\"线程：\"></a>线程：</h4><ul>\n<li>是进程的子任务</li>\n<li>是操作系统可识别的最小执行和调度单位</li>\n<li>是CPU调度和分配的基本单位</li>\n</ul>\n<h4 id=\"进程：\"><a href=\"#进程：\" class=\"headerlink\" title=\"进程：\"></a>进程：</h4><ul>\n<li>是对运行时程序的封装</li>\n<li>是系统进行资源调度和分配的基本单位</li>\n</ul>\n<h4 id=\"区别：-1\"><a href=\"#区别：-1\" class=\"headerlink\" title=\"区别：\"></a>区别：</h4><ul>\n<li>一个线程只能属于一个进程，一个进程可以包含多个线程，且至少有一个线程</li>\n<li>进程用友独立的内存单元，多个线程共享这部分内存</li>\n<li>进程是资源分配的最小单位，线程是cpu调度的最小单位</li>\n<li>创建、撤销、切换等操作，进程的开销要远大于线程</li>\n<li>线程间可以使用共享内存进行通信，实现起来较简单，进程间通信实现较复杂，进程间通信依赖线程</li>\n<li>进程间互相不会影响，线程挂掉时会导致整个进程挂掉</li>\n</ul>\n<h3 id=\"进程间通信方式？\"><a href=\"#进程间通信方式？\" class=\"headerlink\" title=\"进程间通信方式？\"></a>进程间通信方式？</h3><ul>\n<li>管道：<ul>\n<li>匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</li>\n<li>高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</li>\n<li>有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信</li>\n</ul>\n</li>\n<li>消息队列</li>\n<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>\n<li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>\n<li>共享内存：</li>\n<li>套接字</li>\n</ul>\n<h3 id=\"线程间通信方式？\"><a href=\"#线程间通信方式？\" class=\"headerlink\" title=\"线程间通信方式？\"></a>线程间通信方式？</h3><ul>\n<li>各种锁：互斥锁</li>\n<li>信号量：</li>\n<li>信号：</li>\n<li>进程间通信也能用于线程间通信，进程间通信本质上都是线程在干活</li>\n</ul>\n<h3 id=\"守护线程是什么？\"><a href=\"#守护线程是什么？\" class=\"headerlink\" title=\"守护线程是什么？\"></a>守护线程是什么？</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义:\"></a>定义:</h4><ul>\n<li>为其他线程服务的线程，比如垃圾回收线程</li>\n</ul>\n<h4 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h4><ul>\n<li>JVM结束进程时，不关心守护线程，但是用户线程存在的话，JVM不会结束进程</li>\n<li>守护线程不能持有任何需要关闭的资源，进程结束时会导致该资源出错</li>\n<li>守护线程优先级低，守护线程中创建的新线程同样是守护线程，用户线程同样，其中创建的新线程也是用户线程</li>\n</ul>\n<h3 id=\"线程分类\"><a href=\"#线程分类\" class=\"headerlink\" title=\"线程分类?\"></a>线程分类?</h3><h4 id=\"按照是否为用户自定义来区分\"><a href=\"#按照是否为用户自定义来区分\" class=\"headerlink\" title=\"按照是否为用户自定义来区分\"></a>按照是否为用户自定义来区分</h4><ul>\n<li>守护线程</li>\n<li>用户线程</li>\n</ul>\n<h3 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h3><ul>\n<li>本质上都是一样的，都需要new thread</li>\n<li>继承Thread类，重写run方法</li>\n<li>通过实现Runnable接口中的run方法</li>\n<li>通过实现Callable接口中的call方法，然后使用FutureTask进行调用<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testCode() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new TestThread());</span><br><span class=\"line\">    new Thread(futureTask).start();</span><br><span class=\"line\">    Integer result = futureTask.get();</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class TestThread implements Callable&lt;Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Integer call() throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;啦啦啦啦&quot;);</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>通过线程池创建线程：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式<ul>\n<li>newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限</li>\n<li>newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限</li>\n<li>newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务</li>\n<li>newSingleThreadExecutor()：单例线程，任何时刻只有一个线程</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h3><ul>\n<li>相同点：<ul>\n<li>都是接口</li>\n<li>都可以实现多线程</li>\n<li>都采用thread.start启动</li>\n</ul>\n</li>\n<li>不同：<ul>\n<li>Runnable的run方法没有返回值，Callable的call方法可以自定义返回值</li>\n<li>Runnable的run方法只能抛出运行时一场，且无法捕获，Callable的run方法允许抛出异常，且可以捕获</li>\n<li>Executor使用Runnable使用execute方法，使用Callable时使用submit方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程有哪些状态？\"><a href=\"#线程有哪些状态？\" class=\"headerlink\" title=\"线程有哪些状态？\"></a>线程有哪些状态？</h3><ul>\n<li>new：创建</li>\n<li>Runnable：运行中，正在执行run方法</li>\n<li>Blocked： 运行中，因被阻塞而挂起</li>\n<li>Waiting：运行中，因为某些操作在等待中，join方法会阻塞当前线程，等待该线程对象执行完成，如果已完成，就立即返回</li>\n<li>Timed Waiting：运行中，因为执行sleep，在计时等待</li>\n<li>Terminated：终止，run方法执行完毕或调用Thread的stop</li>\n</ul>\n<h3 id=\"sleep-和-wait-有什么区别？\"><a href=\"#sleep-和-wait-有什么区别？\" class=\"headerlink\" title=\"sleep() 和 wait() 有什么区别？\"></a>sleep() 和 wait() 有什么区别？</h3><ul>\n<li>调用方面：<ul>\n<li>sleep是静态方法，wait是实例方法</li>\n<li>wait只能在同步情况下调用，sleep不需要</li>\n<li>wait是用于线程间通信的，sleep是用于当前线程</li>\n</ul>\n</li>\n<li>锁及资源：<ul>\n<li>线程进入wait状态时会释放持有的对象锁，但sleep不会</li>\n<li>进入wait状态的线程使用notify和notifyAll可以再次唤醒，进入sleep状态的线程不能被唤醒</li>\n</ul>\n</li>\n<li>异常捕获：<ul>\n<li>sleep需要捕获或者抛出异常，wait/notify/notifyAll不需要</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify()和 notifyAll()有什么区别？\"></a>notify()和 notifyAll()有什么区别？</h3><ul>\n<li>notify唤醒对象的等待池中的一个线程进入锁池，notifyAll唤醒等待池中的所有线程进入锁池</li>\n<li>等待池：线程A调用了对象o的wait方法，A就会释放o的锁，进入o的等待池，等待池中的线程不会竞争o的锁</li>\n<li>锁池：获取了对象o的锁，才能执行synchronized代码，同一时间内，只有一个线程可以获得该锁，其他线程只能在锁池中等待，锁池中的线程会竞争对象锁，等待池中的线程不会</li>\n</ul>\n<h3 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h3><ul>\n<li>run里面是线程需要计算的内容，start就是创建新线程然后调用一下run，基于此区别自己说就好了</li>\n</ul>\n<h3 id=\"创建线程池有哪几种方式？\"><a href=\"#创建线程池有哪几种方式？\" class=\"headerlink\" title=\"创建线程池有哪几种方式？\"></a>创建线程池有哪几种方式？</h3><ul>\n<li>使用Executors创建线程池：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式<ul>\n<li>newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限</li>\n<li>newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限</li>\n<li>newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务</li>\n<li>newSingleThreadExecutor()：单例线程，任何时刻只有一个线程</li>\n</ul>\n</li>\n<li>通过ThreadPoolExecutor创建自定义线程池</li>\n</ul>\n<h3 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h3><ul>\n<li>running：接收新任务，处理队列任务</li>\n<li>shutdown：停止接收新任务，处理队列任务</li>\n<li>stop：停止接收新任务，停止处理队列任务，停止正在处理的任务</li>\n<li>tidying：所有任务被终结，有效线程为0，会触发terminated方法</li>\n<li>terminated：当terminated执行结束，销毁状态</li>\n</ul>\n<h3 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit()和 execute()方法有什么区别？\"></a>线程池中 submit()和 execute()方法有什么区别？</h3><ul>\n<li>同<ul>\n<li>都是线程池的方法</li>\n</ul>\n</li>\n<li>异<ul>\n<li>execute只能传入Runnable任务，submit可以传入Runnable和Callable任务</li>\n<li>execute会直接抛出异常，submit会吃掉异常，但是可以通过future的get方法将异常重新抛出</li>\n<li>execute所属顶层接口是Executor，submit所属顶层接口是ExecutorService</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在-java-程序中怎么保证多线程的运行安全？\"><a href=\"#在-java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"在 java 程序中怎么保证多线程的运行安全？\"></a>在 java 程序中怎么保证多线程的运行安全？</h3><ul>\n<li>保证安全需要遵守的特性：<ul>\n<li>原子性：一个或者多个操作在CPU执行的过程中不被中断的特性</li>\n<li>可见性：一个线程对共享变量的修改，另一个线程能立刻看到</li>\n<li>有序性：程序按照代码顺序进行执行</li>\n</ul>\n</li>\n<li>安全隐患：<ul>\n<li>缓存对可见性的影响</li>\n<li>线程切换导致CPU执行终端，对原子性的影响</li>\n<li>编译优化带来的有序性问题</li>\n</ul>\n</li>\n<li>解决方案：<ul>\n<li>JDK Atomic开头的原子类、synchronized、lock，可解决原子性问题</li>\n<li>synchronized、volatile、lock可以解决可见性问题</li>\n<li>Happen-before可解决有序性问题</li>\n</ul>\n</li>\n<li>Happen-before：<ul>\n<li>程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作发生早于后面的操作</li>\n<li>管道锁定规则：unlock操作发生遭遇后面对同一个锁的lock操作</li>\n<li>volatile规则：对一个变量的写操作早于后面的读操作</li>\n<li>线程启动规则：Thread的start操作早于线程的任何其他行为</li>\n<li>线程终止规则：Thread的销毁操作发生与线程的所有其他行为之后</li>\n<li>线程中断规则：对线程的interrupt的调用发生于被中断线程的代码检测到中断之前</li>\n<li>对象销毁规则：对象的初始化完成、构造完成早于销毁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"多线程锁的升级原理是什么？\"><a href=\"#多线程锁的升级原理是什么？\" class=\"headerlink\" title=\"多线程锁的升级原理是什么？\"></a>多线程锁的升级原理是什么？</h3><ul>\n<li><a href=\"https://www.cnblogs.com/jxxblogs/p/11890563.html\">参考文章</a></li>\n<li>锁分级原因：降低资源消耗，没有优化之前，synchronized是重量级锁（悲观锁），wait、notify、notifyAll切换线程状态非常消耗资源，而线程的挂起和唤醒时间很短，这样会导致浪费资源，影响应能，所以JVM对synchronized进行了优化，把锁分成了无锁、偏向锁、轻量级锁、重量级锁<ul>\n<li>切换原因：当JVM检测到不同的竞争状态时，会根据需要自动切换到合适的锁</li>\n<li>特点：只能从低到高，不能从高到低</li>\n<li>位置：对象头的Mark Word里</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>CAS：compareAndSwap，比较并替换<ul>\n<li>CAS包含三个操作数：内存地址V、预期值A、即将更新的目标值B</li>\n<li>使用场景：当一个线程要修改某个变量的值时，发现被其他线程修改过了，此时就会放弃修改，实现逻辑加锁</li>\n<li>特点：逻辑上避免加锁</li>\n<li>作用：比较并替换</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>锁级别从低到高：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<ul>\n<li>无锁：不对资源进行锁定，所有线程都可以同时读写同一资源、但只有一个线程可以成功，其他线程需要不断重试才能成功</li>\n<li>偏向锁：对象代码一致被同一线程执行，不存在多个线程竞争，该线程在后续执行中自动获取锁，降低获取锁带来的性能开销。偏向指的就是偏向第一个加锁线程，该线程不会主动释放锁，当其他线程尝试竞争偏向锁时才会被释放。<ul>\n<li>撤销：在没有字节码执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否被锁定，如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，如果线程处于活跃状态，就升级为轻量级锁</li>\n</ul>\n</li>\n<li>轻量级锁：当对象锁时偏向锁，且对象被第二个线程访问时，此时偏向锁会升级为轻量级锁，第二个线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。<ul>\n<li>升级重量级锁1：当只有一个等待线程时，该线程会通过自旋进行等待，但是当自旋超过一定次数时，轻量级锁会升级成重量级锁</li>\n<li>升级重量级锁2：当一个线程持有锁，另一个线程在自旋等待，此时再有一个线程来访问时，轻量级锁会升级为重量级锁</li>\n</ul>\n</li>\n<li>重量级锁：当一个线程获取锁之后，其余所有等待线程都处于阻塞状态<ul>\n<li>实现：重量级锁通过对象内的监视器（monitor）实现，monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户状态切换为内核态，切换成本很高</li>\n</ul>\n</li>\n<li>synchronized优化之锁消除：编译时对上线文进行扫描，去除不可能存在共享资源竞争的锁，消除没必要的锁，节约资源</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>锁升级过程：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>默认无锁，当程序执行到同步块时，<em><strong>判断对象头中保存的threadId是否是当前线程</strong></em></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>是：该线程获得偏向锁，此时不需要CAS来加、撤销锁，偏向锁是最简单的线程锁，适合某线程频繁访问同一对象场景</td>\n<td>否：<em><strong>判断偏向锁标识</strong></em></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0：即无锁状态，此时需使用CAS竞争锁</td>\n<td>1：即偏向锁状态，使用CAS将对象头中的锁信息指向当前线程，并触发偏向锁撤销（有竞争才会有偏向锁撤销）</td>\n</tr>\n<tr>\n<td>当其它线程尝试竞争偏向锁，且程序到达全局安全点（即无正在运行代码），此时JVM会<em><strong>判断对象头中记录的线程是否存活</strong></em></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>未存活：对象被重置为无锁状态，其他线程可竞争偏向锁</td>\n<td>存活：查找该线程栈帧信息，<em><strong>判断是否需要继续持有该对象</strong></em></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>需要：暂停该线程，撤销偏向锁，升级为轻量级锁</td>\n<td>不需要：将该对象设置为无锁状态，其他线程可竞争偏向锁</td>\n</tr>\n<tr>\n<td></td>\n<td>轻量级锁：当有多个线程竞争一个偏向锁时，会频繁产生偏向锁撤销，此时JVM会将对象头中的锁标识升级为轻量级锁，多个线程通过自旋来继续获取锁</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>重量级锁：有多个线程通过自旋获取锁，进入到非常激烈状态时，会非常消耗cpu资源，当自旋达到一定次数时（轻量级切换重量级的判断逻辑），JVM会将轻量级锁升级为重量级锁，重量级锁当获取锁失败时会让线程阻塞，重量级锁缺点是线程会频繁进行上下文切换</td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>锁比较：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>偏向锁</th>\n<th>轻量级锁</th>\n<th>重量级锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使用场景</td>\n<td>一个同步代码块只有一个线程频繁访问</td>\n<td>多条线程进入同步块，线程进入时间错开因而并未争抢</td>\n<td>发生了争抢，多个线程进入同步块并竞争锁</td>\n</tr>\n<tr>\n<td>本质</td>\n<td>取消同步操作</td>\n<td>CAS操作代替互斥同步</td>\n<td>互斥同步</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>不阻塞，执行效率高 (不需要使用CAS来获取锁和撤销锁，只需要对比threadId，效率高)</td>\n<td>不会阻塞</td>\n<td>不会空耗cpu</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>使用场景局限，若竞争产生，会有偏向锁撤销的消耗</td>\n<td>长时间获取不到会空耗cpu</td>\n<td>阻塞，上下文切换，重量级操作，消耗系统资源</td>\n</tr>\n</tbody></table>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><h4 id=\"线程死锁\"><a href=\"#线程死锁\" class=\"headerlink\" title=\"线程死锁\"></a>线程死锁</h4><ul>\n<li>定义：两个及以上的线程因为互相等待而被阻塞的现象即死锁</li>\n<li>死锁示例：两个线程互相等待对方持有的锁，即死锁<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  public void add(int m) &#123;</span><br><span class=\"line\">    synchronized(lockA) &#123; // 获得lockA的锁</span><br><span class=\"line\">        this.value += m;</span><br><span class=\"line\">        synchronized(lockB) &#123; // 获得lockB的锁</span><br><span class=\"line\">            this.another += m;</span><br><span class=\"line\">        &#125; // 释放lockB的锁</span><br><span class=\"line\">    &#125; // 释放lockA的锁</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void dec(int m) &#123;</span><br><span class=\"line\">    synchronized(lockB) &#123; // 获得lockB的锁</span><br><span class=\"line\">        this.another -= m;</span><br><span class=\"line\">        synchronized(lockA) &#123; // 获得lockA的锁</span><br><span class=\"line\">            this.value -= m;</span><br><span class=\"line\">        &#125; // 释放lockA的锁</span><br><span class=\"line\">    &#125; // 释放lockB的锁</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>导致死锁的原因：<ul>\n<li>已持有锁的线程请求新锁</li>\n<li>两个及以上的线程同时发出新锁请求</li>\n<li>两个及以上的线程形成一个新锁申请循环链，每个线程都在等待链中下一个线程持有的锁</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>潜在死锁：不一定发生，但可能在程序运行的任何阶段发生</li>\n<li>实际死锁：程序执行过程中的死锁，实际死锁会导致线程挂起，但进程不一定挂起</li>\n</ul>\n</li>\n<li>java线程锁是可重入锁，即同一个锁可以被同一线程多次获取到，线程对锁有记录，获取到加1，完成代码块减一，减到0时，释放锁<ul>\n<li>例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  public class Counter &#123;</span><br><span class=\"line\">    private int count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void add(int n) &#123;</span><br><span class=\"line\">        if (n &lt; 0) &#123;</span><br><span class=\"line\">            dec(-n);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void dec(int n) &#123;</span><br><span class=\"line\">        count += n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"进程死锁\"><a href=\"#进程死锁\" class=\"headerlink\" title=\"进程死锁\"></a>进程死锁</h4></li>\n</ul>\n</li>\n<li>定义：进程竞争共享资源时出现的无线循环等待问题</li>\n<li>产生进程死锁必要条件：<ul>\n<li>互斥条件：共享资源单位时间内只能被一个进程占有</li>\n<li>不可抢占条件：某进程占有的资源未使用完之前，其他进程不得抢夺</li>\n<li>占有且申请条件：进程已占用的资源，在申请新资源时，仍继续占有已占有资源</li>\n<li>循环等待条件：存在一个循环等待环，第一个依赖第二个，第n个依赖第1个</li>\n</ul>\n</li>\n<li>预防死锁：打破产生的四个条件之中的一个或多个</li>\n</ul>\n<h3 id=\"怎么防止死锁？\"><a href=\"#怎么防止死锁？\" class=\"headerlink\" title=\"怎么防止死锁？\"></a>怎么防止死锁？</h3><ul>\n<li>规避四个产生条件来设计代码，以避免</li>\n</ul>\n<h4 id=\"避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\"><a href=\"#避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\" class=\"headerlink\" title=\"避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\"></a>避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_33414271/article/details/80245715\">参考文章1</a><br><a href=\"https://baike.baidu.com/item/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1679781\">参考文章2</a></li>\n<li>安全状态：某一时刻，某进程序列中的进程都可以顺利完成，则此时状态为安全状态，系统中安全状态与不安全状态是共存的，安全状态一定不死锁，不安全状态不一定会死锁</li>\n<li>安全状态检测：系统先尝试分配资源给申请进程，然后使用剩余资源计算是否能满足进程队列中的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态，如果有进程都可以执行完毕，然后假设回收资源后，也可以让其他所有进程队列中的进程都执行完毕，则系统处于安全状态，然后会根据分配顺序生成安全序列，然后执行</li>\n<li>判断某个状态是否安全：根据安全性算法进行计算，如果可以找到某种安全序列即安全</li>\n<li>判断某个请求系统是否可满足：根据安全性算法进行检查，如果分配后剩余的资源无法满足进程队列中的任一进程需求的话，即不能分配，否则可分配</li>\n</ul>\n<h3 id=\"ThreadLocal-是什么？有哪些使用场景？\"><a href=\"#ThreadLocal-是什么？有哪些使用场景？\" class=\"headerlink\" title=\"ThreadLocal 是什么？有哪些使用场景？\"></a>ThreadLocal 是什么？有哪些使用场景？</h3><ul>\n<li>ThreadLocal：线程本地存储，每个线程中都会有一个ThreadLcoalMap对象，用来保存各种数据</li>\n<li>作用：避免资源在多线程中共享时产生各种异常，所以每个线程自己独立存储一份进行使用</li>\n<li>使用场景:<ul>\n<li>比如JDBC的链接，每个线程可独立对数据库进行操作，某个线程进行close操作时不会对其他线程造成影响</li>\n<li>session管理等</li>\n</ul>\n</li>\n<li>实现：这个Map是Thread的属性，而ThreadLocal是一个代理工具类，用来持有这个map并对其进行操作</li>\n<li>注意点：使用时需要手动调用ThreadLocal的remove方法，尤其是当使用到线程池时，线程可能会一直存在，所以会导致内存泄漏</li>\n</ul>\n<h3 id=\"说一下-synchronized-底层实现原理？\"><a href=\"#说一下-synchronized-底层实现原理？\" class=\"headerlink\" title=\"说一下 synchronized 底层实现原理？\"></a>说一下 synchronized 底层实现原理？</h3><ul>\n<li>特性：<ul>\n<li>原子性</li>\n<li>可见性</li>\n<li>有序性</li>\n<li>可重入性：同一线程可以多次申请同一锁</li>\n</ul>\n</li>\n<li>使用场景：<ul>\n<li>修饰静态方法、成员函数、代码块</li>\n<li>真正可以锁的资源：对象</li>\n</ul>\n</li>\n<li>通过在对象头当中增加线程标记、锁标记等记录，然后三种锁（偏向锁、轻量级锁、重量级锁）根据程序运行情况使用来实现</li>\n</ul>\n<h3 id=\"synchronized-和-volatile-的区别是什么？\"><a href=\"#synchronized-和-volatile-的区别是什么？\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别是什么？\"></a>synchronized 和 volatile 的区别是什么？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>synchronized</th>\n<th>volatitle</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>本质</td>\n<td>锁定对象只能由一个线程访问</td>\n<td>告诉jvm某个变量值时不确定的，需要实时读取</td>\n</tr>\n<tr>\n<td>修饰内容</td>\n<td>变量、方法、类、代码块</td>\n<td>变量</td>\n</tr>\n<tr>\n<td>可见性、原子性</td>\n<td>只能保证可见性</td>\n<td>可见性、原子性</td>\n</tr>\n<tr>\n<td>会不会造成线程阻塞</td>\n<td>会</td>\n<td>不会</td>\n</tr>\n<tr>\n<td>编译器优化</td>\n<td>会</td>\n<td>不会</td>\n</tr>\n</tbody></table>\n<h3 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>synchronized</th>\n<th>lock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使用场景</td>\n<td>简单场景使用，并发情况简单</td>\n<td>并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断</td>\n</tr>\n<tr>\n<td>存在层次</td>\n<td>是java关键字，可修饰变量、方法、类、代码块</td>\n<td>一个类，使用时需要主动调用上锁和解锁</td>\n</tr>\n<tr>\n<td>锁实现</td>\n<td>JVM实现</td>\n<td>自己写代码调用lock API实现</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>jvm自动释放(获取锁线程执行完；程序执行异常)</td>\n<td>手动unlock，不释放会造成死锁</td>\n</tr>\n<tr>\n<td>获取锁</td>\n<td>jvm自己获取，根据锁升级规则来获取</td>\n<td>trylock，可以设置等待时间</td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td>无法判断</td>\n<td>可以获取</td>\n</tr>\n<tr>\n<td>锁类型</td>\n<td>可重入、不可中断、非公平</td>\n<td>可重入、可中断、可公平（不公平皆可）</td>\n</tr>\n<tr>\n<td>阻塞性</td>\n<td>少量阻塞</td>\n<td>大量阻塞</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>简单场景两者相似，复杂场景lock好</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>synchronized</th>\n<th>ReentrantLock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使用场景</td>\n<td>简单场景使用，并发情况简单</td>\n<td>并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断</td>\n</tr>\n<tr>\n<td>存在层次</td>\n<td>是java关键字，可修饰变量、方法、类、代码块</td>\n<td>一个类，使用时需要主动调用上锁和解锁</td>\n</tr>\n<tr>\n<td>锁实现</td>\n<td>JVM实现</td>\n<td>自己写代码调用lock API实现</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>jvm自动释放(获取锁线程执行完；程序执行异常)</td>\n<td>手动unlock，不释放会造成死锁</td>\n</tr>\n<tr>\n<td>获取锁</td>\n<td>jvm自己获取，根据锁升级规则来获取</td>\n<td>trylock，可以设置等待时间</td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td>无法判断</td>\n<td>可以获取</td>\n</tr>\n<tr>\n<td>锁类型</td>\n<td>可重入、不可中断、非公平</td>\n<td>可重入、可中断、可公平（不公平皆可）</td>\n</tr>\n<tr>\n<td>阻塞性</td>\n<td>少量阻塞</td>\n<td>大量阻塞</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>简单场景两者相似，复杂场景lock好</td>\n<td></td>\n</tr>\n<tr>\n<td>特点</td>\n<td>使用简单</td>\n<td>可以制定公平锁、非公平锁；提供Condition类来精细控制；提供等待获取锁功能</td>\n</tr>\n</tbody></table>\n<h3 id=\"atomic-的原理？\"><a href=\"#atomic-的原理？\" class=\"headerlink\" title=\"atomic 的原理？\"></a>atomic 的原理？</h3><ul>\n<li>作用：在多线程环境中保证同一时间内变量写操作只能由一个线程完成</li>\n<li>原理：基于unsafe类提供的硬件级别的原子操作实现的</li>\n<li>核心原理：即CAS操作，比如有个变量num（比如此时值为1），首先执行操作的开始会先将num的值复制一份为numCopy（值也是1）用于一会的对比，然后将num放到运算单元中进行计算，此时不会改变内存中num的值，当计算完成后得到numTmp（比如执行了加1操作，此时numTmp为2），将复制的值即numCopy与内存中现有的num的值进行比较，如果numCopy与num相等，则将numTmp复制给num，不想等就放弃赋值，意思就是防止num在执行本次操作过程中被别人改过</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"并行和并发有什么区别？\"><a href=\"#并行和并发有什么区别？\" class=\"headerlink\" title=\"并行和并发有什么区别？\"></a>并行和并发有什么区别？</h3><h4 id=\"并发：\"><a href=\"#并发：\" class=\"headerlink\" title=\"并发：\"></a>并发：</h4><ul>\n<li>在操作系统中，一个时间段内在同一个处理机上处于开始到结束之间的多个任务之间的状态，window的时间片分时调度即并发，实际是串行，但是多个任务在不停地切换，每个任务运行一小会，以实现多个任务的同时运行即并发</li>\n</ul>\n<h4 id=\"并行：\"><a href=\"#并行：\" class=\"headerlink\" title=\"并行：\"></a>并行：</h4><ul>\n<li>互不抢占资源的两个任务同时运行时，即并行</li>\n</ul>\n<h4 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h4><ul>\n<li>并发实际上是串行</li>\n<li>并发需要共享运算资源，并行不需要</li>\n<li>单cpu可以实现并发，但不能实现并行</li>\n<li>并行是真正的同时运行</li>\n</ul>\n<h3 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h3><h4 id=\"线程：\"><a href=\"#线程：\" class=\"headerlink\" title=\"线程：\"></a>线程：</h4><ul>\n<li>是进程的子任务</li>\n<li>是操作系统可识别的最小执行和调度单位</li>\n<li>是CPU调度和分配的基本单位</li>\n</ul>\n<h4 id=\"进程：\"><a href=\"#进程：\" class=\"headerlink\" title=\"进程：\"></a>进程：</h4><ul>\n<li>是对运行时程序的封装</li>\n<li>是系统进行资源调度和分配的基本单位</li>\n</ul>\n<h4 id=\"区别：-1\"><a href=\"#区别：-1\" class=\"headerlink\" title=\"区别：\"></a>区别：</h4><ul>\n<li>一个线程只能属于一个进程，一个进程可以包含多个线程，且至少有一个线程</li>\n<li>进程用友独立的内存单元，多个线程共享这部分内存</li>\n<li>进程是资源分配的最小单位，线程是cpu调度的最小单位</li>\n<li>创建、撤销、切换等操作，进程的开销要远大于线程</li>\n<li>线程间可以使用共享内存进行通信，实现起来较简单，进程间通信实现较复杂，进程间通信依赖线程</li>\n<li>进程间互相不会影响，线程挂掉时会导致整个进程挂掉</li>\n</ul>\n<h3 id=\"进程间通信方式？\"><a href=\"#进程间通信方式？\" class=\"headerlink\" title=\"进程间通信方式？\"></a>进程间通信方式？</h3><ul>\n<li>管道：<ul>\n<li>匿名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</li>\n<li>高级管道：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</li>\n<li>有名管道：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信</li>\n</ul>\n</li>\n<li>消息队列</li>\n<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>\n<li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>\n<li>共享内存：</li>\n<li>套接字</li>\n</ul>\n<h3 id=\"线程间通信方式？\"><a href=\"#线程间通信方式？\" class=\"headerlink\" title=\"线程间通信方式？\"></a>线程间通信方式？</h3><ul>\n<li>各种锁：互斥锁</li>\n<li>信号量：</li>\n<li>信号：</li>\n<li>进程间通信也能用于线程间通信，进程间通信本质上都是线程在干活</li>\n</ul>\n<h3 id=\"守护线程是什么？\"><a href=\"#守护线程是什么？\" class=\"headerlink\" title=\"守护线程是什么？\"></a>守护线程是什么？</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义:\"></a>定义:</h4><ul>\n<li>为其他线程服务的线程，比如垃圾回收线程</li>\n</ul>\n<h4 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h4><ul>\n<li>JVM结束进程时，不关心守护线程，但是用户线程存在的话，JVM不会结束进程</li>\n<li>守护线程不能持有任何需要关闭的资源，进程结束时会导致该资源出错</li>\n<li>守护线程优先级低，守护线程中创建的新线程同样是守护线程，用户线程同样，其中创建的新线程也是用户线程</li>\n</ul>\n<h3 id=\"线程分类\"><a href=\"#线程分类\" class=\"headerlink\" title=\"线程分类?\"></a>线程分类?</h3><h4 id=\"按照是否为用户自定义来区分\"><a href=\"#按照是否为用户自定义来区分\" class=\"headerlink\" title=\"按照是否为用户自定义来区分\"></a>按照是否为用户自定义来区分</h4><ul>\n<li>守护线程</li>\n<li>用户线程</li>\n</ul>\n<h3 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h3><ul>\n<li>本质上都是一样的，都需要new thread</li>\n<li>继承Thread类，重写run方法</li>\n<li>通过实现Runnable接口中的run方法</li>\n<li>通过实现Callable接口中的call方法，然后使用FutureTask进行调用<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testCode() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new TestThread());</span><br><span class=\"line\">    new Thread(futureTask).start();</span><br><span class=\"line\">    Integer result = futureTask.get();</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class TestThread implements Callable&lt;Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Integer call() throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;啦啦啦啦&quot;);</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>通过线程池创建线程：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式<ul>\n<li>newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限</li>\n<li>newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限</li>\n<li>newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务</li>\n<li>newSingleThreadExecutor()：单例线程，任何时刻只有一个线程</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h3><ul>\n<li>相同点：<ul>\n<li>都是接口</li>\n<li>都可以实现多线程</li>\n<li>都采用thread.start启动</li>\n</ul>\n</li>\n<li>不同：<ul>\n<li>Runnable的run方法没有返回值，Callable的call方法可以自定义返回值</li>\n<li>Runnable的run方法只能抛出运行时一场，且无法捕获，Callable的run方法允许抛出异常，且可以捕获</li>\n<li>Executor使用Runnable使用execute方法，使用Callable时使用submit方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程有哪些状态？\"><a href=\"#线程有哪些状态？\" class=\"headerlink\" title=\"线程有哪些状态？\"></a>线程有哪些状态？</h3><ul>\n<li>new：创建</li>\n<li>Runnable：运行中，正在执行run方法</li>\n<li>Blocked： 运行中，因被阻塞而挂起</li>\n<li>Waiting：运行中，因为某些操作在等待中，join方法会阻塞当前线程，等待该线程对象执行完成，如果已完成，就立即返回</li>\n<li>Timed Waiting：运行中，因为执行sleep，在计时等待</li>\n<li>Terminated：终止，run方法执行完毕或调用Thread的stop</li>\n</ul>\n<h3 id=\"sleep-和-wait-有什么区别？\"><a href=\"#sleep-和-wait-有什么区别？\" class=\"headerlink\" title=\"sleep() 和 wait() 有什么区别？\"></a>sleep() 和 wait() 有什么区别？</h3><ul>\n<li>调用方面：<ul>\n<li>sleep是静态方法，wait是实例方法</li>\n<li>wait只能在同步情况下调用，sleep不需要</li>\n<li>wait是用于线程间通信的，sleep是用于当前线程</li>\n</ul>\n</li>\n<li>锁及资源：<ul>\n<li>线程进入wait状态时会释放持有的对象锁，但sleep不会</li>\n<li>进入wait状态的线程使用notify和notifyAll可以再次唤醒，进入sleep状态的线程不能被唤醒</li>\n</ul>\n</li>\n<li>异常捕获：<ul>\n<li>sleep需要捕获或者抛出异常，wait/notify/notifyAll不需要</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify()和 notifyAll()有什么区别？\"></a>notify()和 notifyAll()有什么区别？</h3><ul>\n<li>notify唤醒对象的等待池中的一个线程进入锁池，notifyAll唤醒等待池中的所有线程进入锁池</li>\n<li>等待池：线程A调用了对象o的wait方法，A就会释放o的锁，进入o的等待池，等待池中的线程不会竞争o的锁</li>\n<li>锁池：获取了对象o的锁，才能执行synchronized代码，同一时间内，只有一个线程可以获得该锁，其他线程只能在锁池中等待，锁池中的线程会竞争对象锁，等待池中的线程不会</li>\n</ul>\n<h3 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h3><ul>\n<li>run里面是线程需要计算的内容，start就是创建新线程然后调用一下run，基于此区别自己说就好了</li>\n</ul>\n<h3 id=\"创建线程池有哪几种方式？\"><a href=\"#创建线程池有哪几种方式？\" class=\"headerlink\" title=\"创建线程池有哪几种方式？\"></a>创建线程池有哪几种方式？</h3><ul>\n<li>使用Executors创建线程池：通过Executors中的静态方法来创建新线程，newCachedThreadPool()最推荐，只有当该方式出现问题时，比如有较多耗时任务出现导致需要不停创建新线程时，才需要考虑使用其它方式<ul>\n<li>newCachedThreadPool() ：缓存型线程池，会复用旧线程，适合快速的异步任务，总线程数没有上限</li>\n<li>newFixedThreadPool(int)：缓存型线程池，会复用旧线程，总线程数有上限</li>\n<li>newScheduledThreadPool(int)：调度型线程池，可以定时或周期性执行任务</li>\n<li>newSingleThreadExecutor()：单例线程，任何时刻只有一个线程</li>\n</ul>\n</li>\n<li>通过ThreadPoolExecutor创建自定义线程池</li>\n</ul>\n<h3 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h3><ul>\n<li>running：接收新任务，处理队列任务</li>\n<li>shutdown：停止接收新任务，处理队列任务</li>\n<li>stop：停止接收新任务，停止处理队列任务，停止正在处理的任务</li>\n<li>tidying：所有任务被终结，有效线程为0，会触发terminated方法</li>\n<li>terminated：当terminated执行结束，销毁状态</li>\n</ul>\n<h3 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit()和 execute()方法有什么区别？\"></a>线程池中 submit()和 execute()方法有什么区别？</h3><ul>\n<li>同<ul>\n<li>都是线程池的方法</li>\n</ul>\n</li>\n<li>异<ul>\n<li>execute只能传入Runnable任务，submit可以传入Runnable和Callable任务</li>\n<li>execute会直接抛出异常，submit会吃掉异常，但是可以通过future的get方法将异常重新抛出</li>\n<li>execute所属顶层接口是Executor，submit所属顶层接口是ExecutorService</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在-java-程序中怎么保证多线程的运行安全？\"><a href=\"#在-java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"在 java 程序中怎么保证多线程的运行安全？\"></a>在 java 程序中怎么保证多线程的运行安全？</h3><ul>\n<li>保证安全需要遵守的特性：<ul>\n<li>原子性：一个或者多个操作在CPU执行的过程中不被中断的特性</li>\n<li>可见性：一个线程对共享变量的修改，另一个线程能立刻看到</li>\n<li>有序性：程序按照代码顺序进行执行</li>\n</ul>\n</li>\n<li>安全隐患：<ul>\n<li>缓存对可见性的影响</li>\n<li>线程切换导致CPU执行终端，对原子性的影响</li>\n<li>编译优化带来的有序性问题</li>\n</ul>\n</li>\n<li>解决方案：<ul>\n<li>JDK Atomic开头的原子类、synchronized、lock，可解决原子性问题</li>\n<li>synchronized、volatile、lock可以解决可见性问题</li>\n<li>Happen-before可解决有序性问题</li>\n</ul>\n</li>\n<li>Happen-before：<ul>\n<li>程序次序规则：在一个线程内，按照控制流顺序，书写在前面的操作发生早于后面的操作</li>\n<li>管道锁定规则：unlock操作发生遭遇后面对同一个锁的lock操作</li>\n<li>volatile规则：对一个变量的写操作早于后面的读操作</li>\n<li>线程启动规则：Thread的start操作早于线程的任何其他行为</li>\n<li>线程终止规则：Thread的销毁操作发生与线程的所有其他行为之后</li>\n<li>线程中断规则：对线程的interrupt的调用发生于被中断线程的代码检测到中断之前</li>\n<li>对象销毁规则：对象的初始化完成、构造完成早于销毁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"多线程锁的升级原理是什么？\"><a href=\"#多线程锁的升级原理是什么？\" class=\"headerlink\" title=\"多线程锁的升级原理是什么？\"></a>多线程锁的升级原理是什么？</h3><ul>\n<li><a href=\"https://www.cnblogs.com/jxxblogs/p/11890563.html\">参考文章</a></li>\n<li>锁分级原因：降低资源消耗，没有优化之前，synchronized是重量级锁（悲观锁），wait、notify、notifyAll切换线程状态非常消耗资源，而线程的挂起和唤醒时间很短，这样会导致浪费资源，影响应能，所以JVM对synchronized进行了优化，把锁分成了无锁、偏向锁、轻量级锁、重量级锁<ul>\n<li>切换原因：当JVM检测到不同的竞争状态时，会根据需要自动切换到合适的锁</li>\n<li>特点：只能从低到高，不能从高到低</li>\n<li>位置：对象头的Mark Word里</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>CAS：compareAndSwap，比较并替换<ul>\n<li>CAS包含三个操作数：内存地址V、预期值A、即将更新的目标值B</li>\n<li>使用场景：当一个线程要修改某个变量的值时，发现被其他线程修改过了，此时就会放弃修改，实现逻辑加锁</li>\n<li>特点：逻辑上避免加锁</li>\n<li>作用：比较并替换</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>锁级别从低到高：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁<ul>\n<li>无锁：不对资源进行锁定，所有线程都可以同时读写同一资源、但只有一个线程可以成功，其他线程需要不断重试才能成功</li>\n<li>偏向锁：对象代码一致被同一线程执行，不存在多个线程竞争，该线程在后续执行中自动获取锁，降低获取锁带来的性能开销。偏向指的就是偏向第一个加锁线程，该线程不会主动释放锁，当其他线程尝试竞争偏向锁时才会被释放。<ul>\n<li>撤销：在没有字节码执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否被锁定，如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，如果线程处于活跃状态，就升级为轻量级锁</li>\n</ul>\n</li>\n<li>轻量级锁：当对象锁时偏向锁，且对象被第二个线程访问时，此时偏向锁会升级为轻量级锁，第二个线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。<ul>\n<li>升级重量级锁1：当只有一个等待线程时，该线程会通过自旋进行等待，但是当自旋超过一定次数时，轻量级锁会升级成重量级锁</li>\n<li>升级重量级锁2：当一个线程持有锁，另一个线程在自旋等待，此时再有一个线程来访问时，轻量级锁会升级为重量级锁</li>\n</ul>\n</li>\n<li>重量级锁：当一个线程获取锁之后，其余所有等待线程都处于阻塞状态<ul>\n<li>实现：重量级锁通过对象内的监视器（monitor）实现，monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户状态切换为内核态，切换成本很高</li>\n</ul>\n</li>\n<li>synchronized优化之锁消除：编译时对上线文进行扫描，去除不可能存在共享资源竞争的锁，消除没必要的锁，节约资源</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>锁升级过程：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>默认无锁，当程序执行到同步块时，<em><strong>判断对象头中保存的threadId是否是当前线程</strong></em></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>是：该线程获得偏向锁，此时不需要CAS来加、撤销锁，偏向锁是最简单的线程锁，适合某线程频繁访问同一对象场景</td>\n<td>否：<em><strong>判断偏向锁标识</strong></em></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>0：即无锁状态，此时需使用CAS竞争锁</td>\n<td>1：即偏向锁状态，使用CAS将对象头中的锁信息指向当前线程，并触发偏向锁撤销（有竞争才会有偏向锁撤销）</td>\n</tr>\n<tr>\n<td>当其它线程尝试竞争偏向锁，且程序到达全局安全点（即无正在运行代码），此时JVM会<em><strong>判断对象头中记录的线程是否存活</strong></em></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>未存活：对象被重置为无锁状态，其他线程可竞争偏向锁</td>\n<td>存活：查找该线程栈帧信息，<em><strong>判断是否需要继续持有该对象</strong></em></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>需要：暂停该线程，撤销偏向锁，升级为轻量级锁</td>\n<td>不需要：将该对象设置为无锁状态，其他线程可竞争偏向锁</td>\n</tr>\n<tr>\n<td></td>\n<td>轻量级锁：当有多个线程竞争一个偏向锁时，会频繁产生偏向锁撤销，此时JVM会将对象头中的锁标识升级为轻量级锁，多个线程通过自旋来继续获取锁</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>重量级锁：有多个线程通过自旋获取锁，进入到非常激烈状态时，会非常消耗cpu资源，当自旋达到一定次数时（轻量级切换重量级的判断逻辑），JVM会将轻量级锁升级为重量级锁，重量级锁当获取锁失败时会让线程阻塞，重量级锁缺点是线程会频繁进行上下文切换</td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>锁比较：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>偏向锁</th>\n<th>轻量级锁</th>\n<th>重量级锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使用场景</td>\n<td>一个同步代码块只有一个线程频繁访问</td>\n<td>多条线程进入同步块，线程进入时间错开因而并未争抢</td>\n<td>发生了争抢，多个线程进入同步块并竞争锁</td>\n</tr>\n<tr>\n<td>本质</td>\n<td>取消同步操作</td>\n<td>CAS操作代替互斥同步</td>\n<td>互斥同步</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>不阻塞，执行效率高 (不需要使用CAS来获取锁和撤销锁，只需要对比threadId，效率高)</td>\n<td>不会阻塞</td>\n<td>不会空耗cpu</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>使用场景局限，若竞争产生，会有偏向锁撤销的消耗</td>\n<td>长时间获取不到会空耗cpu</td>\n<td>阻塞，上下文切换，重量级操作，消耗系统资源</td>\n</tr>\n</tbody></table>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><h4 id=\"线程死锁\"><a href=\"#线程死锁\" class=\"headerlink\" title=\"线程死锁\"></a>线程死锁</h4><ul>\n<li>定义：两个及以上的线程因为互相等待而被阻塞的现象即死锁</li>\n<li>死锁示例：两个线程互相等待对方持有的锁，即死锁<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  public void add(int m) &#123;</span><br><span class=\"line\">    synchronized(lockA) &#123; // 获得lockA的锁</span><br><span class=\"line\">        this.value += m;</span><br><span class=\"line\">        synchronized(lockB) &#123; // 获得lockB的锁</span><br><span class=\"line\">            this.another += m;</span><br><span class=\"line\">        &#125; // 释放lockB的锁</span><br><span class=\"line\">    &#125; // 释放lockA的锁</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void dec(int m) &#123;</span><br><span class=\"line\">    synchronized(lockB) &#123; // 获得lockB的锁</span><br><span class=\"line\">        this.another -= m;</span><br><span class=\"line\">        synchronized(lockA) &#123; // 获得lockA的锁</span><br><span class=\"line\">            this.value -= m;</span><br><span class=\"line\">        &#125; // 释放lockA的锁</span><br><span class=\"line\">    &#125; // 释放lockB的锁</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>导致死锁的原因：<ul>\n<li>已持有锁的线程请求新锁</li>\n<li>两个及以上的线程同时发出新锁请求</li>\n<li>两个及以上的线程形成一个新锁申请循环链，每个线程都在等待链中下一个线程持有的锁</li>\n</ul>\n</li>\n<li>分类：<ul>\n<li>潜在死锁：不一定发生，但可能在程序运行的任何阶段发生</li>\n<li>实际死锁：程序执行过程中的死锁，实际死锁会导致线程挂起，但进程不一定挂起</li>\n</ul>\n</li>\n<li>java线程锁是可重入锁，即同一个锁可以被同一线程多次获取到，线程对锁有记录，获取到加1，完成代码块减一，减到0时，释放锁<ul>\n<li>例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  public class Counter &#123;</span><br><span class=\"line\">    private int count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void add(int n) &#123;</span><br><span class=\"line\">        if (n &lt; 0) &#123;</span><br><span class=\"line\">            dec(-n);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void dec(int n) &#123;</span><br><span class=\"line\">        count += n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"进程死锁\"><a href=\"#进程死锁\" class=\"headerlink\" title=\"进程死锁\"></a>进程死锁</h4></li>\n</ul>\n</li>\n<li>定义：进程竞争共享资源时出现的无线循环等待问题</li>\n<li>产生进程死锁必要条件：<ul>\n<li>互斥条件：共享资源单位时间内只能被一个进程占有</li>\n<li>不可抢占条件：某进程占有的资源未使用完之前，其他进程不得抢夺</li>\n<li>占有且申请条件：进程已占用的资源，在申请新资源时，仍继续占有已占有资源</li>\n<li>循环等待条件：存在一个循环等待环，第一个依赖第二个，第n个依赖第1个</li>\n</ul>\n</li>\n<li>预防死锁：打破产生的四个条件之中的一个或多个</li>\n</ul>\n<h3 id=\"怎么防止死锁？\"><a href=\"#怎么防止死锁？\" class=\"headerlink\" title=\"怎么防止死锁？\"></a>怎么防止死锁？</h3><ul>\n<li>规避四个产生条件来设计代码，以避免</li>\n</ul>\n<h4 id=\"避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\"><a href=\"#避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\" class=\"headerlink\" title=\"避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁\"></a>避免死锁典型算法-银行家算法：设法保证系统动态分配资源后不进入不安全状态，以避免死锁</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_33414271/article/details/80245715\">参考文章1</a><br><a href=\"https://baike.baidu.com/item/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/1679781\">参考文章2</a></li>\n<li>安全状态：某一时刻，某进程序列中的进程都可以顺利完成，则此时状态为安全状态，系统中安全状态与不安全状态是共存的，安全状态一定不死锁，不安全状态不一定会死锁</li>\n<li>安全状态检测：系统先尝试分配资源给申请进程，然后使用剩余资源计算是否能满足进程队列中的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态，如果有进程都可以执行完毕，然后假设回收资源后，也可以让其他所有进程队列中的进程都执行完毕，则系统处于安全状态，然后会根据分配顺序生成安全序列，然后执行</li>\n<li>判断某个状态是否安全：根据安全性算法进行计算，如果可以找到某种安全序列即安全</li>\n<li>判断某个请求系统是否可满足：根据安全性算法进行检查，如果分配后剩余的资源无法满足进程队列中的任一进程需求的话，即不能分配，否则可分配</li>\n</ul>\n<h3 id=\"ThreadLocal-是什么？有哪些使用场景？\"><a href=\"#ThreadLocal-是什么？有哪些使用场景？\" class=\"headerlink\" title=\"ThreadLocal 是什么？有哪些使用场景？\"></a>ThreadLocal 是什么？有哪些使用场景？</h3><ul>\n<li>ThreadLocal：线程本地存储，每个线程中都会有一个ThreadLcoalMap对象，用来保存各种数据</li>\n<li>作用：避免资源在多线程中共享时产生各种异常，所以每个线程自己独立存储一份进行使用</li>\n<li>使用场景:<ul>\n<li>比如JDBC的链接，每个线程可独立对数据库进行操作，某个线程进行close操作时不会对其他线程造成影响</li>\n<li>session管理等</li>\n</ul>\n</li>\n<li>实现：这个Map是Thread的属性，而ThreadLocal是一个代理工具类，用来持有这个map并对其进行操作</li>\n<li>注意点：使用时需要手动调用ThreadLocal的remove方法，尤其是当使用到线程池时，线程可能会一直存在，所以会导致内存泄漏</li>\n</ul>\n<h3 id=\"说一下-synchronized-底层实现原理？\"><a href=\"#说一下-synchronized-底层实现原理？\" class=\"headerlink\" title=\"说一下 synchronized 底层实现原理？\"></a>说一下 synchronized 底层实现原理？</h3><ul>\n<li>特性：<ul>\n<li>原子性</li>\n<li>可见性</li>\n<li>有序性</li>\n<li>可重入性：同一线程可以多次申请同一锁</li>\n</ul>\n</li>\n<li>使用场景：<ul>\n<li>修饰静态方法、成员函数、代码块</li>\n<li>真正可以锁的资源：对象</li>\n</ul>\n</li>\n<li>通过在对象头当中增加线程标记、锁标记等记录，然后三种锁（偏向锁、轻量级锁、重量级锁）根据程序运行情况使用来实现</li>\n</ul>\n<h3 id=\"synchronized-和-volatile-的区别是什么？\"><a href=\"#synchronized-和-volatile-的区别是什么？\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别是什么？\"></a>synchronized 和 volatile 的区别是什么？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>synchronized</th>\n<th>volatitle</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>本质</td>\n<td>锁定对象只能由一个线程访问</td>\n<td>告诉jvm某个变量值时不确定的，需要实时读取</td>\n</tr>\n<tr>\n<td>修饰内容</td>\n<td>变量、方法、类、代码块</td>\n<td>变量</td>\n</tr>\n<tr>\n<td>可见性、原子性</td>\n<td>只能保证可见性</td>\n<td>可见性、原子性</td>\n</tr>\n<tr>\n<td>会不会造成线程阻塞</td>\n<td>会</td>\n<td>不会</td>\n</tr>\n<tr>\n<td>编译器优化</td>\n<td>会</td>\n<td>不会</td>\n</tr>\n</tbody></table>\n<h3 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>synchronized</th>\n<th>lock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使用场景</td>\n<td>简单场景使用，并发情况简单</td>\n<td>并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断</td>\n</tr>\n<tr>\n<td>存在层次</td>\n<td>是java关键字，可修饰变量、方法、类、代码块</td>\n<td>一个类，使用时需要主动调用上锁和解锁</td>\n</tr>\n<tr>\n<td>锁实现</td>\n<td>JVM实现</td>\n<td>自己写代码调用lock API实现</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>jvm自动释放(获取锁线程执行完；程序执行异常)</td>\n<td>手动unlock，不释放会造成死锁</td>\n</tr>\n<tr>\n<td>获取锁</td>\n<td>jvm自己获取，根据锁升级规则来获取</td>\n<td>trylock，可以设置等待时间</td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td>无法判断</td>\n<td>可以获取</td>\n</tr>\n<tr>\n<td>锁类型</td>\n<td>可重入、不可中断、非公平</td>\n<td>可重入、可中断、可公平（不公平皆可）</td>\n</tr>\n<tr>\n<td>阻塞性</td>\n<td>少量阻塞</td>\n<td>大量阻塞</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>简单场景两者相似，复杂场景lock好</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>synchronized</th>\n<th>ReentrantLock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使用场景</td>\n<td>简单场景使用，并发情况简单</td>\n<td>并发量大，竞争激烈时，需要的操作非常灵活时，比如需要实现中断</td>\n</tr>\n<tr>\n<td>存在层次</td>\n<td>是java关键字，可修饰变量、方法、类、代码块</td>\n<td>一个类，使用时需要主动调用上锁和解锁</td>\n</tr>\n<tr>\n<td>锁实现</td>\n<td>JVM实现</td>\n<td>自己写代码调用lock API实现</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>jvm自动释放(获取锁线程执行完；程序执行异常)</td>\n<td>手动unlock，不释放会造成死锁</td>\n</tr>\n<tr>\n<td>获取锁</td>\n<td>jvm自己获取，根据锁升级规则来获取</td>\n<td>trylock，可以设置等待时间</td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td>无法判断</td>\n<td>可以获取</td>\n</tr>\n<tr>\n<td>锁类型</td>\n<td>可重入、不可中断、非公平</td>\n<td>可重入、可中断、可公平（不公平皆可）</td>\n</tr>\n<tr>\n<td>阻塞性</td>\n<td>少量阻塞</td>\n<td>大量阻塞</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>简单场景两者相似，复杂场景lock好</td>\n<td></td>\n</tr>\n<tr>\n<td>特点</td>\n<td>使用简单</td>\n<td>可以制定公平锁、非公平锁；提供Condition类来精细控制；提供等待获取锁功能</td>\n</tr>\n</tbody></table>\n<h3 id=\"atomic-的原理？\"><a href=\"#atomic-的原理？\" class=\"headerlink\" title=\"atomic 的原理？\"></a>atomic 的原理？</h3><ul>\n<li>作用：在多线程环境中保证同一时间内变量写操作只能由一个线程完成</li>\n<li>原理：基于unsafe类提供的硬件级别的原子操作实现的</li>\n<li>核心原理：即CAS操作，比如有个变量num（比如此时值为1），首先执行操作的开始会先将num的值复制一份为numCopy（值也是1）用于一会的对比，然后将num放到运算单元中进行计算，此时不会改变内存中num的值，当计算完成后得到numTmp（比如执行了加1操作，此时numTmp为2），将复制的值即numCopy与内存中现有的num的值进行比较，如果numCopy与num相等，则将numTmp复制给num，不想等就放弃赋值，意思就是防止num在执行本次操作过程中被别人改过</li>\n</ul>\n"},{"title":"容器","date":"2021-12-06T08:34:38.000Z","_content":"\n## 容器简介\n* 作用：持有和增删对象\n* 分类：\n  * Collection：一个独立元素组成的队列，这些元素都遵守一个或多个相同的规则\n  * Map：一组由成对的“键值对”组成的对象\n\n## Collection：一个接口，定义了对集合对象操作的通用方法\n### 介绍：\n* java.util.Collection是一个接口，定义了对集合对象操作的一些通用方法\n* java本身没有直接提供Collection的实现类，而是提供了Collection的接口子类，比如List和Set\n* 关联类：Collections，一个都是静态方法的工具类，且该类不能被实例化（构造方法私有了）\n\n\n### 组成类：\n  * List\n    * LinkedList\n    * ArrayList\n    * Vector\n      * Stack\n  * Set\n    * HashSet\n    * TreeSet\n    * LinkedHashSet\n\n### Collection主要方法：\n  * boolean addObject(Object o): 添加元素到集合\n  * boolean removeObject(Object o): 从集合中删除某个元素\n  * int size(): 集合中元素数量\n  * boolean contains(Object o): 查找集合中是否包含某个元素\n  * boolean isEmpty：判断集合中是否为空\n  * Iterator iterator(): 返回一个迭代器\n  * boolean containsAll(Collection c): 判断是否包含另一个集合中的全部元素\n  * boolean addAll(Collection c)：将另一个集合里面的所有元素添加到当前集合中\n  * void clear(): 删除集合中所有元素\n  * void removeAll(Collection c)：从当前集合中删除c中的所有元素\n  * void retainAll(Collection c)：从当前集合中删除c中没有的元素\n\n\n### List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\n  * 数组和list区别：\n    * 数组是静态的，即长度固定，且所有元素保存在一块连续的内存区域中，list的长度可变\n    * 数组是多维，list的实现类ArrayList是一维\n    * 数组是java中最基本的数据结构，没有类对应，list本身是一个接口类，list有实现类ArrayList等，即ArrayList功能比Array多\n    * list的实现类ArrayList即基于数组实现\n  * 实现类：ArrayList、LinkedList、Vector、Stack\n  * LinkedList（链表）：即java的链表，有单向和双向链表\n    * 特点：相比ArrayList，适合增删操作，不适合修改和查找\n    * 使用场景：适合通过循环迭代使用某些元素，适合在表中任意位置增删元素\n    * 注意：LinkedList没有同步方法，多线程访问时需要自己实现访问同步，使用Collections.synchronizedList可以创建一个同步list解决\n  * ArrayList（可变数组）：即java的可变数组\n    * 特点：非同步，跟LinkedList一样\n    * 使用场景：适合快速访问任一元素，适合在表尾执行增删操作\n  * Vector：类似ArrayList，但是是同步的\n  * Stack：继承Vector，即先进后出的堆\n\n### Set：不包含重复元素的Collection，最多有一个null元素\n* 实现类：HashSet、LinkedHashSet、TreeSet\n* HashSet：基于HashMap实现，一个不包含重复元素的无序集合，非线程安全\n* TreeSet：基于TreeMap实现，一个有序不包含重复元素的集合\n* LinkedHashSet：继承于HashSet，一个按照插入顺序排序的有序且不包含重复元素的集合\n\n\n\n## Map：一组key-value集合\n### 组成类\n  * HashMap\n  * TreeMap\n  * HashTable\n  * WeakHashMap\n  * ConcurrentHashMap\n  * LinkedHashMap\n\n### 主要方法\n* boolean equals(Object o)：比较两个对象是否相等\n* boolean remove(Object o)：删除对象\n* put: 向map中添加key-value\n* size：map中key-value个数\n\n### ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\n\n### HashMap: 非同步，无序，允许key、value为null的map\n\n### WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\n\n### TreeMap：依据比较规则对key进行排序的map\n\n### LinkedHashMap：一个有序的HashMap\n\n## 相关面试题\n### Collection 和 Collections 有什么区别\n* Collection是一个接口，给集合操作提供一些基础功能方法，Collections是一个均为静态方法的集合工具类，两者均不能实例化\n\n### List、Set、Map 之间的区别是什么？\n* List和Set是集合，是一堆元素按照一定规则或者无规则的容器，Map内部的元素形式是Key-value\n* List内部元素是可以重复的，Set内部元素不能重复，Map内部Key不能重复，value可以重复\n* List和Set都继承Collection，Map没有父接口类\n\n### HashMap 和 HashTable 有什么区别？\n* HashTable官方已经淘汰，使用非常相似的ConcurrentHashMap替代\n* HashTable是线程安全，支持同步访问，HashMap不支持同步访问，其他方面就比较像\n\n### 如何决定使用 HashMap 还是 TreeMap？\n* 需要根据key进行排序的情况下使用TreeMap，其余情况下建议HashMap，HashMap性能较好\n\n\n### HashMap 的实现原理？\n\n#### JDK7和JDK8中HashMap实现的差别\n  * 1.7采用的是数组+链表，1.8采用的是数组+链表/红黑树\n  * 1.7扩容时需要重新计算哈希值和索引位置，1.8不需要重新计算哈希值，巧妙的采用和扩容后容量进行&操作来计算新的索引位置\n  * 1.7是采用表头插入法插入链表，1.8采用是尾部插入法\n  * 1.7中采用表头插入法，在扩容时会改变链表中元素顺序，以至于在并发场景下会导致链表成环问题，在1.8中采用的尾部插入法，在扩容时不会改变链表中元素顺序，所以就没有该问题\n\n#### HashMap组成?\n* hashMap使用数组+链表的方式来存储数据，数组元素为Entry组成的链表，当链表长度大于8的时候，JDK1.8会将链表转成红黑树\n\n#### Hash冲突如何解决?\n* 当两个不同的key进行hash后取得的下标相同时，就会将这两个key-value放到对应的数组下标中的链表中\n\n#### HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用?\n* 使用LinkedList替换数组实现HashMap是否可行，然后为什么不会用：当然可行\n* 数组的查找效率比LinkedList高，LinkedList是使用链表实现的\n* ArrayList底层也是使用数组实现，但是由于扩容机制问题，不利于HashMap的取模运算，HashMap中的数组扩容时2倍扩容，ArrayList是1.5倍扩容\n\n#### HashMap查找key的位置\n* 首先对key进行hashCode，同时使用HashMap对应的数组长度进行取余等操作找到对应的数组下标之后，再在这个下标对应的链表中查找\n\n#### HashMap扩容\n* 创建一个2倍容量的数组，将原数组的元素散列后放到新数组中\n\n### HashSet实现原理？\n* HashSet使用HashMap来实现，HashSet的元素都是保存在HashMap的key上，value是一个统一的static final对象\n\n### ArrayList 和 LinkedList 的区别是什么？\n* 都是list接口的实现类\n* ArrayList基于数组实现，LinkedList基于链表实现\n* ArrayList相对更适合快速访问元素，LinkedList相对更适合快速插入删除元素\n\n### 如何实现数组和 List 之间的转换？\n* list转数组：\n  * 循环一个个放\n  * toArray方法\n* 数组转list：\n  * 循环一个个放\n  * asList方法\n\n### ArrayList 和 Vector 的区别是什么？\n* Vector是同步版的ArrayList，是线程安全的\n* Vector扩容时是当前的2倍，ArrayList扩容时是当前的1.5倍\n\n### Array 和 ArrayList 有何区别？\n* ArrayList基于Array实现\n* ArrayList是动态的，Array是静态\n* ArrayList相当于是可变Array\n* ArrayList不能存储基本数据类型，Array都可以\n* Array中元素类型相同，ArrayList可以不同\n\n\n### 在 Queue 中 poll()和 remove()有什么区别？\n* 相同：都是从删除头部元素并返回该元素\n* 不同：队列为空时，remove()会抛出NoSuchElementException异常，poll()会返回null\n\n### 哪些集合类是线程安全的？\n* Vector\n* Stack\n* Hashtable\n* java.util.concurrent包下的类，ArrayBlockingQueue、ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque\n\n\n### 迭代器 Iterator 是什么？\n* 定义了访问集合的方法，可以迭代HashSet、ArrayList等集合\n* 具有next、hasNext、remove等功能\n* 迭代器是一种设计模式\n* remove会抛异常\n\n\n### Iterator 和 ListIterator 有什么区别？\n* Iterator可以遍历set和list，ListIterator只能遍历list\n* ListIterator可以双向遍历list，Iterator只能单向\n* Iterator可以读、删，ListIterator可以读、删、增\n* Iterator无法获取集合中的索引，ListIterator可以获取集合中的索引\n\n### 怎么确保一个集合不能被修改？\n* 使用Collections类提供的方法即可\n  * Collections.unmodifiableList(List)\n  * Collections.unmodifiableSet(Set)\n","source":"_posts/Q&A/Java/容器.md","raw":"---\ntitle: 容器\ndate: 2021-12-06 16:34:38\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## 容器简介\n* 作用：持有和增删对象\n* 分类：\n  * Collection：一个独立元素组成的队列，这些元素都遵守一个或多个相同的规则\n  * Map：一组由成对的“键值对”组成的对象\n\n## Collection：一个接口，定义了对集合对象操作的通用方法\n### 介绍：\n* java.util.Collection是一个接口，定义了对集合对象操作的一些通用方法\n* java本身没有直接提供Collection的实现类，而是提供了Collection的接口子类，比如List和Set\n* 关联类：Collections，一个都是静态方法的工具类，且该类不能被实例化（构造方法私有了）\n\n\n### 组成类：\n  * List\n    * LinkedList\n    * ArrayList\n    * Vector\n      * Stack\n  * Set\n    * HashSet\n    * TreeSet\n    * LinkedHashSet\n\n### Collection主要方法：\n  * boolean addObject(Object o): 添加元素到集合\n  * boolean removeObject(Object o): 从集合中删除某个元素\n  * int size(): 集合中元素数量\n  * boolean contains(Object o): 查找集合中是否包含某个元素\n  * boolean isEmpty：判断集合中是否为空\n  * Iterator iterator(): 返回一个迭代器\n  * boolean containsAll(Collection c): 判断是否包含另一个集合中的全部元素\n  * boolean addAll(Collection c)：将另一个集合里面的所有元素添加到当前集合中\n  * void clear(): 删除集合中所有元素\n  * void removeAll(Collection c)：从当前集合中删除c中的所有元素\n  * void retainAll(Collection c)：从当前集合中删除c中没有的元素\n\n\n### List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\n  * 数组和list区别：\n    * 数组是静态的，即长度固定，且所有元素保存在一块连续的内存区域中，list的长度可变\n    * 数组是多维，list的实现类ArrayList是一维\n    * 数组是java中最基本的数据结构，没有类对应，list本身是一个接口类，list有实现类ArrayList等，即ArrayList功能比Array多\n    * list的实现类ArrayList即基于数组实现\n  * 实现类：ArrayList、LinkedList、Vector、Stack\n  * LinkedList（链表）：即java的链表，有单向和双向链表\n    * 特点：相比ArrayList，适合增删操作，不适合修改和查找\n    * 使用场景：适合通过循环迭代使用某些元素，适合在表中任意位置增删元素\n    * 注意：LinkedList没有同步方法，多线程访问时需要自己实现访问同步，使用Collections.synchronizedList可以创建一个同步list解决\n  * ArrayList（可变数组）：即java的可变数组\n    * 特点：非同步，跟LinkedList一样\n    * 使用场景：适合快速访问任一元素，适合在表尾执行增删操作\n  * Vector：类似ArrayList，但是是同步的\n  * Stack：继承Vector，即先进后出的堆\n\n### Set：不包含重复元素的Collection，最多有一个null元素\n* 实现类：HashSet、LinkedHashSet、TreeSet\n* HashSet：基于HashMap实现，一个不包含重复元素的无序集合，非线程安全\n* TreeSet：基于TreeMap实现，一个有序不包含重复元素的集合\n* LinkedHashSet：继承于HashSet，一个按照插入顺序排序的有序且不包含重复元素的集合\n\n\n\n## Map：一组key-value集合\n### 组成类\n  * HashMap\n  * TreeMap\n  * HashTable\n  * WeakHashMap\n  * ConcurrentHashMap\n  * LinkedHashMap\n\n### 主要方法\n* boolean equals(Object o)：比较两个对象是否相等\n* boolean remove(Object o)：删除对象\n* put: 向map中添加key-value\n* size：map中key-value个数\n\n### ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\n\n### HashMap: 非同步，无序，允许key、value为null的map\n\n### WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\n\n### TreeMap：依据比较规则对key进行排序的map\n\n### LinkedHashMap：一个有序的HashMap\n\n## 相关面试题\n### Collection 和 Collections 有什么区别\n* Collection是一个接口，给集合操作提供一些基础功能方法，Collections是一个均为静态方法的集合工具类，两者均不能实例化\n\n### List、Set、Map 之间的区别是什么？\n* List和Set是集合，是一堆元素按照一定规则或者无规则的容器，Map内部的元素形式是Key-value\n* List内部元素是可以重复的，Set内部元素不能重复，Map内部Key不能重复，value可以重复\n* List和Set都继承Collection，Map没有父接口类\n\n### HashMap 和 HashTable 有什么区别？\n* HashTable官方已经淘汰，使用非常相似的ConcurrentHashMap替代\n* HashTable是线程安全，支持同步访问，HashMap不支持同步访问，其他方面就比较像\n\n### 如何决定使用 HashMap 还是 TreeMap？\n* 需要根据key进行排序的情况下使用TreeMap，其余情况下建议HashMap，HashMap性能较好\n\n\n### HashMap 的实现原理？\n\n#### JDK7和JDK8中HashMap实现的差别\n  * 1.7采用的是数组+链表，1.8采用的是数组+链表/红黑树\n  * 1.7扩容时需要重新计算哈希值和索引位置，1.8不需要重新计算哈希值，巧妙的采用和扩容后容量进行&操作来计算新的索引位置\n  * 1.7是采用表头插入法插入链表，1.8采用是尾部插入法\n  * 1.7中采用表头插入法，在扩容时会改变链表中元素顺序，以至于在并发场景下会导致链表成环问题，在1.8中采用的尾部插入法，在扩容时不会改变链表中元素顺序，所以就没有该问题\n\n#### HashMap组成?\n* hashMap使用数组+链表的方式来存储数据，数组元素为Entry组成的链表，当链表长度大于8的时候，JDK1.8会将链表转成红黑树\n\n#### Hash冲突如何解决?\n* 当两个不同的key进行hash后取得的下标相同时，就会将这两个key-value放到对应的数组下标中的链表中\n\n#### HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用?\n* 使用LinkedList替换数组实现HashMap是否可行，然后为什么不会用：当然可行\n* 数组的查找效率比LinkedList高，LinkedList是使用链表实现的\n* ArrayList底层也是使用数组实现，但是由于扩容机制问题，不利于HashMap的取模运算，HashMap中的数组扩容时2倍扩容，ArrayList是1.5倍扩容\n\n#### HashMap查找key的位置\n* 首先对key进行hashCode，同时使用HashMap对应的数组长度进行取余等操作找到对应的数组下标之后，再在这个下标对应的链表中查找\n\n#### HashMap扩容\n* 创建一个2倍容量的数组，将原数组的元素散列后放到新数组中\n\n### HashSet实现原理？\n* HashSet使用HashMap来实现，HashSet的元素都是保存在HashMap的key上，value是一个统一的static final对象\n\n### ArrayList 和 LinkedList 的区别是什么？\n* 都是list接口的实现类\n* ArrayList基于数组实现，LinkedList基于链表实现\n* ArrayList相对更适合快速访问元素，LinkedList相对更适合快速插入删除元素\n\n### 如何实现数组和 List 之间的转换？\n* list转数组：\n  * 循环一个个放\n  * toArray方法\n* 数组转list：\n  * 循环一个个放\n  * asList方法\n\n### ArrayList 和 Vector 的区别是什么？\n* Vector是同步版的ArrayList，是线程安全的\n* Vector扩容时是当前的2倍，ArrayList扩容时是当前的1.5倍\n\n### Array 和 ArrayList 有何区别？\n* ArrayList基于Array实现\n* ArrayList是动态的，Array是静态\n* ArrayList相当于是可变Array\n* ArrayList不能存储基本数据类型，Array都可以\n* Array中元素类型相同，ArrayList可以不同\n\n\n### 在 Queue 中 poll()和 remove()有什么区别？\n* 相同：都是从删除头部元素并返回该元素\n* 不同：队列为空时，remove()会抛出NoSuchElementException异常，poll()会返回null\n\n### 哪些集合类是线程安全的？\n* Vector\n* Stack\n* Hashtable\n* java.util.concurrent包下的类，ArrayBlockingQueue、ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque\n\n\n### 迭代器 Iterator 是什么？\n* 定义了访问集合的方法，可以迭代HashSet、ArrayList等集合\n* 具有next、hasNext、remove等功能\n* 迭代器是一种设计模式\n* remove会抛异常\n\n\n### Iterator 和 ListIterator 有什么区别？\n* Iterator可以遍历set和list，ListIterator只能遍历list\n* ListIterator可以双向遍历list，Iterator只能单向\n* Iterator可以读、删，ListIterator可以读、删、增\n* Iterator无法获取集合中的索引，ListIterator可以获取集合中的索引\n\n### 怎么确保一个集合不能被修改？\n* 使用Collections类提供的方法即可\n  * Collections.unmodifiableList(List)\n  * Collections.unmodifiableSet(Set)\n","slug":"Q&A/Java/容器","published":1,"updated":"2022-04-12T09:00:46.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c1003owgttamxhac0w","content":"<h2 id=\"容器简介\"><a href=\"#容器简介\" class=\"headerlink\" title=\"容器简介\"></a>容器简介</h2><ul>\n<li>作用：持有和增删对象</li>\n<li>分类：<ul>\n<li>Collection：一个独立元素组成的队列，这些元素都遵守一个或多个相同的规则</li>\n<li>Map：一组由成对的“键值对”组成的对象</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Collection：一个接口，定义了对集合对象操作的通用方法\"><a href=\"#Collection：一个接口，定义了对集合对象操作的通用方法\" class=\"headerlink\" title=\"Collection：一个接口，定义了对集合对象操作的通用方法\"></a>Collection：一个接口，定义了对集合对象操作的通用方法</h2><h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><ul>\n<li>java.util.Collection是一个接口，定义了对集合对象操作的一些通用方法</li>\n<li>java本身没有直接提供Collection的实现类，而是提供了Collection的接口子类，比如List和Set</li>\n<li>关联类：Collections，一个都是静态方法的工具类，且该类不能被实例化（构造方法私有了）</li>\n</ul>\n<h3 id=\"组成类：\"><a href=\"#组成类：\" class=\"headerlink\" title=\"组成类：\"></a>组成类：</h3><ul>\n<li>List<ul>\n<li>LinkedList</li>\n<li>ArrayList</li>\n<li>Vector<ul>\n<li>Stack</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet</li>\n<li>TreeSet</li>\n<li>LinkedHashSet</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Collection主要方法：\"><a href=\"#Collection主要方法：\" class=\"headerlink\" title=\"Collection主要方法：\"></a>Collection主要方法：</h3><ul>\n<li>boolean addObject(Object o): 添加元素到集合</li>\n<li>boolean removeObject(Object o): 从集合中删除某个元素</li>\n<li>int size(): 集合中元素数量</li>\n<li>boolean contains(Object o): 查找集合中是否包含某个元素</li>\n<li>boolean isEmpty：判断集合中是否为空</li>\n<li>Iterator iterator(): 返回一个迭代器</li>\n<li>boolean containsAll(Collection c): 判断是否包含另一个集合中的全部元素</li>\n<li>boolean addAll(Collection c)：将另一个集合里面的所有元素添加到当前集合中</li>\n<li>void clear(): 删除集合中所有元素</li>\n<li>void removeAll(Collection c)：从当前集合中删除c中的所有元素</li>\n<li>void retainAll(Collection c)：从当前集合中删除c中没有的元素</li>\n</ul>\n<h3 id=\"List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\"><a href=\"#List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\" class=\"headerlink\" title=\"List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\"></a>List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组</h3><ul>\n<li>数组和list区别：<ul>\n<li>数组是静态的，即长度固定，且所有元素保存在一块连续的内存区域中，list的长度可变</li>\n<li>数组是多维，list的实现类ArrayList是一维</li>\n<li>数组是java中最基本的数据结构，没有类对应，list本身是一个接口类，list有实现类ArrayList等，即ArrayList功能比Array多</li>\n<li>list的实现类ArrayList即基于数组实现</li>\n</ul>\n</li>\n<li>实现类：ArrayList、LinkedList、Vector、Stack</li>\n<li>LinkedList（链表）：即java的链表，有单向和双向链表<ul>\n<li>特点：相比ArrayList，适合增删操作，不适合修改和查找</li>\n<li>使用场景：适合通过循环迭代使用某些元素，适合在表中任意位置增删元素</li>\n<li>注意：LinkedList没有同步方法，多线程访问时需要自己实现访问同步，使用Collections.synchronizedList可以创建一个同步list解决</li>\n</ul>\n</li>\n<li>ArrayList（可变数组）：即java的可变数组<ul>\n<li>特点：非同步，跟LinkedList一样</li>\n<li>使用场景：适合快速访问任一元素，适合在表尾执行增删操作</li>\n</ul>\n</li>\n<li>Vector：类似ArrayList，但是是同步的</li>\n<li>Stack：继承Vector，即先进后出的堆</li>\n</ul>\n<h3 id=\"Set：不包含重复元素的Collection，最多有一个null元素\"><a href=\"#Set：不包含重复元素的Collection，最多有一个null元素\" class=\"headerlink\" title=\"Set：不包含重复元素的Collection，最多有一个null元素\"></a>Set：不包含重复元素的Collection，最多有一个null元素</h3><ul>\n<li>实现类：HashSet、LinkedHashSet、TreeSet</li>\n<li>HashSet：基于HashMap实现，一个不包含重复元素的无序集合，非线程安全</li>\n<li>TreeSet：基于TreeMap实现，一个有序不包含重复元素的集合</li>\n<li>LinkedHashSet：继承于HashSet，一个按照插入顺序排序的有序且不包含重复元素的集合</li>\n</ul>\n<h2 id=\"Map：一组key-value集合\"><a href=\"#Map：一组key-value集合\" class=\"headerlink\" title=\"Map：一组key-value集合\"></a>Map：一组key-value集合</h2><h3 id=\"组成类\"><a href=\"#组成类\" class=\"headerlink\" title=\"组成类\"></a>组成类</h3><ul>\n<li>HashMap</li>\n<li>TreeMap</li>\n<li>HashTable</li>\n<li>WeakHashMap</li>\n<li>ConcurrentHashMap</li>\n<li>LinkedHashMap</li>\n</ul>\n<h3 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h3><ul>\n<li>boolean equals(Object o)：比较两个对象是否相等</li>\n<li>boolean remove(Object o)：删除对象</li>\n<li>put: 向map中添加key-value</li>\n<li>size：map中key-value个数</li>\n</ul>\n<h3 id=\"ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\"><a href=\"#ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\"></a>ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap</h3><h3 id=\"HashMap-非同步，无序，允许key、value为null的map\"><a href=\"#HashMap-非同步，无序，允许key、value为null的map\" class=\"headerlink\" title=\"HashMap: 非同步，无序，允许key、value为null的map\"></a>HashMap: 非同步，无序，允许key、value为null的map</h3><h3 id=\"WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\"><a href=\"#WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\" class=\"headerlink\" title=\"WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\"></a>WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收</h3><h3 id=\"TreeMap：依据比较规则对key进行排序的map\"><a href=\"#TreeMap：依据比较规则对key进行排序的map\" class=\"headerlink\" title=\"TreeMap：依据比较规则对key进行排序的map\"></a>TreeMap：依据比较规则对key进行排序的map</h3><h3 id=\"LinkedHashMap：一个有序的HashMap\"><a href=\"#LinkedHashMap：一个有序的HashMap\" class=\"headerlink\" title=\"LinkedHashMap：一个有序的HashMap\"></a>LinkedHashMap：一个有序的HashMap</h3><h2 id=\"相关面试题\"><a href=\"#相关面试题\" class=\"headerlink\" title=\"相关面试题\"></a>相关面试题</h2><h3 id=\"Collection-和-Collections-有什么区别\"><a href=\"#Collection-和-Collections-有什么区别\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别\"></a>Collection 和 Collections 有什么区别</h3><ul>\n<li>Collection是一个接口，给集合操作提供一些基础功能方法，Collections是一个均为静态方法的集合工具类，两者均不能实例化</li>\n</ul>\n<h3 id=\"List、Set、Map-之间的区别是什么？\"><a href=\"#List、Set、Map-之间的区别是什么？\" class=\"headerlink\" title=\"List、Set、Map 之间的区别是什么？\"></a>List、Set、Map 之间的区别是什么？</h3><ul>\n<li>List和Set是集合，是一堆元素按照一定规则或者无规则的容器，Map内部的元素形式是Key-value</li>\n<li>List内部元素是可以重复的，Set内部元素不能重复，Map内部Key不能重复，value可以重复</li>\n<li>List和Set都继承Collection，Map没有父接口类</li>\n</ul>\n<h3 id=\"HashMap-和-HashTable-有什么区别？\"><a href=\"#HashMap-和-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 和 HashTable 有什么区别？\"></a>HashMap 和 HashTable 有什么区别？</h3><ul>\n<li>HashTable官方已经淘汰，使用非常相似的ConcurrentHashMap替代</li>\n<li>HashTable是线程安全，支持同步访问，HashMap不支持同步访问，其他方面就比较像</li>\n</ul>\n<h3 id=\"如何决定使用-HashMap-还是-TreeMap？\"><a href=\"#如何决定使用-HashMap-还是-TreeMap？\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap？\"></a>如何决定使用 HashMap 还是 TreeMap？</h3><ul>\n<li>需要根据key进行排序的情况下使用TreeMap，其余情况下建议HashMap，HashMap性能较好</li>\n</ul>\n<h3 id=\"HashMap-的实现原理？\"><a href=\"#HashMap-的实现原理？\" class=\"headerlink\" title=\"HashMap 的实现原理？\"></a>HashMap 的实现原理？</h3><h4 id=\"JDK7和JDK8中HashMap实现的差别\"><a href=\"#JDK7和JDK8中HashMap实现的差别\" class=\"headerlink\" title=\"JDK7和JDK8中HashMap实现的差别\"></a>JDK7和JDK8中HashMap实现的差别</h4><ul>\n<li>1.7采用的是数组+链表，1.8采用的是数组+链表/红黑树</li>\n<li>1.7扩容时需要重新计算哈希值和索引位置，1.8不需要重新计算哈希值，巧妙的采用和扩容后容量进行&amp;操作来计算新的索引位置</li>\n<li>1.7是采用表头插入法插入链表，1.8采用是尾部插入法</li>\n<li>1.7中采用表头插入法，在扩容时会改变链表中元素顺序，以至于在并发场景下会导致链表成环问题，在1.8中采用的尾部插入法，在扩容时不会改变链表中元素顺序，所以就没有该问题</li>\n</ul>\n<h4 id=\"HashMap组成\"><a href=\"#HashMap组成\" class=\"headerlink\" title=\"HashMap组成?\"></a>HashMap组成?</h4><ul>\n<li>hashMap使用数组+链表的方式来存储数据，数组元素为Entry组成的链表，当链表长度大于8的时候，JDK1.8会将链表转成红黑树</li>\n</ul>\n<h4 id=\"Hash冲突如何解决\"><a href=\"#Hash冲突如何解决\" class=\"headerlink\" title=\"Hash冲突如何解决?\"></a>Hash冲突如何解决?</h4><ul>\n<li>当两个不同的key进行hash后取得的下标相同时，就会将这两个key-value放到对应的数组下标中的链表中</li>\n</ul>\n<h4 id=\"HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用\"><a href=\"#HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用\" class=\"headerlink\" title=\"HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用?\"></a>HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用?</h4><ul>\n<li>使用LinkedList替换数组实现HashMap是否可行，然后为什么不会用：当然可行</li>\n<li>数组的查找效率比LinkedList高，LinkedList是使用链表实现的</li>\n<li>ArrayList底层也是使用数组实现，但是由于扩容机制问题，不利于HashMap的取模运算，HashMap中的数组扩容时2倍扩容，ArrayList是1.5倍扩容</li>\n</ul>\n<h4 id=\"HashMap查找key的位置\"><a href=\"#HashMap查找key的位置\" class=\"headerlink\" title=\"HashMap查找key的位置\"></a>HashMap查找key的位置</h4><ul>\n<li>首先对key进行hashCode，同时使用HashMap对应的数组长度进行取余等操作找到对应的数组下标之后，再在这个下标对应的链表中查找</li>\n</ul>\n<h4 id=\"HashMap扩容\"><a href=\"#HashMap扩容\" class=\"headerlink\" title=\"HashMap扩容\"></a>HashMap扩容</h4><ul>\n<li>创建一个2倍容量的数组，将原数组的元素散列后放到新数组中</li>\n</ul>\n<h3 id=\"HashSet实现原理？\"><a href=\"#HashSet实现原理？\" class=\"headerlink\" title=\"HashSet实现原理？\"></a>HashSet实现原理？</h3><ul>\n<li>HashSet使用HashMap来实现，HashSet的元素都是保存在HashMap的key上，value是一个统一的static final对象</li>\n</ul>\n<h3 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h3><ul>\n<li>都是list接口的实现类</li>\n<li>ArrayList基于数组实现，LinkedList基于链表实现</li>\n<li>ArrayList相对更适合快速访问元素，LinkedList相对更适合快速插入删除元素</li>\n</ul>\n<h3 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h3><ul>\n<li>list转数组：<ul>\n<li>循环一个个放</li>\n<li>toArray方法</li>\n</ul>\n</li>\n<li>数组转list：<ul>\n<li>循环一个个放</li>\n<li>asList方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h3><ul>\n<li>Vector是同步版的ArrayList，是线程安全的</li>\n<li>Vector扩容时是当前的2倍，ArrayList扩容时是当前的1.5倍</li>\n</ul>\n<h3 id=\"Array-和-ArrayList-有何区别？\"><a href=\"#Array-和-ArrayList-有何区别？\" class=\"headerlink\" title=\"Array 和 ArrayList 有何区别？\"></a>Array 和 ArrayList 有何区别？</h3><ul>\n<li>ArrayList基于Array实现</li>\n<li>ArrayList是动态的，Array是静态</li>\n<li>ArrayList相当于是可变Array</li>\n<li>ArrayList不能存储基本数据类型，Array都可以</li>\n<li>Array中元素类型相同，ArrayList可以不同</li>\n</ul>\n<h3 id=\"在-Queue-中-poll-和-remove-有什么区别？\"><a href=\"#在-Queue-中-poll-和-remove-有什么区别？\" class=\"headerlink\" title=\"在 Queue 中 poll()和 remove()有什么区别？\"></a>在 Queue 中 poll()和 remove()有什么区别？</h3><ul>\n<li>相同：都是从删除头部元素并返回该元素</li>\n<li>不同：队列为空时，remove()会抛出NoSuchElementException异常，poll()会返回null</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><ul>\n<li>Vector</li>\n<li>Stack</li>\n<li>Hashtable</li>\n<li>java.util.concurrent包下的类，ArrayBlockingQueue、ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque</li>\n</ul>\n<h3 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h3><ul>\n<li>定义了访问集合的方法，可以迭代HashSet、ArrayList等集合</li>\n<li>具有next、hasNext、remove等功能</li>\n<li>迭代器是一种设计模式</li>\n<li>remove会抛异常</li>\n</ul>\n<h3 id=\"Iterator-和-ListIterator-有什么区别？\"><a href=\"#Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"Iterator 和 ListIterator 有什么区别？\"></a>Iterator 和 ListIterator 有什么区别？</h3><ul>\n<li>Iterator可以遍历set和list，ListIterator只能遍历list</li>\n<li>ListIterator可以双向遍历list，Iterator只能单向</li>\n<li>Iterator可以读、删，ListIterator可以读、删、增</li>\n<li>Iterator无法获取集合中的索引，ListIterator可以获取集合中的索引</li>\n</ul>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><ul>\n<li>使用Collections类提供的方法即可<ul>\n<li>Collections.unmodifiableList(List)</li>\n<li>Collections.unmodifiableSet(Set)</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"容器简介\"><a href=\"#容器简介\" class=\"headerlink\" title=\"容器简介\"></a>容器简介</h2><ul>\n<li>作用：持有和增删对象</li>\n<li>分类：<ul>\n<li>Collection：一个独立元素组成的队列，这些元素都遵守一个或多个相同的规则</li>\n<li>Map：一组由成对的“键值对”组成的对象</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Collection：一个接口，定义了对集合对象操作的通用方法\"><a href=\"#Collection：一个接口，定义了对集合对象操作的通用方法\" class=\"headerlink\" title=\"Collection：一个接口，定义了对集合对象操作的通用方法\"></a>Collection：一个接口，定义了对集合对象操作的通用方法</h2><h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><ul>\n<li>java.util.Collection是一个接口，定义了对集合对象操作的一些通用方法</li>\n<li>java本身没有直接提供Collection的实现类，而是提供了Collection的接口子类，比如List和Set</li>\n<li>关联类：Collections，一个都是静态方法的工具类，且该类不能被实例化（构造方法私有了）</li>\n</ul>\n<h3 id=\"组成类：\"><a href=\"#组成类：\" class=\"headerlink\" title=\"组成类：\"></a>组成类：</h3><ul>\n<li>List<ul>\n<li>LinkedList</li>\n<li>ArrayList</li>\n<li>Vector<ul>\n<li>Stack</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Set<ul>\n<li>HashSet</li>\n<li>TreeSet</li>\n<li>LinkedHashSet</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Collection主要方法：\"><a href=\"#Collection主要方法：\" class=\"headerlink\" title=\"Collection主要方法：\"></a>Collection主要方法：</h3><ul>\n<li>boolean addObject(Object o): 添加元素到集合</li>\n<li>boolean removeObject(Object o): 从集合中删除某个元素</li>\n<li>int size(): 集合中元素数量</li>\n<li>boolean contains(Object o): 查找集合中是否包含某个元素</li>\n<li>boolean isEmpty：判断集合中是否为空</li>\n<li>Iterator iterator(): 返回一个迭代器</li>\n<li>boolean containsAll(Collection c): 判断是否包含另一个集合中的全部元素</li>\n<li>boolean addAll(Collection c)：将另一个集合里面的所有元素添加到当前集合中</li>\n<li>void clear(): 删除集合中所有元素</li>\n<li>void removeAll(Collection c)：从当前集合中删除c中的所有元素</li>\n<li>void retainAll(Collection c)：从当前集合中删除c中没有的元素</li>\n</ul>\n<h3 id=\"List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\"><a href=\"#List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\" class=\"headerlink\" title=\"List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组\"></a>List：一个继承Collection的接口类，表示有序集合，可精确控制每个元素的插入位置，可使用索引访问元素，类似数组</h3><ul>\n<li>数组和list区别：<ul>\n<li>数组是静态的，即长度固定，且所有元素保存在一块连续的内存区域中，list的长度可变</li>\n<li>数组是多维，list的实现类ArrayList是一维</li>\n<li>数组是java中最基本的数据结构，没有类对应，list本身是一个接口类，list有实现类ArrayList等，即ArrayList功能比Array多</li>\n<li>list的实现类ArrayList即基于数组实现</li>\n</ul>\n</li>\n<li>实现类：ArrayList、LinkedList、Vector、Stack</li>\n<li>LinkedList（链表）：即java的链表，有单向和双向链表<ul>\n<li>特点：相比ArrayList，适合增删操作，不适合修改和查找</li>\n<li>使用场景：适合通过循环迭代使用某些元素，适合在表中任意位置增删元素</li>\n<li>注意：LinkedList没有同步方法，多线程访问时需要自己实现访问同步，使用Collections.synchronizedList可以创建一个同步list解决</li>\n</ul>\n</li>\n<li>ArrayList（可变数组）：即java的可变数组<ul>\n<li>特点：非同步，跟LinkedList一样</li>\n<li>使用场景：适合快速访问任一元素，适合在表尾执行增删操作</li>\n</ul>\n</li>\n<li>Vector：类似ArrayList，但是是同步的</li>\n<li>Stack：继承Vector，即先进后出的堆</li>\n</ul>\n<h3 id=\"Set：不包含重复元素的Collection，最多有一个null元素\"><a href=\"#Set：不包含重复元素的Collection，最多有一个null元素\" class=\"headerlink\" title=\"Set：不包含重复元素的Collection，最多有一个null元素\"></a>Set：不包含重复元素的Collection，最多有一个null元素</h3><ul>\n<li>实现类：HashSet、LinkedHashSet、TreeSet</li>\n<li>HashSet：基于HashMap实现，一个不包含重复元素的无序集合，非线程安全</li>\n<li>TreeSet：基于TreeMap实现，一个有序不包含重复元素的集合</li>\n<li>LinkedHashSet：继承于HashSet，一个按照插入顺序排序的有序且不包含重复元素的集合</li>\n</ul>\n<h2 id=\"Map：一组key-value集合\"><a href=\"#Map：一组key-value集合\" class=\"headerlink\" title=\"Map：一组key-value集合\"></a>Map：一组key-value集合</h2><h3 id=\"组成类\"><a href=\"#组成类\" class=\"headerlink\" title=\"组成类\"></a>组成类</h3><ul>\n<li>HashMap</li>\n<li>TreeMap</li>\n<li>HashTable</li>\n<li>WeakHashMap</li>\n<li>ConcurrentHashMap</li>\n<li>LinkedHashMap</li>\n</ul>\n<h3 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h3><ul>\n<li>boolean equals(Object o)：比较两个对象是否相等</li>\n<li>boolean remove(Object o)：删除对象</li>\n<li>put: 向map中添加key-value</li>\n<li>size：map中key-value个数</li>\n</ul>\n<h3 id=\"ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\"><a href=\"#ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap\"></a>ConcurrentHashMap、HashTable：与HashMap类似，可同步访问，key、value均不能为null，官方已淘汰HashTable，使用ConcurrentHashMap</h3><h3 id=\"HashMap-非同步，无序，允许key、value为null的map\"><a href=\"#HashMap-非同步，无序，允许key、value为null的map\" class=\"headerlink\" title=\"HashMap: 非同步，无序，允许key、value为null的map\"></a>HashMap: 非同步，无序，允许key、value为null的map</h3><h3 id=\"WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\"><a href=\"#WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\" class=\"headerlink\" title=\"WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收\"></a>WeakHashMap：类似HashMap，对key是弱引用，当key未被引用时，GC可回收</h3><h3 id=\"TreeMap：依据比较规则对key进行排序的map\"><a href=\"#TreeMap：依据比较规则对key进行排序的map\" class=\"headerlink\" title=\"TreeMap：依据比较规则对key进行排序的map\"></a>TreeMap：依据比较规则对key进行排序的map</h3><h3 id=\"LinkedHashMap：一个有序的HashMap\"><a href=\"#LinkedHashMap：一个有序的HashMap\" class=\"headerlink\" title=\"LinkedHashMap：一个有序的HashMap\"></a>LinkedHashMap：一个有序的HashMap</h3><h2 id=\"相关面试题\"><a href=\"#相关面试题\" class=\"headerlink\" title=\"相关面试题\"></a>相关面试题</h2><h3 id=\"Collection-和-Collections-有什么区别\"><a href=\"#Collection-和-Collections-有什么区别\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别\"></a>Collection 和 Collections 有什么区别</h3><ul>\n<li>Collection是一个接口，给集合操作提供一些基础功能方法，Collections是一个均为静态方法的集合工具类，两者均不能实例化</li>\n</ul>\n<h3 id=\"List、Set、Map-之间的区别是什么？\"><a href=\"#List、Set、Map-之间的区别是什么？\" class=\"headerlink\" title=\"List、Set、Map 之间的区别是什么？\"></a>List、Set、Map 之间的区别是什么？</h3><ul>\n<li>List和Set是集合，是一堆元素按照一定规则或者无规则的容器，Map内部的元素形式是Key-value</li>\n<li>List内部元素是可以重复的，Set内部元素不能重复，Map内部Key不能重复，value可以重复</li>\n<li>List和Set都继承Collection，Map没有父接口类</li>\n</ul>\n<h3 id=\"HashMap-和-HashTable-有什么区别？\"><a href=\"#HashMap-和-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 和 HashTable 有什么区别？\"></a>HashMap 和 HashTable 有什么区别？</h3><ul>\n<li>HashTable官方已经淘汰，使用非常相似的ConcurrentHashMap替代</li>\n<li>HashTable是线程安全，支持同步访问，HashMap不支持同步访问，其他方面就比较像</li>\n</ul>\n<h3 id=\"如何决定使用-HashMap-还是-TreeMap？\"><a href=\"#如何决定使用-HashMap-还是-TreeMap？\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap？\"></a>如何决定使用 HashMap 还是 TreeMap？</h3><ul>\n<li>需要根据key进行排序的情况下使用TreeMap，其余情况下建议HashMap，HashMap性能较好</li>\n</ul>\n<h3 id=\"HashMap-的实现原理？\"><a href=\"#HashMap-的实现原理？\" class=\"headerlink\" title=\"HashMap 的实现原理？\"></a>HashMap 的实现原理？</h3><h4 id=\"JDK7和JDK8中HashMap实现的差别\"><a href=\"#JDK7和JDK8中HashMap实现的差别\" class=\"headerlink\" title=\"JDK7和JDK8中HashMap实现的差别\"></a>JDK7和JDK8中HashMap实现的差别</h4><ul>\n<li>1.7采用的是数组+链表，1.8采用的是数组+链表/红黑树</li>\n<li>1.7扩容时需要重新计算哈希值和索引位置，1.8不需要重新计算哈希值，巧妙的采用和扩容后容量进行&amp;操作来计算新的索引位置</li>\n<li>1.7是采用表头插入法插入链表，1.8采用是尾部插入法</li>\n<li>1.7中采用表头插入法，在扩容时会改变链表中元素顺序，以至于在并发场景下会导致链表成环问题，在1.8中采用的尾部插入法，在扩容时不会改变链表中元素顺序，所以就没有该问题</li>\n</ul>\n<h4 id=\"HashMap组成\"><a href=\"#HashMap组成\" class=\"headerlink\" title=\"HashMap组成?\"></a>HashMap组成?</h4><ul>\n<li>hashMap使用数组+链表的方式来存储数据，数组元素为Entry组成的链表，当链表长度大于8的时候，JDK1.8会将链表转成红黑树</li>\n</ul>\n<h4 id=\"Hash冲突如何解决\"><a href=\"#Hash冲突如何解决\" class=\"headerlink\" title=\"Hash冲突如何解决?\"></a>Hash冲突如何解决?</h4><ul>\n<li>当两个不同的key进行hash后取得的下标相同时，就会将这两个key-value放到对应的数组下标中的链表中</li>\n</ul>\n<h4 id=\"HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用\"><a href=\"#HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用\" class=\"headerlink\" title=\"HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用?\"></a>HashMap是否可以使用LinkedList代替数组进行实现，如果是的话为什么不用?</h4><ul>\n<li>使用LinkedList替换数组实现HashMap是否可行，然后为什么不会用：当然可行</li>\n<li>数组的查找效率比LinkedList高，LinkedList是使用链表实现的</li>\n<li>ArrayList底层也是使用数组实现，但是由于扩容机制问题，不利于HashMap的取模运算，HashMap中的数组扩容时2倍扩容，ArrayList是1.5倍扩容</li>\n</ul>\n<h4 id=\"HashMap查找key的位置\"><a href=\"#HashMap查找key的位置\" class=\"headerlink\" title=\"HashMap查找key的位置\"></a>HashMap查找key的位置</h4><ul>\n<li>首先对key进行hashCode，同时使用HashMap对应的数组长度进行取余等操作找到对应的数组下标之后，再在这个下标对应的链表中查找</li>\n</ul>\n<h4 id=\"HashMap扩容\"><a href=\"#HashMap扩容\" class=\"headerlink\" title=\"HashMap扩容\"></a>HashMap扩容</h4><ul>\n<li>创建一个2倍容量的数组，将原数组的元素散列后放到新数组中</li>\n</ul>\n<h3 id=\"HashSet实现原理？\"><a href=\"#HashSet实现原理？\" class=\"headerlink\" title=\"HashSet实现原理？\"></a>HashSet实现原理？</h3><ul>\n<li>HashSet使用HashMap来实现，HashSet的元素都是保存在HashMap的key上，value是一个统一的static final对象</li>\n</ul>\n<h3 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h3><ul>\n<li>都是list接口的实现类</li>\n<li>ArrayList基于数组实现，LinkedList基于链表实现</li>\n<li>ArrayList相对更适合快速访问元素，LinkedList相对更适合快速插入删除元素</li>\n</ul>\n<h3 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h3><ul>\n<li>list转数组：<ul>\n<li>循环一个个放</li>\n<li>toArray方法</li>\n</ul>\n</li>\n<li>数组转list：<ul>\n<li>循环一个个放</li>\n<li>asList方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h3><ul>\n<li>Vector是同步版的ArrayList，是线程安全的</li>\n<li>Vector扩容时是当前的2倍，ArrayList扩容时是当前的1.5倍</li>\n</ul>\n<h3 id=\"Array-和-ArrayList-有何区别？\"><a href=\"#Array-和-ArrayList-有何区别？\" class=\"headerlink\" title=\"Array 和 ArrayList 有何区别？\"></a>Array 和 ArrayList 有何区别？</h3><ul>\n<li>ArrayList基于Array实现</li>\n<li>ArrayList是动态的，Array是静态</li>\n<li>ArrayList相当于是可变Array</li>\n<li>ArrayList不能存储基本数据类型，Array都可以</li>\n<li>Array中元素类型相同，ArrayList可以不同</li>\n</ul>\n<h3 id=\"在-Queue-中-poll-和-remove-有什么区别？\"><a href=\"#在-Queue-中-poll-和-remove-有什么区别？\" class=\"headerlink\" title=\"在 Queue 中 poll()和 remove()有什么区别？\"></a>在 Queue 中 poll()和 remove()有什么区别？</h3><ul>\n<li>相同：都是从删除头部元素并返回该元素</li>\n<li>不同：队列为空时，remove()会抛出NoSuchElementException异常，poll()会返回null</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><ul>\n<li>Vector</li>\n<li>Stack</li>\n<li>Hashtable</li>\n<li>java.util.concurrent包下的类，ArrayBlockingQueue、ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque</li>\n</ul>\n<h3 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h3><ul>\n<li>定义了访问集合的方法，可以迭代HashSet、ArrayList等集合</li>\n<li>具有next、hasNext、remove等功能</li>\n<li>迭代器是一种设计模式</li>\n<li>remove会抛异常</li>\n</ul>\n<h3 id=\"Iterator-和-ListIterator-有什么区别？\"><a href=\"#Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"Iterator 和 ListIterator 有什么区别？\"></a>Iterator 和 ListIterator 有什么区别？</h3><ul>\n<li>Iterator可以遍历set和list，ListIterator只能遍历list</li>\n<li>ListIterator可以双向遍历list，Iterator只能单向</li>\n<li>Iterator可以读、删，ListIterator可以读、删、增</li>\n<li>Iterator无法获取集合中的索引，ListIterator可以获取集合中的索引</li>\n</ul>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><ul>\n<li>使用Collections类提供的方法即可<ul>\n<li>Collections.unmodifiableList(List)</li>\n<li>Collections.unmodifiableSet(Set)</li>\n</ul>\n</li>\n</ul>\n"},{"title":"对象拷贝","date":"2022-03-25T08:28:18.000Z","_content":"\n### 为什么要使用克隆？\n* 想对一个对象进行处理，但是又想保留原有数据进行其他操作，此时需要对原有数据进行克隆\n\n### 如何实现对象克隆？\n* 克隆：\n  * 浅克隆：只克隆对象里面的基本数据类型\n  * 深克隆：克隆对象里面的所有属性\n* 实现：浅克隆只需要本类实现Cloneable接口（该接口有个clone方法，需要调用super.clone实现）即可，深克隆需要对象所属的类以及对象引用的所有对象对应的类都实现Cloneable接口\n* 深拷贝代码示例：\n```\nclass Address  {\n    private String add;\n    public String getAdd() {\n        return add;\n    }\n\n    public void setAdd(String add) {\n        this.add = add;\n    }\n\n}\n\nclass Student implements Cloneable {\n    private int number;\n\n    private Address addr;\n\n    public Address getAddr() {\n        return addr;\n    }\n\n    public void setAddr(Address addr) {\n        this.addr = addr;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public Object clone() {\n        Student stu = null;\n        try{\n            stu = (Student)super.clone();\n        }catch(CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        return stu;\n    }\n}\n\n@Test\npublic void testCopy() {\n    Address addr = new Address();\n    addr.setAdd(\"杭州市\");\n    Student stu1 = new Student();\n    stu1.setNumber(123);\n    stu1.setAddr(addr);\n\n    Student stu2 = (Student)stu1.clone();\n\n    System.out.println(\"学生1:\" + stu1.getNumber() + \",地址:\" + stu1.getAddr().getAdd());\n    System.out.println(\"学生2:\" + stu2.getNumber() + \",地址:\" + stu2.getAddr().getAdd());\n}\n```\n\n### 深拷贝和浅拷贝区别是什么？\n* 浅拷贝只支持基本数据类型的拷贝，深拷贝全都支持，所以浅拷贝之后的引用类型还是同一个地址\n\n### 如何解决多层克隆问题？\n* 先序列化，在反序列化\n","source":"_posts/Q&A/Java/对象拷贝.md","raw":"---\ntitle: 对象拷贝\ndate: 2022-03-25 16:28:18\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n### 为什么要使用克隆？\n* 想对一个对象进行处理，但是又想保留原有数据进行其他操作，此时需要对原有数据进行克隆\n\n### 如何实现对象克隆？\n* 克隆：\n  * 浅克隆：只克隆对象里面的基本数据类型\n  * 深克隆：克隆对象里面的所有属性\n* 实现：浅克隆只需要本类实现Cloneable接口（该接口有个clone方法，需要调用super.clone实现）即可，深克隆需要对象所属的类以及对象引用的所有对象对应的类都实现Cloneable接口\n* 深拷贝代码示例：\n```\nclass Address  {\n    private String add;\n    public String getAdd() {\n        return add;\n    }\n\n    public void setAdd(String add) {\n        this.add = add;\n    }\n\n}\n\nclass Student implements Cloneable {\n    private int number;\n\n    private Address addr;\n\n    public Address getAddr() {\n        return addr;\n    }\n\n    public void setAddr(Address addr) {\n        this.addr = addr;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public Object clone() {\n        Student stu = null;\n        try{\n            stu = (Student)super.clone();\n        }catch(CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        return stu;\n    }\n}\n\n@Test\npublic void testCopy() {\n    Address addr = new Address();\n    addr.setAdd(\"杭州市\");\n    Student stu1 = new Student();\n    stu1.setNumber(123);\n    stu1.setAddr(addr);\n\n    Student stu2 = (Student)stu1.clone();\n\n    System.out.println(\"学生1:\" + stu1.getNumber() + \",地址:\" + stu1.getAddr().getAdd());\n    System.out.println(\"学生2:\" + stu2.getNumber() + \",地址:\" + stu2.getAddr().getAdd());\n}\n```\n\n### 深拷贝和浅拷贝区别是什么？\n* 浅拷贝只支持基本数据类型的拷贝，深拷贝全都支持，所以浅拷贝之后的引用类型还是同一个地址\n\n### 如何解决多层克隆问题？\n* 先序列化，在反序列化\n","slug":"Q&A/Java/对象拷贝","published":1,"updated":"2022-04-12T09:00:46.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c2003qwgtter1s49qn","content":"<h3 id=\"为什么要使用克隆？\"><a href=\"#为什么要使用克隆？\" class=\"headerlink\" title=\"为什么要使用克隆？\"></a>为什么要使用克隆？</h3><ul>\n<li>想对一个对象进行处理，但是又想保留原有数据进行其他操作，此时需要对原有数据进行克隆</li>\n</ul>\n<h3 id=\"如何实现对象克隆？\"><a href=\"#如何实现对象克隆？\" class=\"headerlink\" title=\"如何实现对象克隆？\"></a>如何实现对象克隆？</h3><ul>\n<li>克隆：<ul>\n<li>浅克隆：只克隆对象里面的基本数据类型</li>\n<li>深克隆：克隆对象里面的所有属性</li>\n</ul>\n</li>\n<li>实现：浅克隆只需要本类实现Cloneable接口（该接口有个clone方法，需要调用super.clone实现）即可，深克隆需要对象所属的类以及对象引用的所有对象对应的类都实现Cloneable接口</li>\n<li>深拷贝代码示例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Address  &#123;</span><br><span class=\"line\">    private String add;</span><br><span class=\"line\">    public String getAdd() &#123;</span><br><span class=\"line\">        return add;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAdd(String add) &#123;</span><br><span class=\"line\">        this.add = add;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Student implements Cloneable &#123;</span><br><span class=\"line\">    private int number;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Address addr;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Address getAddr() &#123;</span><br><span class=\"line\">        return addr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddr(Address addr) &#123;</span><br><span class=\"line\">        this.addr = addr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getNumber() &#123;</span><br><span class=\"line\">        return number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setNumber(int number) &#123;</span><br><span class=\"line\">        this.number = number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object clone() &#123;</span><br><span class=\"line\">        Student stu = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            stu = (Student)super.clone();</span><br><span class=\"line\">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return stu;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void testCopy() &#123;</span><br><span class=\"line\">    Address addr = new Address();</span><br><span class=\"line\">    addr.setAdd(&quot;杭州市&quot;);</span><br><span class=\"line\">    Student stu1 = new Student();</span><br><span class=\"line\">    stu1.setNumber(123);</span><br><span class=\"line\">    stu1.setAddr(addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    Student stu2 = (Student)stu1.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());</span><br><span class=\"line\">    System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"深拷贝和浅拷贝区别是什么？\"><a href=\"#深拷贝和浅拷贝区别是什么？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别是什么？\"></a>深拷贝和浅拷贝区别是什么？</h3><ul>\n<li>浅拷贝只支持基本数据类型的拷贝，深拷贝全都支持，所以浅拷贝之后的引用类型还是同一个地址</li>\n</ul>\n<h3 id=\"如何解决多层克隆问题？\"><a href=\"#如何解决多层克隆问题？\" class=\"headerlink\" title=\"如何解决多层克隆问题？\"></a>如何解决多层克隆问题？</h3><ul>\n<li>先序列化，在反序列化</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要使用克隆？\"><a href=\"#为什么要使用克隆？\" class=\"headerlink\" title=\"为什么要使用克隆？\"></a>为什么要使用克隆？</h3><ul>\n<li>想对一个对象进行处理，但是又想保留原有数据进行其他操作，此时需要对原有数据进行克隆</li>\n</ul>\n<h3 id=\"如何实现对象克隆？\"><a href=\"#如何实现对象克隆？\" class=\"headerlink\" title=\"如何实现对象克隆？\"></a>如何实现对象克隆？</h3><ul>\n<li>克隆：<ul>\n<li>浅克隆：只克隆对象里面的基本数据类型</li>\n<li>深克隆：克隆对象里面的所有属性</li>\n</ul>\n</li>\n<li>实现：浅克隆只需要本类实现Cloneable接口（该接口有个clone方法，需要调用super.clone实现）即可，深克隆需要对象所属的类以及对象引用的所有对象对应的类都实现Cloneable接口</li>\n<li>深拷贝代码示例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Address  &#123;</span><br><span class=\"line\">    private String add;</span><br><span class=\"line\">    public String getAdd() &#123;</span><br><span class=\"line\">        return add;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAdd(String add) &#123;</span><br><span class=\"line\">        this.add = add;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Student implements Cloneable &#123;</span><br><span class=\"line\">    private int number;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Address addr;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Address getAddr() &#123;</span><br><span class=\"line\">        return addr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddr(Address addr) &#123;</span><br><span class=\"line\">        this.addr = addr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getNumber() &#123;</span><br><span class=\"line\">        return number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setNumber(int number) &#123;</span><br><span class=\"line\">        this.number = number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object clone() &#123;</span><br><span class=\"line\">        Student stu = null;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            stu = (Student)super.clone();</span><br><span class=\"line\">        &#125;catch(CloneNotSupportedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return stu;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">public void testCopy() &#123;</span><br><span class=\"line\">    Address addr = new Address();</span><br><span class=\"line\">    addr.setAdd(&quot;杭州市&quot;);</span><br><span class=\"line\">    Student stu1 = new Student();</span><br><span class=\"line\">    stu1.setNumber(123);</span><br><span class=\"line\">    stu1.setAddr(addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    Student stu2 = (Student)stu1.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;学生1:&quot; + stu1.getNumber() + &quot;,地址:&quot; + stu1.getAddr().getAdd());</span><br><span class=\"line\">    System.out.println(&quot;学生2:&quot; + stu2.getNumber() + &quot;,地址:&quot; + stu2.getAddr().getAdd());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"深拷贝和浅拷贝区别是什么？\"><a href=\"#深拷贝和浅拷贝区别是什么？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别是什么？\"></a>深拷贝和浅拷贝区别是什么？</h3><ul>\n<li>浅拷贝只支持基本数据类型的拷贝，深拷贝全都支持，所以浅拷贝之后的引用类型还是同一个地址</li>\n</ul>\n<h3 id=\"如何解决多层克隆问题？\"><a href=\"#如何解决多层克隆问题？\" class=\"headerlink\" title=\"如何解决多层克隆问题？\"></a>如何解决多层克隆问题？</h3><ul>\n<li>先序列化，在反序列化</li>\n</ul>\n"},{"title":"异常","date":"2022-04-06T14:39:41.000Z","_content":"\n### 系统抛异常的方式\n* throw\n* throws\n* 系统自动抛异常\n\n### throw 与 throws 的区别\n||throw|throws|\n|---|---|---|\n|作用|表示当前代码块抛出的一个异常|表示当前方法可能抛出的一个或多个异常，声明要抛出的异常类型｜\n|使用位置|方法中|方法名中|\n|处理位置|方法中、调用该方法的方法中|调用该方法的方法中|\n|特点|执行到这一行，就是一定有异常，表示一定|不一定真的产生这些异常，表达可能行|\n\n### final、finally、finalize 有什么区别？\n\n||final|finally|finalize|\n|---|---|---|----|\n|作用|使修饰内容不发生变化，使被修饰的内容只读|配合try、catch完成异常处理的一部分流程，表示该部分最后且一定会执行，即使catch中return了，经常用来释放资源|是object的方法之一，作用是协助gcc释放资源|\n|修饰内容|修饰变量、方法、类|无|无|\n|修饰内容特点|被修饰内容不可变，类不能被继承、方法不能被重写，变量内容不能变（变量值不变或者引用不变）|无|无|\n\n\n### try-catch-finally 中哪个部分可以省略？\n* catch和finally都可以省略，但是不能同时省略\n\n### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n* return之前会先执行finally，具体执行情况如下\n    * finally中有return：此处会覆盖try与catch中的返回值\n    *finally中没有return：\n        * 返回值是基本数据类型：由于返回值已经存储在栈中了，所以finally中的改变是无效的\n        * 返回值是引用类型：finally中对引用的操作会生效\n* 不会执行的情况： \n    * 没有进入try\n    * 强制退出程序\n    * 守护线程被终止\n\n### 常见的异常类有哪些？\n|异常名称|用途|\n|---|---|\n|NullPointerException|空指针|\n|SQLException|数据库访问异常|\n|IndexOutOfBoundsException|数组越界|\n|NumberFormatException|字符串转数值类型异常|\n|FileNotFoundException|打开文件失败|\n|IOException|I/O异常|\n|ClassCastException|强制类型转换异常|\n|ArrayStoreException|向数组中存入错误类型对象时的异常|\n|IllegalArgumentException|无效参数|\n|ArithmeticException|运算异常|\n|NegativeArraySizeException|创建长度为负的数组异常|\n|NoSuchMethodException|找不到方法|\n|SecurityException|存在安全侵犯|\n|UnsupportedOperationException|不支持的操作|\n|RuntimeException|运行时异常父类|\n","source":"_posts/Q&A/Java/异常.md","raw":"---\ntitle: 异常\ndate: 2022-04-06 22:39:41\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n### 系统抛异常的方式\n* throw\n* throws\n* 系统自动抛异常\n\n### throw 与 throws 的区别\n||throw|throws|\n|---|---|---|\n|作用|表示当前代码块抛出的一个异常|表示当前方法可能抛出的一个或多个异常，声明要抛出的异常类型｜\n|使用位置|方法中|方法名中|\n|处理位置|方法中、调用该方法的方法中|调用该方法的方法中|\n|特点|执行到这一行，就是一定有异常，表示一定|不一定真的产生这些异常，表达可能行|\n\n### final、finally、finalize 有什么区别？\n\n||final|finally|finalize|\n|---|---|---|----|\n|作用|使修饰内容不发生变化，使被修饰的内容只读|配合try、catch完成异常处理的一部分流程，表示该部分最后且一定会执行，即使catch中return了，经常用来释放资源|是object的方法之一，作用是协助gcc释放资源|\n|修饰内容|修饰变量、方法、类|无|无|\n|修饰内容特点|被修饰内容不可变，类不能被继承、方法不能被重写，变量内容不能变（变量值不变或者引用不变）|无|无|\n\n\n### try-catch-finally 中哪个部分可以省略？\n* catch和finally都可以省略，但是不能同时省略\n\n### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n* return之前会先执行finally，具体执行情况如下\n    * finally中有return：此处会覆盖try与catch中的返回值\n    *finally中没有return：\n        * 返回值是基本数据类型：由于返回值已经存储在栈中了，所以finally中的改变是无效的\n        * 返回值是引用类型：finally中对引用的操作会生效\n* 不会执行的情况： \n    * 没有进入try\n    * 强制退出程序\n    * 守护线程被终止\n\n### 常见的异常类有哪些？\n|异常名称|用途|\n|---|---|\n|NullPointerException|空指针|\n|SQLException|数据库访问异常|\n|IndexOutOfBoundsException|数组越界|\n|NumberFormatException|字符串转数值类型异常|\n|FileNotFoundException|打开文件失败|\n|IOException|I/O异常|\n|ClassCastException|强制类型转换异常|\n|ArrayStoreException|向数组中存入错误类型对象时的异常|\n|IllegalArgumentException|无效参数|\n|ArithmeticException|运算异常|\n|NegativeArraySizeException|创建长度为负的数组异常|\n|NoSuchMethodException|找不到方法|\n|SecurityException|存在安全侵犯|\n|UnsupportedOperationException|不支持的操作|\n|RuntimeException|运行时异常父类|\n","slug":"Q&A/Java/异常","published":1,"updated":"2022-04-12T09:00:46.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c3003vwgttb4ij8w3d","content":"<h3 id=\"系统抛异常的方式\"><a href=\"#系统抛异常的方式\" class=\"headerlink\" title=\"系统抛异常的方式\"></a>系统抛异常的方式</h3><ul>\n<li>throw</li>\n<li>throws</li>\n<li>系统自动抛异常</li>\n</ul>\n<h3 id=\"throw-与-throws-的区别\"><a href=\"#throw-与-throws-的区别\" class=\"headerlink\" title=\"throw 与 throws 的区别\"></a>throw 与 throws 的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>throw</th>\n<th>throws</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>作用</td>\n<td>表示当前代码块抛出的一个异常</td>\n<td>表示当前方法可能抛出的一个或多个异常，声明要抛出的异常类型｜</td>\n</tr>\n<tr>\n<td>使用位置</td>\n<td>方法中</td>\n<td>方法名中</td>\n</tr>\n<tr>\n<td>处理位置</td>\n<td>方法中、调用该方法的方法中</td>\n<td>调用该方法的方法中</td>\n</tr>\n<tr>\n<td>特点</td>\n<td>执行到这一行，就是一定有异常，表示一定</td>\n<td>不一定真的产生这些异常，表达可能行</td>\n</tr>\n</tbody></table>\n<h3 id=\"final、finally、finalize-有什么区别？\"><a href=\"#final、finally、finalize-有什么区别？\" class=\"headerlink\" title=\"final、finally、finalize 有什么区别？\"></a>final、finally、finalize 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>final</th>\n<th>finally</th>\n<th>finalize</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>作用</td>\n<td>使修饰内容不发生变化，使被修饰的内容只读</td>\n<td>配合try、catch完成异常处理的一部分流程，表示该部分最后且一定会执行，即使catch中return了，经常用来释放资源</td>\n<td>是object的方法之一，作用是协助gcc释放资源</td>\n</tr>\n<tr>\n<td>修饰内容</td>\n<td>修饰变量、方法、类</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td>修饰内容特点</td>\n<td>被修饰内容不可变，类不能被继承、方法不能被重写，变量内容不能变（变量值不变或者引用不变）</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<h3 id=\"try-catch-finally-中哪个部分可以省略？\"><a href=\"#try-catch-finally-中哪个部分可以省略？\" class=\"headerlink\" title=\"try-catch-finally 中哪个部分可以省略？\"></a>try-catch-finally 中哪个部分可以省略？</h3><ul>\n<li>catch和finally都可以省略，但是不能同时省略</li>\n</ul>\n<h3 id=\"try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><ul>\n<li>return之前会先执行finally，具体执行情况如下<ul>\n<li>finally中有return：此处会覆盖try与catch中的返回值</li>\n<li>finally中没有return：<ul>\n<li>返回值是基本数据类型：由于返回值已经存储在栈中了，所以finally中的改变是无效的</li>\n<li>返回值是引用类型：finally中对引用的操作会生效</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>不会执行的情况： <ul>\n<li>没有进入try</li>\n<li>强制退出程序</li>\n<li>守护线程被终止</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见的异常类有哪些？\"><a href=\"#常见的异常类有哪些？\" class=\"headerlink\" title=\"常见的异常类有哪些？\"></a>常见的异常类有哪些？</h3><table>\n<thead>\n<tr>\n<th>异常名称</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NullPointerException</td>\n<td>空指针</td>\n</tr>\n<tr>\n<td>SQLException</td>\n<td>数据库访问异常</td>\n</tr>\n<tr>\n<td>IndexOutOfBoundsException</td>\n<td>数组越界</td>\n</tr>\n<tr>\n<td>NumberFormatException</td>\n<td>字符串转数值类型异常</td>\n</tr>\n<tr>\n<td>FileNotFoundException</td>\n<td>打开文件失败</td>\n</tr>\n<tr>\n<td>IOException</td>\n<td>I/O异常</td>\n</tr>\n<tr>\n<td>ClassCastException</td>\n<td>强制类型转换异常</td>\n</tr>\n<tr>\n<td>ArrayStoreException</td>\n<td>向数组中存入错误类型对象时的异常</td>\n</tr>\n<tr>\n<td>IllegalArgumentException</td>\n<td>无效参数</td>\n</tr>\n<tr>\n<td>ArithmeticException</td>\n<td>运算异常</td>\n</tr>\n<tr>\n<td>NegativeArraySizeException</td>\n<td>创建长度为负的数组异常</td>\n</tr>\n<tr>\n<td>NoSuchMethodException</td>\n<td>找不到方法</td>\n</tr>\n<tr>\n<td>SecurityException</td>\n<td>存在安全侵犯</td>\n</tr>\n<tr>\n<td>UnsupportedOperationException</td>\n<td>不支持的操作</td>\n</tr>\n<tr>\n<td>RuntimeException</td>\n<td>运行时异常父类</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"系统抛异常的方式\"><a href=\"#系统抛异常的方式\" class=\"headerlink\" title=\"系统抛异常的方式\"></a>系统抛异常的方式</h3><ul>\n<li>throw</li>\n<li>throws</li>\n<li>系统自动抛异常</li>\n</ul>\n<h3 id=\"throw-与-throws-的区别\"><a href=\"#throw-与-throws-的区别\" class=\"headerlink\" title=\"throw 与 throws 的区别\"></a>throw 与 throws 的区别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>throw</th>\n<th>throws</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>作用</td>\n<td>表示当前代码块抛出的一个异常</td>\n<td>表示当前方法可能抛出的一个或多个异常，声明要抛出的异常类型｜</td>\n</tr>\n<tr>\n<td>使用位置</td>\n<td>方法中</td>\n<td>方法名中</td>\n</tr>\n<tr>\n<td>处理位置</td>\n<td>方法中、调用该方法的方法中</td>\n<td>调用该方法的方法中</td>\n</tr>\n<tr>\n<td>特点</td>\n<td>执行到这一行，就是一定有异常，表示一定</td>\n<td>不一定真的产生这些异常，表达可能行</td>\n</tr>\n</tbody></table>\n<h3 id=\"final、finally、finalize-有什么区别？\"><a href=\"#final、finally、finalize-有什么区别？\" class=\"headerlink\" title=\"final、finally、finalize 有什么区别？\"></a>final、finally、finalize 有什么区别？</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>final</th>\n<th>finally</th>\n<th>finalize</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>作用</td>\n<td>使修饰内容不发生变化，使被修饰的内容只读</td>\n<td>配合try、catch完成异常处理的一部分流程，表示该部分最后且一定会执行，即使catch中return了，经常用来释放资源</td>\n<td>是object的方法之一，作用是协助gcc释放资源</td>\n</tr>\n<tr>\n<td>修饰内容</td>\n<td>修饰变量、方法、类</td>\n<td>无</td>\n<td>无</td>\n</tr>\n<tr>\n<td>修饰内容特点</td>\n<td>被修饰内容不可变，类不能被继承、方法不能被重写，变量内容不能变（变量值不变或者引用不变）</td>\n<td>无</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<h3 id=\"try-catch-finally-中哪个部分可以省略？\"><a href=\"#try-catch-finally-中哪个部分可以省略？\" class=\"headerlink\" title=\"try-catch-finally 中哪个部分可以省略？\"></a>try-catch-finally 中哪个部分可以省略？</h3><ul>\n<li>catch和finally都可以省略，但是不能同时省略</li>\n</ul>\n<h3 id=\"try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><ul>\n<li>return之前会先执行finally，具体执行情况如下<ul>\n<li>finally中有return：此处会覆盖try与catch中的返回值</li>\n<li>finally中没有return：<ul>\n<li>返回值是基本数据类型：由于返回值已经存储在栈中了，所以finally中的改变是无效的</li>\n<li>返回值是引用类型：finally中对引用的操作会生效</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>不会执行的情况： <ul>\n<li>没有进入try</li>\n<li>强制退出程序</li>\n<li>守护线程被终止</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见的异常类有哪些？\"><a href=\"#常见的异常类有哪些？\" class=\"headerlink\" title=\"常见的异常类有哪些？\"></a>常见的异常类有哪些？</h3><table>\n<thead>\n<tr>\n<th>异常名称</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NullPointerException</td>\n<td>空指针</td>\n</tr>\n<tr>\n<td>SQLException</td>\n<td>数据库访问异常</td>\n</tr>\n<tr>\n<td>IndexOutOfBoundsException</td>\n<td>数组越界</td>\n</tr>\n<tr>\n<td>NumberFormatException</td>\n<td>字符串转数值类型异常</td>\n</tr>\n<tr>\n<td>FileNotFoundException</td>\n<td>打开文件失败</td>\n</tr>\n<tr>\n<td>IOException</td>\n<td>I/O异常</td>\n</tr>\n<tr>\n<td>ClassCastException</td>\n<td>强制类型转换异常</td>\n</tr>\n<tr>\n<td>ArrayStoreException</td>\n<td>向数组中存入错误类型对象时的异常</td>\n</tr>\n<tr>\n<td>IllegalArgumentException</td>\n<td>无效参数</td>\n</tr>\n<tr>\n<td>ArithmeticException</td>\n<td>运算异常</td>\n</tr>\n<tr>\n<td>NegativeArraySizeException</td>\n<td>创建长度为负的数组异常</td>\n</tr>\n<tr>\n<td>NoSuchMethodException</td>\n<td>找不到方法</td>\n</tr>\n<tr>\n<td>SecurityException</td>\n<td>存在安全侵犯</td>\n</tr>\n<tr>\n<td>UnsupportedOperationException</td>\n<td>不支持的操作</td>\n</tr>\n<tr>\n<td>RuntimeException</td>\n<td>运行时异常父类</td>\n</tr>\n</tbody></table>\n"},{"title":"抽象类、抽象方法","date":"2021-11-24T11:26:50.000Z","_content":"\n## 抽象方法：没有方法体的方法，且必须被abstract修饰\n* 作用：为了让子类继承来实现属于子类的方法体\n* 特点：\n  * 缺省默认为public方法，必须为public或者protected方法，如果是private，子类便无法实现该方法\n  * 对应的类一定是抽象类\n  * 没有方法体，只有一个大括号\n  * 构造方法不能声明为抽象方法\n\n## 抽象类：没有足够的信息来描述一个对象的类\n* 作用：将一些共有的属性和方法进行抽取整合成一个类，用来给其他类继承，然后子类重写抽象方法来实现子类自己的方法体\n* 特点：\n  * 一定用abstract修饰\n  * 不一定包含抽象方法，但有抽象方法的一定是抽象类\n  * 不能被实例化\n  * 只能通过继承的方式来直接使用到抽象类\n  * 子类必须重写自己继承的抽象类的全部抽象方法，如果不想全部重写，那必须自己为抽象类\n  * 只有抽象类的非抽象子类才能实例化\n\n\n## 面试题\n### 抽象类必须要有抽象方法吗？\n* 非必须\n\n### 抽象类与普通类的异同\n* 异：\n  * 抽象类不能被实例化，普通类可以\n  * 子类继承抽象类时必须实现抽象方法，除非声明自己也是抽象类，普通类方法重写非必须\n  * 抽象类需要使用abstract修饰\n  * 抽象方法不能被private修饰\n* 同：除了异都是同，比如都可以包含成员方法、成员变量等\n\n### 抽象类能使用 final 修饰吗？\n* 不能，因为抽象类只有被继承才能发挥价值，而被final修饰的类不能被继承\n\n### 接口和抽象类异同？\n* 同：\n  * 都不能被实例化\n  * 接口的实现类和抽象类的子类只有实现了接口和抽象类要求实现的抽象方法才能被实例化\n* 异：\n  * 接口用interface声明、抽象类用abstract修饰，接口实现类用implements来声明实现某个接口，抽象类的子类用extends来继承抽象类\n  * 抽象类中的抽象方法不能被private修饰\n  * 子类继承抽象类，必须实现抽象方法，否则需要声明自己为抽象类\n  * 都可以有成员方法、成员变量，但是接口变量默认被public static final修饰，接口方法只能是default method、static method或者被public abstract修饰\n  * 子类只能继承一个抽象类，但可以使用接口实现多继承\n  * 接口强调实现，抽象类强调类型、归属、多态的意思\n","source":"_posts/Q&A/Java/抽象类、抽象方法.md","raw":"---\ntitle: 抽象类、抽象方法\ndate: 2021-11-24 19:26:50\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## 抽象方法：没有方法体的方法，且必须被abstract修饰\n* 作用：为了让子类继承来实现属于子类的方法体\n* 特点：\n  * 缺省默认为public方法，必须为public或者protected方法，如果是private，子类便无法实现该方法\n  * 对应的类一定是抽象类\n  * 没有方法体，只有一个大括号\n  * 构造方法不能声明为抽象方法\n\n## 抽象类：没有足够的信息来描述一个对象的类\n* 作用：将一些共有的属性和方法进行抽取整合成一个类，用来给其他类继承，然后子类重写抽象方法来实现子类自己的方法体\n* 特点：\n  * 一定用abstract修饰\n  * 不一定包含抽象方法，但有抽象方法的一定是抽象类\n  * 不能被实例化\n  * 只能通过继承的方式来直接使用到抽象类\n  * 子类必须重写自己继承的抽象类的全部抽象方法，如果不想全部重写，那必须自己为抽象类\n  * 只有抽象类的非抽象子类才能实例化\n\n\n## 面试题\n### 抽象类必须要有抽象方法吗？\n* 非必须\n\n### 抽象类与普通类的异同\n* 异：\n  * 抽象类不能被实例化，普通类可以\n  * 子类继承抽象类时必须实现抽象方法，除非声明自己也是抽象类，普通类方法重写非必须\n  * 抽象类需要使用abstract修饰\n  * 抽象方法不能被private修饰\n* 同：除了异都是同，比如都可以包含成员方法、成员变量等\n\n### 抽象类能使用 final 修饰吗？\n* 不能，因为抽象类只有被继承才能发挥价值，而被final修饰的类不能被继承\n\n### 接口和抽象类异同？\n* 同：\n  * 都不能被实例化\n  * 接口的实现类和抽象类的子类只有实现了接口和抽象类要求实现的抽象方法才能被实例化\n* 异：\n  * 接口用interface声明、抽象类用abstract修饰，接口实现类用implements来声明实现某个接口，抽象类的子类用extends来继承抽象类\n  * 抽象类中的抽象方法不能被private修饰\n  * 子类继承抽象类，必须实现抽象方法，否则需要声明自己为抽象类\n  * 都可以有成员方法、成员变量，但是接口变量默认被public static final修饰，接口方法只能是default method、static method或者被public abstract修饰\n  * 子类只能继承一个抽象类，但可以使用接口实现多继承\n  * 接口强调实现，抽象类强调类型、归属、多态的意思\n","slug":"Q&A/Java/抽象类、抽象方法","published":1,"updated":"2022-04-12T09:00:46.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c4003xwgtt1im1ad4e","content":"<h2 id=\"抽象方法：没有方法体的方法，且必须被abstract修饰\"><a href=\"#抽象方法：没有方法体的方法，且必须被abstract修饰\" class=\"headerlink\" title=\"抽象方法：没有方法体的方法，且必须被abstract修饰\"></a>抽象方法：没有方法体的方法，且必须被abstract修饰</h2><ul>\n<li>作用：为了让子类继承来实现属于子类的方法体</li>\n<li>特点：<ul>\n<li>缺省默认为public方法，必须为public或者protected方法，如果是private，子类便无法实现该方法</li>\n<li>对应的类一定是抽象类</li>\n<li>没有方法体，只有一个大括号</li>\n<li>构造方法不能声明为抽象方法</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象类：没有足够的信息来描述一个对象的类\"><a href=\"#抽象类：没有足够的信息来描述一个对象的类\" class=\"headerlink\" title=\"抽象类：没有足够的信息来描述一个对象的类\"></a>抽象类：没有足够的信息来描述一个对象的类</h2><ul>\n<li>作用：将一些共有的属性和方法进行抽取整合成一个类，用来给其他类继承，然后子类重写抽象方法来实现子类自己的方法体</li>\n<li>特点：<ul>\n<li>一定用abstract修饰</li>\n<li>不一定包含抽象方法，但有抽象方法的一定是抽象类</li>\n<li>不能被实例化</li>\n<li>只能通过继承的方式来直接使用到抽象类</li>\n<li>子类必须重写自己继承的抽象类的全部抽象方法，如果不想全部重写，那必须自己为抽象类</li>\n<li>只有抽象类的非抽象子类才能实例化</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><h3 id=\"抽象类必须要有抽象方法吗？\"><a href=\"#抽象类必须要有抽象方法吗？\" class=\"headerlink\" title=\"抽象类必须要有抽象方法吗？\"></a>抽象类必须要有抽象方法吗？</h3><ul>\n<li>非必须</li>\n</ul>\n<h3 id=\"抽象类与普通类的异同\"><a href=\"#抽象类与普通类的异同\" class=\"headerlink\" title=\"抽象类与普通类的异同\"></a>抽象类与普通类的异同</h3><ul>\n<li>异：<ul>\n<li>抽象类不能被实例化，普通类可以</li>\n<li>子类继承抽象类时必须实现抽象方法，除非声明自己也是抽象类，普通类方法重写非必须</li>\n<li>抽象类需要使用abstract修饰</li>\n<li>抽象方法不能被private修饰</li>\n</ul>\n</li>\n<li>同：除了异都是同，比如都可以包含成员方法、成员变量等</li>\n</ul>\n<h3 id=\"抽象类能使用-final-修饰吗？\"><a href=\"#抽象类能使用-final-修饰吗？\" class=\"headerlink\" title=\"抽象类能使用 final 修饰吗？\"></a>抽象类能使用 final 修饰吗？</h3><ul>\n<li>不能，因为抽象类只有被继承才能发挥价值，而被final修饰的类不能被继承</li>\n</ul>\n<h3 id=\"接口和抽象类异同？\"><a href=\"#接口和抽象类异同？\" class=\"headerlink\" title=\"接口和抽象类异同？\"></a>接口和抽象类异同？</h3><ul>\n<li>同：<ul>\n<li>都不能被实例化</li>\n<li>接口的实现类和抽象类的子类只有实现了接口和抽象类要求实现的抽象方法才能被实例化</li>\n</ul>\n</li>\n<li>异：<ul>\n<li>接口用interface声明、抽象类用abstract修饰，接口实现类用implements来声明实现某个接口，抽象类的子类用extends来继承抽象类</li>\n<li>抽象类中的抽象方法不能被private修饰</li>\n<li>子类继承抽象类，必须实现抽象方法，否则需要声明自己为抽象类</li>\n<li>都可以有成员方法、成员变量，但是接口变量默认被public static final修饰，接口方法只能是default method、static method或者被public abstract修饰</li>\n<li>子类只能继承一个抽象类，但可以使用接口实现多继承</li>\n<li>接口强调实现，抽象类强调类型、归属、多态的意思</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"抽象方法：没有方法体的方法，且必须被abstract修饰\"><a href=\"#抽象方法：没有方法体的方法，且必须被abstract修饰\" class=\"headerlink\" title=\"抽象方法：没有方法体的方法，且必须被abstract修饰\"></a>抽象方法：没有方法体的方法，且必须被abstract修饰</h2><ul>\n<li>作用：为了让子类继承来实现属于子类的方法体</li>\n<li>特点：<ul>\n<li>缺省默认为public方法，必须为public或者protected方法，如果是private，子类便无法实现该方法</li>\n<li>对应的类一定是抽象类</li>\n<li>没有方法体，只有一个大括号</li>\n<li>构造方法不能声明为抽象方法</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象类：没有足够的信息来描述一个对象的类\"><a href=\"#抽象类：没有足够的信息来描述一个对象的类\" class=\"headerlink\" title=\"抽象类：没有足够的信息来描述一个对象的类\"></a>抽象类：没有足够的信息来描述一个对象的类</h2><ul>\n<li>作用：将一些共有的属性和方法进行抽取整合成一个类，用来给其他类继承，然后子类重写抽象方法来实现子类自己的方法体</li>\n<li>特点：<ul>\n<li>一定用abstract修饰</li>\n<li>不一定包含抽象方法，但有抽象方法的一定是抽象类</li>\n<li>不能被实例化</li>\n<li>只能通过继承的方式来直接使用到抽象类</li>\n<li>子类必须重写自己继承的抽象类的全部抽象方法，如果不想全部重写，那必须自己为抽象类</li>\n<li>只有抽象类的非抽象子类才能实例化</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><h3 id=\"抽象类必须要有抽象方法吗？\"><a href=\"#抽象类必须要有抽象方法吗？\" class=\"headerlink\" title=\"抽象类必须要有抽象方法吗？\"></a>抽象类必须要有抽象方法吗？</h3><ul>\n<li>非必须</li>\n</ul>\n<h3 id=\"抽象类与普通类的异同\"><a href=\"#抽象类与普通类的异同\" class=\"headerlink\" title=\"抽象类与普通类的异同\"></a>抽象类与普通类的异同</h3><ul>\n<li>异：<ul>\n<li>抽象类不能被实例化，普通类可以</li>\n<li>子类继承抽象类时必须实现抽象方法，除非声明自己也是抽象类，普通类方法重写非必须</li>\n<li>抽象类需要使用abstract修饰</li>\n<li>抽象方法不能被private修饰</li>\n</ul>\n</li>\n<li>同：除了异都是同，比如都可以包含成员方法、成员变量等</li>\n</ul>\n<h3 id=\"抽象类能使用-final-修饰吗？\"><a href=\"#抽象类能使用-final-修饰吗？\" class=\"headerlink\" title=\"抽象类能使用 final 修饰吗？\"></a>抽象类能使用 final 修饰吗？</h3><ul>\n<li>不能，因为抽象类只有被继承才能发挥价值，而被final修饰的类不能被继承</li>\n</ul>\n<h3 id=\"接口和抽象类异同？\"><a href=\"#接口和抽象类异同？\" class=\"headerlink\" title=\"接口和抽象类异同？\"></a>接口和抽象类异同？</h3><ul>\n<li>同：<ul>\n<li>都不能被实例化</li>\n<li>接口的实现类和抽象类的子类只有实现了接口和抽象类要求实现的抽象方法才能被实例化</li>\n</ul>\n</li>\n<li>异：<ul>\n<li>接口用interface声明、抽象类用abstract修饰，接口实现类用implements来声明实现某个接口，抽象类的子类用extends来继承抽象类</li>\n<li>抽象类中的抽象方法不能被private修饰</li>\n<li>子类继承抽象类，必须实现抽象方法，否则需要声明自己为抽象类</li>\n<li>都可以有成员方法、成员变量，但是接口变量默认被public static final修饰，接口方法只能是default method、static method或者被public abstract修饰</li>\n<li>子类只能继承一个抽象类，但可以使用接口实现多继承</li>\n<li>接口强调实现，抽象类强调类型、归属、多态的意思</li>\n</ul>\n</li>\n</ul>\n"},{"title":"接口","date":"2021-11-25T11:51:40.000Z","_content":"\n## 特点\n* 使用interface声明\n* 所有成员变量默认被public static final修饰\n* JDK1.8之前所有成员方法默认被public abstract修饰\n\n## JDK 1.8 之后的变化\n* default method：\n  * 允许添加非抽象的方法实现，但必须使用default修饰\n  * 可以被实现子类实例调用，实现子类不能重写\n  * 实现子类实现的多个接口中有同样的default method，那么该实现子类需要重写该方法\n* static method:\n  * 即接口自己的static method，只能通过接口名来调用（接口名.static method）\n","source":"_posts/Q&A/Java/接口.md","raw":"---\ntitle: 接口\ndate: 2021-11-25 19:51:40\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## 特点\n* 使用interface声明\n* 所有成员变量默认被public static final修饰\n* JDK1.8之前所有成员方法默认被public abstract修饰\n\n## JDK 1.8 之后的变化\n* default method：\n  * 允许添加非抽象的方法实现，但必须使用default修饰\n  * 可以被实现子类实例调用，实现子类不能重写\n  * 实现子类实现的多个接口中有同样的default method，那么该实现子类需要重写该方法\n* static method:\n  * 即接口自己的static method，只能通过接口名来调用（接口名.static method）\n","slug":"Q&A/Java/接口","published":1,"updated":"2022-04-12T09:00:46.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c50041wgttb42qfwdt","content":"<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>使用interface声明</li>\n<li>所有成员变量默认被public static final修饰</li>\n<li>JDK1.8之前所有成员方法默认被public abstract修饰</li>\n</ul>\n<h2 id=\"JDK-1-8-之后的变化\"><a href=\"#JDK-1-8-之后的变化\" class=\"headerlink\" title=\"JDK 1.8 之后的变化\"></a>JDK 1.8 之后的变化</h2><ul>\n<li>default method：<ul>\n<li>允许添加非抽象的方法实现，但必须使用default修饰</li>\n<li>可以被实现子类实例调用，实现子类不能重写</li>\n<li>实现子类实现的多个接口中有同样的default method，那么该实现子类需要重写该方法</li>\n</ul>\n</li>\n<li>static method:<ul>\n<li>即接口自己的static method，只能通过接口名来调用（接口名.static method）</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>使用interface声明</li>\n<li>所有成员变量默认被public static final修饰</li>\n<li>JDK1.8之前所有成员方法默认被public abstract修饰</li>\n</ul>\n<h2 id=\"JDK-1-8-之后的变化\"><a href=\"#JDK-1-8-之后的变化\" class=\"headerlink\" title=\"JDK 1.8 之后的变化\"></a>JDK 1.8 之后的变化</h2><ul>\n<li>default method：<ul>\n<li>允许添加非抽象的方法实现，但必须使用default修饰</li>\n<li>可以被实现子类实例调用，实现子类不能重写</li>\n<li>实现子类实现的多个接口中有同样的default method，那么该实现子类需要重写该方法</li>\n</ul>\n</li>\n<li>static method:<ul>\n<li>即接口自己的static method，只能通过接口名来调用（接口名.static method）</li>\n</ul>\n</li>\n</ul>\n"},{"title":"重写、重载","date":"2021-11-25T07:17:59.000Z","_content":"\n## 重写：子类重写父类方法，壳不变，瓤变\n\n## 重载：同一个类中方法名一样，返回值、参数不一样\n","source":"_posts/Q&A/Java/重写、重载.md","raw":"---\ntitle: 重写、重载\ndate: 2021-11-25 15:17:59\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## 重写：子类重写父类方法，壳不变，瓤变\n\n## 重载：同一个类中方法名一样，返回值、参数不一样\n","slug":"Q&A/Java/重写、重载","published":1,"updated":"2022-04-12T09:00:46.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c60043wgttgx3r1qil","content":"<h2 id=\"重写：子类重写父类方法，壳不变，瓤变\"><a href=\"#重写：子类重写父类方法，壳不变，瓤变\" class=\"headerlink\" title=\"重写：子类重写父类方法，壳不变，瓤变\"></a>重写：子类重写父类方法，壳不变，瓤变</h2><h2 id=\"重载：同一个类中方法名一样，返回值、参数不一样\"><a href=\"#重载：同一个类中方法名一样，返回值、参数不一样\" class=\"headerlink\" title=\"重载：同一个类中方法名一样，返回值、参数不一样\"></a>重载：同一个类中方法名一样，返回值、参数不一样</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"重写：子类重写父类方法，壳不变，瓤变\"><a href=\"#重写：子类重写父类方法，壳不变，瓤变\" class=\"headerlink\" title=\"重写：子类重写父类方法，壳不变，瓤变\"></a>重写：子类重写父类方法，壳不变，瓤变</h2><h2 id=\"重载：同一个类中方法名一样，返回值、参数不一样\"><a href=\"#重载：同一个类中方法名一样，返回值、参数不一样\" class=\"headerlink\" title=\"重载：同一个类中方法名一样，返回值、参数不一样\"></a>重载：同一个类中方法名一样，返回值、参数不一样</h2>"},{"title":"面向对象、面向过程","date":"2021-11-22T14:22:10.000Z","_content":"\n## 面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\n### 对象：有自己独特个性的任何事物\n* 特点：\n    * 继承：子类继承父类属性和方法\n    * 封装：将不需要外接知道的内容隐藏起来，优点是实现了\"高内聚、低耦合\"；隐藏实现细节；对成员变量实现更精确控制  \n    * 多态：一种行为具有多种表现形式，存在条件：继承、重写、父类引用指向子类对象\n* 模板：类\n* 组成：属性、方法\n\n### 优缺点：\n* 优：\n    * 适合大型系统\n    * 易复用\n    * 易拓展\n    * 易维护\n    * 低耦合\n\n* 缺：\n    * 较抽象\n    * 性能差\n\n\n## 面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\n### 优缺点：\n* 优：\n    * 适合小型系统\n    * 易理解\n    * 性能好\n* 缺：\n    * 不适合大型系统\n    * 难复用\n    * 难拓展\n    * 难维护\n","source":"_posts/Q&A/Java/面向对象、面向过程.md","raw":"---\ntitle: 面向对象、面向过程\ndate: 2021-11-22 22:22:10\ntags: Q&A\ncategories:\n- [Q&A, Q&A-java]\n---\n\n## 面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\n### 对象：有自己独特个性的任何事物\n* 特点：\n    * 继承：子类继承父类属性和方法\n    * 封装：将不需要外接知道的内容隐藏起来，优点是实现了\"高内聚、低耦合\"；隐藏实现细节；对成员变量实现更精确控制  \n    * 多态：一种行为具有多种表现形式，存在条件：继承、重写、父类引用指向子类对象\n* 模板：类\n* 组成：属性、方法\n\n### 优缺点：\n* 优：\n    * 适合大型系统\n    * 易复用\n    * 易拓展\n    * 易维护\n    * 低耦合\n\n* 缺：\n    * 较抽象\n    * 性能差\n\n\n## 面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\n### 优缺点：\n* 优：\n    * 适合小型系统\n    * 易理解\n    * 性能好\n* 缺：\n    * 不适合大型系统\n    * 难复用\n    * 难拓展\n    * 难维护\n","slug":"Q&A/Java/面向对象、面向过程","published":1,"updated":"2022-04-12T09:00:46.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1vwz0c70046wgtt454w915e","content":"<h2 id=\"面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\"><a href=\"#面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\" class=\"headerlink\" title=\"面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\"></a>面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念</h2><h3 id=\"对象：有自己独特个性的任何事物\"><a href=\"#对象：有自己独特个性的任何事物\" class=\"headerlink\" title=\"对象：有自己独特个性的任何事物\"></a>对象：有自己独特个性的任何事物</h3><ul>\n<li>特点：<ul>\n<li>继承：子类继承父类属性和方法</li>\n<li>封装：将不需要外接知道的内容隐藏起来，优点是实现了”高内聚、低耦合”；隐藏实现细节；对成员变量实现更精确控制  </li>\n<li>多态：一种行为具有多种表现形式，存在条件：继承、重写、父类引用指向子类对象</li>\n</ul>\n</li>\n<li>模板：类</li>\n<li>组成：属性、方法</li>\n</ul>\n<h3 id=\"优缺点：\"><a href=\"#优缺点：\" class=\"headerlink\" title=\"优缺点：\"></a>优缺点：</h3><ul>\n<li><p>优：</p>\n<ul>\n<li>适合大型系统</li>\n<li>易复用</li>\n<li>易拓展</li>\n<li>易维护</li>\n<li>低耦合</li>\n</ul>\n</li>\n<li><p>缺：</p>\n<ul>\n<li>较抽象</li>\n<li>性能差</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\"><a href=\"#面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\" class=\"headerlink\" title=\"面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\"></a>面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节</h2><h3 id=\"优缺点：-1\"><a href=\"#优缺点：-1\" class=\"headerlink\" title=\"优缺点：\"></a>优缺点：</h3><ul>\n<li>优：<ul>\n<li>适合小型系统</li>\n<li>易理解</li>\n<li>性能好</li>\n</ul>\n</li>\n<li>缺：<ul>\n<li>不适合大型系统</li>\n<li>难复用</li>\n<li>难拓展</li>\n<li>难维护</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\"><a href=\"#面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\" class=\"headerlink\" title=\"面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念\"></a>面向对象：将数据和操作方法放到一起，作为一个相互依存的整体-对象，对象是人对具体事务抽象出来的概念</h2><h3 id=\"对象：有自己独特个性的任何事物\"><a href=\"#对象：有自己独特个性的任何事物\" class=\"headerlink\" title=\"对象：有自己独特个性的任何事物\"></a>对象：有自己独特个性的任何事物</h3><ul>\n<li>特点：<ul>\n<li>继承：子类继承父类属性和方法</li>\n<li>封装：将不需要外接知道的内容隐藏起来，优点是实现了”高内聚、低耦合”；隐藏实现细节；对成员变量实现更精确控制  </li>\n<li>多态：一种行为具有多种表现形式，存在条件：继承、重写、父类引用指向子类对象</li>\n</ul>\n</li>\n<li>模板：类</li>\n<li>组成：属性、方法</li>\n</ul>\n<h3 id=\"优缺点：\"><a href=\"#优缺点：\" class=\"headerlink\" title=\"优缺点：\"></a>优缺点：</h3><ul>\n<li><p>优：</p>\n<ul>\n<li>适合大型系统</li>\n<li>易复用</li>\n<li>易拓展</li>\n<li>易维护</li>\n<li>低耦合</li>\n</ul>\n</li>\n<li><p>缺：</p>\n<ul>\n<li>较抽象</li>\n<li>性能差</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\"><a href=\"#面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\" class=\"headerlink\" title=\"面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节\"></a>面向过程：与面向对象相反，要按照执行过程自己实现所有功能细节</h2><h3 id=\"优缺点：-1\"><a href=\"#优缺点：-1\" class=\"headerlink\" title=\"优缺点：\"></a>优缺点：</h3><ul>\n<li>优：<ul>\n<li>适合小型系统</li>\n<li>易理解</li>\n<li>性能好</li>\n</ul>\n</li>\n<li>缺：<ul>\n<li>不适合大型系统</li>\n<li>难复用</li>\n<li>难拓展</li>\n<li>难维护</li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl1vwz0ad0005wgtthu6dhafk","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0al000hwgtthmdx3h6d"},{"post_id":"cl1vwz09u0000wgtt9okrfjgy","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0an000kwgtt918ua6ee"},{"post_id":"cl1vwz0ae0006wgtt7ip46iy4","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0ao000nwgttd58g091j"},{"post_id":"cl1vwz0ah000awgtthop0dub6","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0ap000qwgtt5ro9bc0t"},{"post_id":"cl1vwz0a30001wgttgi7f2qg2","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0ar000twgtt18te1oa3"},{"post_id":"cl1vwz0ai000cwgtt1x0ackg8","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0as000wwgtteauyc6nu"},{"post_id":"cl1vwz0ak000gwgttb8eddty6","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0at000zwgtt5g89h6ns"},{"post_id":"cl1vwz0aa0003wgttdwqohty7","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0au0012wgtth5ct0m5l"},{"post_id":"cl1vwz0al000jwgtt4xe94bkz","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0av0015wgttfwou49an"},{"post_id":"cl1vwz0an000mwgtt8xqnef4m","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0av0018wgtt44983doo"},{"post_id":"cl1vwz0ap000pwgttbppkfj57","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0aw001bwgtt4fifabd2"},{"post_id":"cl1vwz0aq000swgtt13tgdd0e","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0ax001ewgtth9mo9cx1"},{"post_id":"cl1vwz0ar000vwgtt20qo8fil","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0ay001hwgtt98ttf7k6"},{"post_id":"cl1vwz0as000ywgtt64mff3qy","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0az001lwgtt7uth7ivz"},{"post_id":"cl1vwz0at0011wgttexgifnjm","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0b1001pwgtt3glrf0w4"},{"post_id":"cl1vwz0au0014wgttbqsfcanq","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0b2001swgttgx9q29ok"},{"post_id":"cl1vwz0av0017wgtt7dhwdcvk","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0b3001xwgttbo639dqy"},{"post_id":"cl1vwz0aw001awgttclnle2k4","category_id":"cl1vwz0ab0004wgtthuss535w","_id":"cl1vwz0b40020wgtt6m03agrq"},{"post_id":"cl1vwz0ax001dwgtt98wfbqaf","category_id":"cl1vwz0az001kwgtt72y7fziz","_id":"cl1vwz0bd0024wgttaxrj9amy"},{"post_id":"cl1vwz0ay001gwgtt1q0jfxwk","category_id":"cl1vwz0b2001twgtt9hkb9npv","_id":"cl1vwz0bf0029wgtte96j2pdd"},{"post_id":"cl1vwz0az001jwgttcqbt09kg","category_id":"cl1vwz0b40021wgtt6x802a1h","_id":"cl1vwz0bh002dwgttdh169l97"},{"post_id":"cl1vwz0b0001owgtth8em6mr8","category_id":"cl1vwz0b40021wgtt6x802a1h","_id":"cl1vwz0bi002gwgttd84yh6f9"},{"post_id":"cl1vwz0b1001rwgttf2uh639w","category_id":"cl1vwz0bf002bwgtt5ecz9di5","_id":"cl1vwz0bj002iwgtt3uhi8xzc"},{"post_id":"cl1vwz0b2001vwgttfya5hjc8","category_id":"cl1vwz0bf002bwgtt5ecz9di5","_id":"cl1vwz0bj002kwgtt5ahoh8nj"},{"post_id":"cl1vwz0b3001zwgtt2xec379e","category_id":"cl1vwz0bi002hwgtt8y5fg92c","_id":"cl1vwz0bj002lwgtt3wkhden7"},{"post_id":"cl1vwz0b50023wgtt32jz0gau","category_id":"cl1vwz0bj002jwgtt5h5hhux9","_id":"cl1vwz0bj002mwgtt71rs1ma4"},{"post_id":"cl1vwz0bn002nwgttgj8e17zp","category_id":"cl1vwz0bo002rwgttcsew2b8a","_id":"cl1vwz0bu0033wgtt4vq3e9tm"},{"post_id":"cl1vwz0bn002owgttc754ffoz","category_id":"cl1vwz0bo002rwgttcsew2b8a","_id":"cl1vwz0bv0038wgtt3hso7ff4"},{"post_id":"cl1vwz0bo002qwgtt2tpx5zce","category_id":"cl1vwz0bo002rwgttcsew2b8a","_id":"cl1vwz0bz003ewgtta1e3gyxb"},{"post_id":"cl1vwz0bp002twgtta5dk9ro2","category_id":"cl1vwz0bv0036wgtt84ir3uo1","_id":"cl1vwz0c1003lwgtt1yf07ns2"},{"post_id":"cl1vwz0bq002vwgtth7tue0c2","category_id":"cl1vwz0by003cwgttenblg690","_id":"cl1vwz0c3003twgtt7z2pfr8m"},{"post_id":"cl1vwz0c0003kwgtt59c2f5kx","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ca004lwgttft5wh56d"},{"post_id":"cl1vwz0c0003kwgtt59c2f5kx","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ca004mwgttgjdj89n0"},{"post_id":"cl1vwz0br002ywgtth009fgwn","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ca004owgttbqrr0vfs"},{"post_id":"cl1vwz0br002ywgtth009fgwn","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ca004pwgtta7f04oif"},{"post_id":"cl1vwz0c1003owgttamxhac0w","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cb004rwgtt2vt22emx"},{"post_id":"cl1vwz0c1003owgttamxhac0w","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0cb004swgtt7mg1f3zx"},{"post_id":"cl1vwz0c2003qwgtter1s49qn","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cb004uwgttc05z9eu4"},{"post_id":"cl1vwz0c2003qwgtter1s49qn","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0cc004vwgtt214oenro"},{"post_id":"cl1vwz0bs002zwgtt8tz1e5a8","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cc004xwgtt0kt8f3d5"},{"post_id":"cl1vwz0bs002zwgtt8tz1e5a8","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0cc004ywgttadwg315z"},{"post_id":"cl1vwz0c3003vwgttb4ij8w3d","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cc0050wgtta1wggoal"},{"post_id":"cl1vwz0c3003vwgttb4ij8w3d","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0cd0051wgtt98jk9g82"},{"post_id":"cl1vwz0c4003xwgtt1im1ad4e","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cd0053wgtt2itl4mk7"},{"post_id":"cl1vwz0c4003xwgtt1im1ad4e","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0cd0054wgttfs0iaoj9"},{"post_id":"cl1vwz0bt0031wgtt11aqhojh","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cd0056wgttflu53s7y"},{"post_id":"cl1vwz0bt0031wgtt11aqhojh","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ce0057wgtt6by32zfp"},{"post_id":"cl1vwz0c50041wgttb42qfwdt","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ce0059wgttgpxi6zsi"},{"post_id":"cl1vwz0c50041wgttb42qfwdt","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ce005awgttavlvbj5l"},{"post_id":"cl1vwz0c60043wgttgx3r1qil","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cg005cwgttbi6139tv"},{"post_id":"cl1vwz0c60043wgttgx3r1qil","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0cg005dwgtt9csh64va"},{"post_id":"cl1vwz0bu0035wgttfeev03w6","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0cg005fwgtta641b8ip"},{"post_id":"cl1vwz0bu0035wgttfeev03w6","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0cg005gwgtt9buk20z0"},{"post_id":"cl1vwz0c70046wgtt454w915e","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ch005iwgtte2l26c5y"},{"post_id":"cl1vwz0c70046wgtt454w915e","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ch005jwgttem5y0oib"},{"post_id":"cl1vwz0bv0037wgttfwo01cd3","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ch005lwgtt2ejr5fe8"},{"post_id":"cl1vwz0bv0037wgttfwo01cd3","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ch005mwgtt9pye73n5"},{"post_id":"cl1vwz0bx003awgtt2mum8gh0","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ci005owgttcucv67c1"},{"post_id":"cl1vwz0bx003awgtt2mum8gh0","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ci005pwgtt4virbgem"},{"post_id":"cl1vwz0by003dwgtt68xac3g6","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ci005qwgtthaje5l8b"},{"post_id":"cl1vwz0by003dwgtt68xac3g6","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ci005rwgtt639v8bs2"},{"post_id":"cl1vwz0bz003hwgtt4b7jb8cn","category_id":"cl1vwz0c0003jwgttats70fr5","_id":"cl1vwz0ci005swgtt554va0bq"},{"post_id":"cl1vwz0bz003hwgtt4b7jb8cn","category_id":"cl1vwz0c9004iwgttfdp968qa","_id":"cl1vwz0ci005twgtt72ck5x1t"}],"PostTag":[{"post_id":"cl1vwz0ad0005wgtthu6dhafk","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ah0009wgttbzhu4pnu"},{"post_id":"cl1vwz09u0000wgtt9okrfjgy","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ai000bwgttbb5k10g7"},{"post_id":"cl1vwz0ae0006wgtt7ip46iy4","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ak000fwgtt31qqbo35"},{"post_id":"cl1vwz0ah000awgtthop0dub6","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0al000iwgtt7ic2f2bk"},{"post_id":"cl1vwz0a30001wgttgi7f2qg2","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0an000lwgtth53mem84"},{"post_id":"cl1vwz0ai000cwgtt1x0ackg8","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ao000owgtt08hgghpo"},{"post_id":"cl1vwz0ak000gwgttb8eddty6","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0aq000rwgttfyowc5ch"},{"post_id":"cl1vwz0aa0003wgttdwqohty7","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ar000uwgttdde1flib"},{"post_id":"cl1vwz0al000jwgtt4xe94bkz","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0as000xwgtt7lm4d918"},{"post_id":"cl1vwz0an000mwgtt8xqnef4m","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0at0010wgtt3yr61jhi"},{"post_id":"cl1vwz0ap000pwgttbppkfj57","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0au0013wgtt11un5vgq"},{"post_id":"cl1vwz0aq000swgtt13tgdd0e","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0av0016wgttf6nl6uwf"},{"post_id":"cl1vwz0ar000vwgtt20qo8fil","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0aw0019wgtt6eefd3hp"},{"post_id":"cl1vwz0as000ywgtt64mff3qy","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ax001cwgtt0p2r1211"},{"post_id":"cl1vwz0at0011wgttexgifnjm","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ay001fwgtt5w6x0agk"},{"post_id":"cl1vwz0au0014wgttbqsfcanq","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0ay001iwgtt9wi35rvq"},{"post_id":"cl1vwz0av0017wgtt7dhwdcvk","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0b0001nwgtthravh5pl"},{"post_id":"cl1vwz0aw001awgttclnle2k4","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0b1001qwgtt6rd4cpc9"},{"post_id":"cl1vwz0ax001dwgtt98wfbqaf","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0b2001uwgttfgpaagui"},{"post_id":"cl1vwz0b1001rwgttf2uh639w","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0b3001ywgtt00rtetia"},{"post_id":"cl1vwz0ay001gwgtt1q0jfxwk","tag_id":"cl1vwz0b0001mwgtt0v0tdgi7","_id":"cl1vwz0b50022wgtt8tfqb018"},{"post_id":"cl1vwz0b2001vwgttfya5hjc8","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0be0026wgtt8lrrbs5s"},{"post_id":"cl1vwz0b3001zwgtt2xec379e","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0bf0028wgtt1eu35270"},{"post_id":"cl1vwz0az001jwgttcqbt09kg","tag_id":"cl1vwz0b3001wwgtt8d6u2d80","_id":"cl1vwz0bf002awgtt6n8egrn0"},{"post_id":"cl1vwz0b50023wgtt32jz0gau","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0bh002cwgtt3hvu8lca"},{"post_id":"cl1vwz0b0001owgtth8em6mr8","tag_id":"cl1vwz0b3001wwgtt8d6u2d80","_id":"cl1vwz0bh002ewgtt3xy4d5ca"},{"post_id":"cl1vwz0bn002nwgttgj8e17zp","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0bo002pwgtteucmd9xs"},{"post_id":"cl1vwz0bn002owgttc754ffoz","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0bp002swgttbtuj2b2j"},{"post_id":"cl1vwz0bo002qwgtt2tpx5zce","tag_id":"cl1vwz0a70002wgtt15ce1p05","_id":"cl1vwz0bp002uwgtt37vs0mbh"},{"post_id":"cl1vwz0bp002twgtta5dk9ro2","tag_id":"cl1vwz0br002xwgtt87t6eyws","_id":"cl1vwz0bu0034wgttavra9pgu"},{"post_id":"cl1vwz0bq002vwgtth7tue0c2","tag_id":"cl1vwz0bu0032wgtthin5hl3j","_id":"cl1vwz0by003bwgtt8zpx2ndm"},{"post_id":"cl1vwz0bx003awgtt2mum8gh0","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0bz003gwgtt5a8z1cz6"},{"post_id":"cl1vwz0br002ywgtth009fgwn","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c0003iwgttbmpr10lk"},{"post_id":"cl1vwz0by003dwgtt68xac3g6","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c1003nwgtt3xq71qp0"},{"post_id":"cl1vwz0bz003hwgtt4b7jb8cn","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c2003pwgttfd9eeyiy"},{"post_id":"cl1vwz0bs002zwgtt8tz1e5a8","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c3003uwgttalr919t2"},{"post_id":"cl1vwz0c0003kwgtt59c2f5kx","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c4003wwgttg2v89r6m"},{"post_id":"cl1vwz0c1003owgttamxhac0w","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c50040wgtt2qfw84rh"},{"post_id":"cl1vwz0bt0031wgtt11aqhojh","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c60042wgtt91wq1mp6"},{"post_id":"cl1vwz0c2003qwgtter1s49qn","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c70045wgtt8iggbmmv"},{"post_id":"cl1vwz0c3003vwgttb4ij8w3d","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c70047wgttge689neu"},{"post_id":"cl1vwz0bu0035wgttfeev03w6","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c80049wgtt2jy82glw"},{"post_id":"cl1vwz0c4003xwgtt1im1ad4e","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c8004awgtt6j2bagxr"},{"post_id":"cl1vwz0c50041wgttb42qfwdt","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c8004cwgtt4vb0317h"},{"post_id":"cl1vwz0bv0037wgttfwo01cd3","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c8004dwgtt3l5p1niv"},{"post_id":"cl1vwz0c60043wgttgx3r1qil","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c9004fwgttdxoyc9gq"},{"post_id":"cl1vwz0c70046wgtt454w915e","tag_id":"cl1vwz0bx0039wgtt0dpj7mgz","_id":"cl1vwz0c9004gwgtt0be2gqp8"}],"Tag":[{"name":"编程","_id":"cl1vwz0a70002wgtt15ce1p05"},{"name":"区块链","_id":"cl1vwz0b0001mwgtt0v0tdgi7"},{"name":"博客搭建","_id":"cl1vwz0b3001wwgtt8d6u2d80"},{"name":"电脑使用技巧","_id":"cl1vwz0br002xwgtt87t6eyws"},{"name":"脚本工具","_id":"cl1vwz0bu0032wgtthin5hl3j"},{"name":"Q&A","_id":"cl1vwz0bx0039wgtt0dpj7mgz"}]}}