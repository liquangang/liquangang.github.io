<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>静</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录知识、思考">
<meta property="og:type" content="website">
<meta property="og:title" content="静">
<meta property="og:url" content="https://liquangang.github.io/index.html">
<meta property="og:site_name" content="静">
<meta property="og:description" content="记录知识、思考">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="帝王之心">
<meta property="article:tag" content="编程、思维方式、知识">
<meta name="twitter:card" content="summary">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  
  
<script src="/js/load.js"></script>

  
<script src="/js/search.js"></script>

  <span class="local-search local-search-google local-search-plugin" style="right: 25px;top: 10px;;position:absolute;z-index:2;">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <script type="text/javascript" id="local.search.active">
          var inputArea = document.querySelector("#local-search-input");
          inputArea.onclick = function () {
              getSearchFile();
              this.onclick = null
          }
          inputArea.onkeydown = function () {
              if (event.keyCode == 13) return false
          }
      </script>
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>



  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">静</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liquangang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Q&amp;A/Java/Zookeeper" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/10/Q&A/Java/Zookeeper/" class="article-date">
  <time datetime="2022-05-10T10:07:28.000Z" itemprop="datePublished">2022-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/10/Q&A/Java/Zookeeper/">Zookeeper</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="zookeeper-是什么？"><a href="#zookeeper-是什么？" class="headerlink" title="zookeeper 是什么？"></a>zookeeper 是什么？</h2><p>一个分布式的、开源的分布式应用程序协调服务，是google chubby的开源实现，是hadoop和hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等</p>
<h2 id="zookeeper都有哪些功能？"><a href="#zookeeper都有哪些功能？" class="headerlink" title="zookeeper都有哪些功能？"></a>zookeeper都有哪些功能？</h2><table>
<thead>
<tr>
<th>功能点</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>集群管理</td>
<td>监控集群节点状态、运行请求等</td>
</tr>
<tr>
<td>主节点选举</td>
<td>即主节点挂掉之后从备用节点开始新一轮主节点的选举，使用zookeeper可以协助完成该过程</td>
</tr>
<tr>
<td>分布式锁</td>
<td>zookeeper提供两种锁：<br/>1、独占锁：只有一个线程使用资源<br/>2、共享锁：多个线程可读，一个线程可写</td>
</tr>
<tr>
<td>命名服务</td>
<td>客户端根据命名服务中制定的名字可以更方便的获取资源、服务地址、提供者等信息</td>
</tr>
</tbody></table>
<h2 id="zookeeper-有几种部署模式？"><a href="#zookeeper-有几种部署模式？" class="headerlink" title="zookeeper 有几种部署模式？"></a>zookeeper 有几种部署模式？</h2><table>
<thead>
<tr>
<th>部署模式</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>单机部署</td>
<td>一台机器上机器上运行</td>
</tr>
<tr>
<td>集群部署</td>
<td>多台机器上运行</td>
</tr>
<tr>
<td>伪集群部署</td>
<td>一台机器上部署多个实例运行</td>
</tr>
</tbody></table>
<h2 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h2><h3 id="通过原子广播机制实现实现节点间的状态同步，该机制依赖zab协议。"><a href="#通过原子广播机制实现实现节点间的状态同步，该机制依赖zab协议。" class="headerlink" title="通过原子广播机制实现实现节点间的状态同步，该机制依赖zab协议。"></a>通过<strong>原子广播机制</strong>实现实现节点间的状态同步，该机制依赖zab协议。</h3><h3 id="zab协议两种模式介绍"><a href="#zab协议两种模式介绍" class="headerlink" title="zab协议两种模式介绍"></a>zab协议两种模式介绍</h3><table>
<thead>
<tr>
<th>模式</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>恢复（选主）模式</td>
<td>当主节点崩溃时，会进入该模式，首先重新选出主节点，然后其他节点会与新主节点完成同步</td>
</tr>
<tr>
<td>广播（同步）模式</td>
<td>即主节点发生变化时，向其他节点广播以完成同步</td>
</tr>
</tbody></table>
<h2 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h2><p>在分布式环境中，有些业务只需要一个节点完成处理，其他节点共享该处理结果即可，这样可以减少运算资源消耗，提升效率，所以就需要设置一个主节点实现该需求</p>
<h2 id="集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h2><p>可以继续使用，奇数个节点的集群只要没超过一半节点宕机就可以继续正常对外提供服务</p>
<h2 id="说一下-zookeeper-的通知机制？"><a href="#说一下-zookeeper-的通知机制？" class="headerlink" title="说一下 zookeeper 的通知机制？"></a>说一下 zookeeper 的通知机制？</h2><p>客户端会对znode建立一个watcher事件，当znode发生变化时，这些客户端会受到zookeeper的通知，然后就可以根据该通知进行相关业务处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/05/10/Q&A/Java/Zookeeper/" data-id="cl3099frg003dqzd4cm0c4e92" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/Kafka" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/09/Q&A/Java/Kafka/" class="article-date">
  <time datetime="2022-05-09T07:16:37.000Z" itemprop="datePublished">2022-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/09/Q&A/Java/Kafka/">Kafka</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><p>不能，kafka需要zookeeper协调和管理kafka的节点服务器</p>
<h2 id="kafka-有几种数据保留的策略？"><a href="#kafka-有几种数据保留的策略？" class="headerlink" title="kafka 有几种数据保留的策略？"></a>kafka 有几种数据保留的策略？</h2><p>1、按照过期时间保留<br>2、按照消息大小保留</p>
<h2 id="kafka同时设置7天和10G清除数据，到第5天达到10G，kafka如何处理"><a href="#kafka同时设置7天和10G清除数据，到第5天达到10G，kafka如何处理" class="headerlink" title="kafka同时设置7天和10G清除数据，到第5天达到10G，kafka如何处理"></a>kafka同时设置7天和10G清除数据，到第5天达到10G，kafka如何处理</h2><p>kafka会执行清除工作，即清除逻辑是二者有其一条件满足即清除数据</p>
<h2 id="什么情况会导致-kafka-运行变慢？"><a href="#什么情况会导致-kafka-运行变慢？" class="headerlink" title="什么情况会导致 kafka 运行变慢？"></a>什么情况会导致 kafka 运行变慢？</h2><p>1、cpu性能瓶颈<br>2、磁盘读写瓶颈<br>3、网络瓶颈</p>
<h2 id="使用-kafka-集群需要注意什么？"><a href="#使用-kafka-集群需要注意什么？" class="headerlink" title="使用 kafka 集群需要注意什么？"></a>使用 kafka 集群需要注意什么？</h2><p>1、集群数量不是越多越好，最好不超过7个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低<br>2、集群数量最好是单数，因为超过一半故障集群就不可用了，设置为单数容错率更高</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/05/09/Q&A/Java/Kafka/" data-id="cl3099frc002yqzd4h36t42z0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/RabbitMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/06/Q&A/Java/RabbitMQ/" class="article-date">
  <time datetime="2022-05-06T11:47:29.000Z" itemprop="datePublished">2022-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/06/Q&A/Java/RabbitMQ/">RabbitMQ</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="rabbitmq-的使用场景有哪些？"><a href="#rabbitmq-的使用场景有哪些？" class="headerlink" title="rabbitmq 的使用场景有哪些？"></a>rabbitmq 的使用场景有哪些？</h2><ul>
<li>跨系统的异步通信</li>
<li>多应用交互解耦</li>
<li>应用内同步变异步</li>
<li>消息驱动的架构方式</li>
<li>应用需要更灵活的耦合方式</li>
<li>跨局域网、城市的通讯（比如cdn）</li>
</ul>
<h2 id="rabbitmq-有哪些重要的角色？"><a href="#rabbitmq-有哪些重要的角色？" class="headerlink" title="rabbitmq 有哪些重要的角色？"></a>rabbitmq 有哪些重要的角色？</h2><table>
<thead>
<tr>
<th>角色</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>生产者</td>
<td>消息创建者，负责创建和推送数据到消息服务器</td>
</tr>
<tr>
<td>消费者</td>
<td>消息接收方，用于处理数据和确认消息</td>
</tr>
<tr>
<td>代理</td>
<td>RabbitMQ本身，扮演快递角色，本身不生产消息，传输和管理消息</td>
</tr>
</tbody></table>
<h2 id="rabbitmq-有哪些重要的组件？"><a href="#rabbitmq-有哪些重要的组件？" class="headerlink" title="rabbitmq 有哪些重要的组件？"></a>rabbitmq 有哪些重要的组件？</h2><table>
<thead>
<tr>
<th>组建名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>ConnectionFactory（连接管理器）</td>
<td>应用于rabbit之间建立的连接的管理器，程序代码中使用</td>
</tr>
<tr>
<td>Channel（信道）</td>
<td>消息推送使用的通道</td>
</tr>
<tr>
<td>Exchange（交换器）</td>
<td>用于接收、分配消息</td>
</tr>
<tr>
<td>Queue（队列）</td>
<td>用于存储生产者消息</td>
</tr>
<tr>
<td>RoutingKey（路由键）</td>
<td>告诉交换器，需要放到哪个队列中，需要与bindingkey一起使用</td>
</tr>
<tr>
<td>BindingKey（绑定建）</td>
<td>用于标记交换器与队列的绑定规则，当消息的路由键与绑定建相同时，交换器会将该消息放到绑定建对应的队列中</td>
</tr>
</tbody></table>
<h2 id="rabbitmq-中-vhost-的作用是什么？"><a href="#rabbitmq-中-vhost-的作用是什么？" class="headerlink" title="rabbitmq 中 vhost 的作用是什么？"></a>rabbitmq 中 vhost 的作用是什么？</h2><p>vhost可以理解为broker，即min-RabbitMQ server，其内部含有rabbitmq的所哟组件，特点是拥有独立的权限系统，可以用于权限隔离，即一个RabbitMQ可以让多个应用以权限隔离的方式同时使用</p>
<h2 id="rabbitmq-的消息是怎么发送的？"><a href="#rabbitmq-的消息是怎么发送的？" class="headerlink" title="rabbitmq 的消息是怎么发送的？"></a>rabbitmq 的消息是怎么发送的？</h2><p>连接到RabbitMQ服务器，然后通过认证，然后通过通过信道发送消息，信道是建立在tcp真实连接上的虚拟连接</p>
<h2 id="rabbitmq-怎么保证消息的稳定性？"><a href="#rabbitmq-怎么保证消息的稳定性？" class="headerlink" title="rabbitmq 怎么保证消息的稳定性？"></a>rabbitmq 怎么保证消息的稳定性？</h2><ul>
<li>提供事务功能</li>
<li>可将channel设置为confirm模式，RabbitMQ会将消息发送情况返回给生产者</li>
</ul>
<h2 id="rabbitmq-怎么避免消息丢失？"><a href="#rabbitmq-怎么避免消息丢失？" class="headerlink" title="rabbitmq 怎么避免消息丢失？"></a>rabbitmq 怎么避免消息丢失？</h2><p>1、消息持久化<br>2、ACK确认机制<br>3、设置集群镜像模式，数据备份<br>4、消息补偿机制</p>
<h2 id="要保证消息持久化成功的条件有哪些？"><a href="#要保证消息持久化成功的条件有哪些？" class="headerlink" title="要保证消息持久化成功的条件有哪些？"></a>要保证消息持久化成功的条件有哪些？</h2><h4 id="需要满足下面四个条件才能实现消息持久化："><a href="#需要满足下面四个条件才能实现消息持久化：" class="headerlink" title="需要满足下面四个条件才能实现消息持久化："></a>需要满足下面四个条件才能实现消息持久化：</h4><p>1、声明队列的持久化属性durable为true<br>2、消息推送投递模式设置持久化，deliveryMode设置为2（持久化）<br>3、消息传输到持久化交换器，前面的流程不包含持久化逻辑<br>4、消息已到达持久化队列</p>
<h2 id="rabbitmq-持久化有什么缺点？"><a href="#rabbitmq-持久化有什么缺点？" class="headerlink" title="rabbitmq 持久化有什么缺点？"></a>rabbitmq 持久化有什么缺点？</h2><p>持久化特性会降低服务并发性能、数据吞吐量</p>
<h2 id="rabbitmq-有几种广播类型？"><a href="#rabbitmq-有几种广播类型？" class="headerlink" title="rabbitmq 有几种广播类型？"></a>rabbitmq 有几种广播类型？</h2><table>
<thead>
<tr>
<th>广播类型</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>fanout</td>
<td>不需要routingkey，只要跟exchange binding的queue都可以接收消息</td>
</tr>
<tr>
<td>direct</td>
<td>根据routingkey和exchange，只有唯一一个queue可以接收消息</td>
</tr>
<tr>
<td>topic</td>
<td>所有符合routingkey和bindingkey规则的queue都可以接收消息</td>
</tr>
</tbody></table>
<h2 id="rabbitmq-怎么实现延迟消息队列？"><a href="#rabbitmq-怎么实现延迟消息队列？" class="headerlink" title="rabbitmq 怎么实现延迟消息队列？"></a>rabbitmq 怎么实现延迟消息队列？</h2><p>1、消息过期后进入死信交换器，再由交换器转发到延迟消息队列，实现延迟功能<br>2、使用RabbitMQ-delayed-message-exchange插件实现延迟功能</p>
<h2 id="RabbitMQ集群作用或者意义"><a href="#RabbitMQ集群作用或者意义" class="headerlink" title="RabbitMQ集群作用或者意义"></a>RabbitMQ集群作用或者意义</h2><p>1、高可用：当某个服务节点出现问题，不影响整体服务可用性<br>2、高容量：集群可以承载更多消息量</p>
<h2 id="rabbitmq-集群搭建需要注意哪些问题？"><a href="#rabbitmq-集群搭建需要注意哪些问题？" class="headerlink" title="rabbitmq 集群搭建需要注意哪些问题？"></a>rabbitmq 集群搭建需要注意哪些问题？</h2><p>1、各节点之间使用“–link”连接，此属性不可忽略<br>2、各节点使用的erlang cookie值必须相同，此值相当于“秘钥”功能，用于各节点认证<br>3、整个集群中必须包含一个磁盘节点</p>
<h2 id="rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？"></a>rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h2><h4 id="不是，原因如下"><a href="#不是，原因如下" class="headerlink" title="不是，原因如下"></a>不是，原因如下</h4><p>1、存储空间考虑：每个节点增加了非常多的冗余数据<br>2、性能考虑：每个节点其实跟单节点本质上是几乎一致的，所以处理性能相比单节点没有优势，甚至更差</p>
<h2 id="rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><h4 id="集群依然可以运行，但是不能更改任何东西，本质上就是设置到写磁盘的操作都不行了"><a href="#集群依然可以运行，但是不能更改任何东西，本质上就是设置到写磁盘的操作都不行了" class="headerlink" title="集群依然可以运行，但是不能更改任何东西，本质上就是设置到写磁盘的操作都不行了"></a>集群依然可以运行，但是不能更改任何东西，本质上就是设置到写磁盘的操作都不行了</h4><ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点</li>
</ul>
<h2 id="rabbitmq-对集群节点停止顺序有要求吗？"><a href="#rabbitmq-对集群节点停止顺序有要求吗？" class="headerlink" title="rabbitmq 对集群节点停止顺序有要求吗？"></a>rabbitmq 对集群节点停止顺序有要求吗？</h2><h4 id="有"><a href="#有" class="headerlink" title="有"></a>有</h4><p>先关闭内存节点，最后关闭磁盘节点，目的是避免消息丢失</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/05/06/Q&A/Java/RabbitMQ/" data-id="cl3099frf0037qzd48e5vf6uh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/MyBatis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/27/Q&A/Java/MyBatis/" class="article-date">
  <time datetime="2022-04-27T07:25:07.000Z" itemprop="datePublished">2022-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/27/Q&A/Java/MyBatis/">MyBatis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mybatis-中-和-的区别是什么？"><a href="#mybatis-中-和-的区别是什么？" class="headerlink" title="mybatis 中 #{}和 ${}的区别是什么？"></a>mybatis 中 #{}和 ${}的区别是什么？</h2><table>
<thead>
<tr>
<th></th>
<th>#{}</th>
<th>${}</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>预处理</td>
<td>字符串替换</td>
</tr>
<tr>
<td>处理流程</td>
<td>Mybatis会先将#{}替换成？，然后调用PreparedStatement中的set方法来赋值</td>
<td>将${}替换成变量的值</td>
</tr>
<tr>
<td>特点</td>
<td>可以有效防止sql注入，提高系统安全性</td>
<td></td>
</tr>
</tbody></table>
<h2 id="mybatis-有几种分页方式？"><a href="#mybatis-有几种分页方式？" class="headerlink" title="mybatis 有几种分页方式？"></a>mybatis 有几种分页方式？</h2><p>1、数组分页<br>2、sql分页<br>3、拦截器分页<br>4、RowBounds分页</p>
<h2 id="mybatis-逻辑分页和物理分页的区别是什么？"><a href="#mybatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="mybatis 逻辑分页和物理分页的区别是什么？"></a>mybatis 逻辑分页和物理分页的区别是什么？</h2><table>
<thead>
<tr>
<th></th>
<th>逻辑分页</th>
<th>物理分页</th>
</tr>
</thead>
<tbody><tr>
<td>实现位置</td>
<td>主要靠代码来分页，从表中读取全量数据，用代码分页，依赖于代码实现</td>
<td>直接使用可以分页的sql语句完成，依赖于sql语句实现</td>
</tr>
<tr>
<td>访问数据库次数</td>
<td>访问一次即可完成分页</td>
<td>没获取一页数据都需要访问数据库</td>
</tr>
<tr>
<td>资源占用</td>
<td>内存占用大</td>
<td>数据库压力大</td>
</tr>
<tr>
<td>速度</td>
<td>不一定谁快</td>
<td></td>
</tr>
<tr>
<td>实时性</td>
<td>只读取一次，读取之后的变化无法提现</td>
<td>实时读取一页，实时性高</td>
</tr>
<tr>
<td>如何选择</td>
<td>逻辑分页速度上优势，但是物理分页在其他方面的优势更明显，建议物理分页</td>
<td></td>
</tr>
</tbody></table>
<h2 id="mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>mybatis 是否支持延迟加载？延迟加载的原理是什么？</h2><ul>
<li>仅支持association对象（查询结果中包含一对一类型，比如人员包含身份证信息这种）和collection对象（查询结果中包含一对多类型，比如人员的房子这个，一个人可能有多套房子）</li>
<li>打开方式：在配置文件中配置lazyLoadingEnabled=true|false</li>
<li>懒加载原理：在get方法中判断对象为空时，去构造</li>
</ul>
<h2 id="说一下-mybatis-的一级缓存和二级缓存？"><a href="#说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="说一下 mybatis 的一级缓存和二级缓存？"></a>说一下 mybatis 的一级缓存和二级缓存？</h2><table>
<thead>
<tr>
<th></th>
<th>一级缓存</th>
<th>二级缓存</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>基于PerpetualCache的HashMap本地缓存</td>
<td>基于PerpetualCache的HashMap实现，也可以使用外部存储资源，比如Ehcache，redis</td>
</tr>
<tr>
<td>存储作用域</td>
<td>作用域session，当session flush或者close之后，该session中的cache就会清空</td>
<td>Mapper（namSpace）</td>
</tr>
<tr>
<td>默认状态</td>
<td>默认代开</td>
<td>默认不打开</td>
</tr>
</tbody></table>
<h2 id="mybatis-和-hibernate-的区别有哪些？"><a href="#mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="mybatis 和 hibernate 的区别有哪些？"></a>mybatis 和 hibernate 的区别有哪些？</h2><table>
<thead>
<tr>
<th></th>
<th>mybatis</th>
<th>Hibernate</th>
</tr>
</thead>
<tbody><tr>
<td>相同点</td>
<td>都是ORM（对象关系映射）框架</td>
<td></td>
</tr>
<tr>
<td>是否需要开发者编写sql语句</td>
<td>需要，半自动框架</td>
<td>不需要，全自动框架</td>
</tr>
<tr>
<td>适合场景</td>
<td>直接编写原生sql，灵活度高，可以更好的控制sql执行性能，适合对关系数据库模型要求不高、需求变化频繁的软件开发</td>
<td>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，可以使用Hibernate，可以节省很多代码，提高效率</td>
</tr>
</tbody></table>
<h2 id="mybatis-有哪些执行器（Executor）？"><a href="#mybatis-有哪些执行器（Executor）？" class="headerlink" title="mybatis 有哪些执行器（Executor）？"></a>mybatis 有哪些执行器（Executor）？</h2><table>
<thead>
<tr>
<th>执行器</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>SimpleExecutor</td>
<td>每执行一次update或者select，就产生一个statement对象，用完立即销毁</td>
</tr>
<tr>
<td>ReuseExecutor</td>
<td>有一个重复使用Map，key时sql，value是可以重复使用的statement，存在就使用，不存在才会创建</td>
</tr>
<tr>
<td>BatchExecutor</td>
<td>会缓存多个statement对象，然后统一执行，批处理不支持select，原因是JDBC不支持批处理select</td>
</tr>
</tbody></table>
<h2 id="mybatis-分页插件的实现原理是什么"><a href="#mybatis-分页插件的实现原理是什么" class="headerlink" title="mybatis 分页插件的实现原理是什么"></a>mybatis 分页插件的实现原理是什么</h2><ul>
<li>简介：使用mybatis提供的插件接口，通过自定义插件实现分页</li>
<li>具体流程：在插件的拦截方法内拦截sql，对sql进行修改，根据dialect添加对应的物理分页参数和物理分页语句</li>
</ul>
<h2 id="mybatis-如何编写一个自定义插件？"><a href="#mybatis-如何编写一个自定义插件？" class="headerlink" title="mybatis 如何编写一个自定义插件？"></a>mybatis 如何编写一个自定义插件？</h2><h3 id="自定义原理"><a href="#自定义原理" class="headerlink" title="自定义原理"></a>自定义原理</h3><p>通过对mybatis的四大对象拦截来实现</p>
<h3 id="Mybatis的四大对象介绍"><a href="#Mybatis的四大对象介绍" class="headerlink" title="Mybatis的四大对象介绍"></a>Mybatis的四大对象介绍</h3><table>
<thead>
<tr>
<th>对象名称</th>
<th>流程</th>
</tr>
</thead>
<tbody><tr>
<td>Executor</td>
<td>执行器，主要是log记录</td>
</tr>
<tr>
<td>StatementHandler</td>
<td>sql语法构建</td>
</tr>
<tr>
<td>ParameterHandler</td>
<td>参数处理</td>
</tr>
<tr>
<td>ResultSetHandler</td>
<td>结果集处理</td>
</tr>
</tbody></table>
<h3 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h3><h4 id="需要实现Mybatis的Interceptor接口"><a href="#需要实现Mybatis的Interceptor接口" class="headerlink" title="需要实现Mybatis的Interceptor接口"></a>需要实现Mybatis的Interceptor接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">    Object intercept(Invocation invocation) throws Throwable; // 拦截器具体处理逻辑方法</span><br><span class="line">    Object plugin(Object target); // 根据签名signatureMap生成动态代理对象</span><br><span class="line">    void setProperties(Properties properties); // 设置Properties属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一个-Interceptor可以配置多个-Signature，-Signature内部参数含义如下："><a href="#一个-Interceptor可以配置多个-Signature，-Signature内部参数含义如下：" class="headerlink" title="一个@Interceptor可以配置多个@Signature，@Signature内部参数含义如下："></a>一个@Interceptor可以配置多个@Signature，@Signature内部参数含义如下：</h4><table>
<thead>
<tr>
<th>参数名称</th>
<th>参数作用</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>表示拦截类，是Executor还是其他三个</td>
</tr>
<tr>
<td>method</td>
<td>表示拦截方法</td>
</tr>
<tr>
<td>args</td>
<td>表示方法参数</td>
</tr>
</tbody></table>
<h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;@Signature(</span><br><span class="line">  type= Executor.class,</span><br><span class="line">  method = &quot;update&quot;,</span><br><span class="line">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line">public class ExamplePlugin implements Interceptor &#123;</span><br><span class="line">  public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">  Object target = invocation.getTarget(); //被代理对象</span><br><span class="line">  Method method = invocation.getMethod(); //代理方法</span><br><span class="line">  Object[] args = invocation.getArgs(); //方法参数</span><br><span class="line">  // do something ...... 方法拦截前执行代码块</span><br><span class="line">  Object result = invocation.proceed();</span><br><span class="line">  // do something .......方法拦截后执行代码块</span><br><span class="line">  return result;</span><br><span class="line">  &#125;</span><br><span class="line">  public Object plugin(Object target) &#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">  &#125;</span><br><span class="line">  public void setProperties(Properties properties) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/04/27/Q&A/Java/MyBatis/" data-id="cl3099frf003aqzd45g52ew5z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/Hibernate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/24/Q&A/Java/Hibernate/" class="article-date">
  <time datetime="2022-04-24T09:53:12.000Z" itemprop="datePublished">2022-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/24/Q&A/Java/Hibernate/">Hibernate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要使用-hibernate？使用Hibernate的优势"><a href="#为什么要使用-hibernate？使用Hibernate的优势" class="headerlink" title="为什么要使用 hibernate？使用Hibernate的优势"></a>为什么要使用 hibernate？使用Hibernate的优势</h2><p>1、对JDBC访问数据代码做了封装，大大简化了数据库访问层的重复性代码；<br>2、Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，很大程度上简化了DAO层的编码工作；<br>3、Hibernate基于Java的反射机制，而不是字节码增强称必须来实现透明性；<br>4、Hiroshima性能非常好，因为他是个轻量级框架，映射灵活性出色，支持各种关系数据库，支持一对一到一对多的复杂关系</p>
<h2 id="什么是-ORM-框架？"><a href="#什么是-ORM-框架？" class="headerlink" title="什么是 ORM 框架？"></a>什么是 ORM 框架？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ORM（Object Relation Mapper）即对象关系映射，是为了解决面向对象与关系型数据库存在的互不匹配的技术框架，它通过描述java对象与数据库表之间的关系，自动将java应用中的对象持久化到关系型数据库中，在java对象与数据库表之间建立一座桥梁，这个桥梁就是映射关系</p>
<h3 id="主流ORM框架"><a href="#主流ORM框架" class="headerlink" title="主流ORM框架"></a>主流ORM框架</h3><table>
<thead>
<tr>
<th>框架名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>MyBatis</td>
<td>一个半自动映射框架，互联网目前比较流行</td>
</tr>
<tr>
<td>Hibernate</td>
<td>全自动映射框架</td>
</tr>
</tbody></table>
<h2 id="hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="hibernate 中如何在控制台查看打印的 sql 语句？"></a>hibernate 中如何在控制台查看打印的 sql 语句？</h2><ul>
<li>方式1（在properties中添加配置项）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.show_sql=true // 控制台是否打印</span><br><span class="line">spring.jpa.properties.hibernate.format_sql=true // 格式化sql语句</span><br><span class="line">spring.jps.properties.hibernate.use_sql_comments=true // 指出是什么操作生成了该语句</span><br></pre></td></tr></table></figure></li>
<li>方式2（在yml文件中修改配置项）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  jpa:</span><br><span class="line">    properties:</span><br><span class="line">      format_sql: true // 格式化sql语句</span><br><span class="line">      show_sql: true // 控制台是否打印</span><br><span class="line">      use_sql_comments: true // 指出是什么操作生成了该语句</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="hibernate-有几种查询方式？"><a href="#hibernate-有几种查询方式？" class="headerlink" title="hibernate 有几种查询方式？"></a>hibernate 有几种查询方式？</h2><table>
<thead>
<tr>
<th>查询方式</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>HQL</td>
<td>Hibernate Query language，Hibernate官方推荐查询方式，语法结构上与sql类似，使用Hibernate中的Query对象执行HQl操作</td>
</tr>
<tr>
<td>QBC</td>
<td>Query By Criteria，Criteria对象提供了一种面向对象式的查询方式，Criteria需要使用sessio对象获得</td>
</tr>
<tr>
<td>SQL</td>
<td>即原生SQL语句方式查询</td>
</tr>
</tbody></table>
<h2 id="hibernate-实体类可以被定义为-final-吗？"><a href="#hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="hibernate 实体类可以被定义为 final 吗？"></a>hibernate 实体类可以被定义为 final 吗？</h2><ul>
<li>可以声明为final类</li>
<li>缺点：java不允许在final类中使用代理，所以Hibernate使用代理模式在延迟关联情况下提高性能的手段就会失效，所以该做法不建议采用</li>
<li>补救方式：将所有public方法在一个接口中声明，并让该final类实现该接口</li>
</ul>
<h2 id="在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><ul>
<li>使用Integer的情况下，Hibernate可以根据Integer是否为null而判断是否是临时对象</li>
<li>使用int，需要在hbm映射文件中声明unsaved-value=0</li>
</ul>
<h2 id="hibernate-是如何工作的？"><a href="#hibernate-是如何工作的？" class="headerlink" title="hibernate 是如何工作的？"></a>hibernate 是如何工作的？</h2><p>1、读取并解析配置文件<br>2、读取并解析映射信息<br>3、创建SessionFactory<br>4、打开session<br>5、创建并启动事务Transation<br>6、操作数据，进行持久化操作<br>7、提交事务<br>8、关闭session<br>9、关闭sessionFactory</p>
<h2 id="get-和-load-的区别？"><a href="#get-和-load-的区别？" class="headerlink" title="get()和 load()的区别？"></a>get()和 load()的区别？</h2><ul>
<li>get：生成sql，立即加载，有直接返回对象，没有返回null</li>
<li>load：不生成sql，延迟加载，会有个代理返回一个id，如果直接使用对象的具体属性的时候，会返回对象不存在的异常</li>
</ul>
<h2 id="说一下-hibernate-的缓存机制？"><a href="#说一下-hibernate-的缓存机制？" class="headerlink" title="说一下 hibernate 的缓存机制？"></a>说一下 hibernate 的缓存机制？</h2><h3 id="Hibernate分为一级缓存和二级缓存"><a href="#Hibernate分为一级缓存和二级缓存" class="headerlink" title="Hibernate分为一级缓存和二级缓存"></a>Hibernate分为一级缓存和二级缓存</h3><table>
<thead>
<tr>
<th></th>
<th>一级缓存</th>
<th>二级缓存</th>
</tr>
</thead>
<tbody><tr>
<td>有效范围</td>
<td>事务范围内</td>
<td>从应用启动到结束</td>
</tr>
<tr>
<td>级别</td>
<td>session级别</td>
<td>sessionFactory级别</td>
</tr>
<tr>
<td>开启关闭</td>
<td>内置，无法卸载或关闭</td>
<td>可选，手动开启，默认不开启</td>
</tr>
</tbody></table>
<h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h3><ul>
<li>缓存在内存中保存了一份，更新完数据库后要同步更新</li>
<li>Hibernate的二级缓存时不支持分布式缓存的，需要使用cache、redis等中央缓存来替代</li>
</ul>
<h3 id="适合放到二级缓存中的数据"><a href="#适合放到二级缓存中的数据" class="headerlink" title="适合放到二级缓存中的数据"></a>适合放到二级缓存中的数据</h3><ul>
<li>很少被修改的数据</li>
<li>经常被查询的数据</li>
<li>不是很重要的数据</li>
<li>不会被并发访问的数据</li>
<li>常量数据</li>
</ul>
<h2 id="hibernate-对象有哪些状态？"><a href="#hibernate-对象有哪些状态？" class="headerlink" title="hibernate 对象有哪些状态？"></a>hibernate 对象有哪些状态？</h2><table>
<thead>
<tr>
<th></th>
<th>Transient（瞬时）</th>
<th>Persistent（持久）</th>
<th>Detached（托管）</th>
</tr>
</thead>
<tbody><tr>
<td>产生状态</td>
<td>对象刚new出来，还没id，设了其他值</td>
<td>调用了save、saveOrUpdate，有id</td>
<td>当session close之后</td>
</tr>
</tbody></table>
<h2 id="在Hibernate中getCurrentSession和openSession的区别是什么"><a href="#在Hibernate中getCurrentSession和openSession的区别是什么" class="headerlink" title="在Hibernate中getCurrentSession和openSession的区别是什么"></a>在Hibernate中getCurrentSession和openSession的区别是什么</h2><table>
<thead>
<tr>
<th></th>
<th>getCurrentSession</th>
<th>openSession</th>
</tr>
</thead>
<tbody><tr>
<td>获取session是否是同一个</td>
<td>是</td>
<td>不是</td>
</tr>
<tr>
<td>特点</td>
<td>没有会创建</td>
<td>每次都会新建，使用完需要执行close操作</td>
</tr>
</tbody></table>
<h2 id="Hibernate实体类必须有无参构造函数吗？为什么"><a href="#Hibernate实体类必须有无参构造函数吗？为什么" class="headerlink" title="Hibernate实体类必须有无参构造函数吗？为什么"></a>Hibernate实体类必须有无参构造函数吗？为什么</h2><ul>
<li>必须，Hibernate框架会调用无参构造函数创建实例对象</li>
<li>如果不提供任何构造函数，虚拟机会自动提供无参构造函数，如果提供了有参构造函数，此时必须手动提供无参构造函数，否则会报错</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/04/24/Q&A/Java/Hibernate/" data-id="cl3099fra002pqzd45x2cgj0h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/Spring" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/18/Q&A/Java/Spring/" class="article-date">
  <time datetime="2022-04-18T11:31:33.000Z" itemprop="datePublished">2022-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/18/Q&A/Java/Spring/">Spring</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要使用-spring？"><a href="#为什么要使用-spring？" class="headerlink" title="为什么要使用 spring？"></a>为什么要使用 spring？</h2><h3 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h3><ul>
<li>省去很多非业务层代码的研发工作，提高javaweb应用开发效率<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3></li>
<li>基于POJO的轻量级和最小侵入式编程；POJO（Plain Ordinary Java Object）即简单Java对象，spring竭力避免污染你的代码，尽量解除我们的代码与spring之间的耦合。具备非侵入式变成的思想，耦合低，代码污染小</li>
<li>通过依赖注入和面向接口编程实现松耦合：降低模块内部不同类之间的依赖，当在某一个类当中使用其他类时，通过spring来管理对象的创建于销毁，spring提供了一种组建内部不同类低耦合协作的一种方式</li>
<li>基于切面和管理进行声明式编程：对于日志管理等通用模块，采用面向切面的方式，使其他模块在编程时完全不需要了解这些部分的相关逻辑与代码</li>
<li>通过切面和模板减少样板式代码：面向切面编程消除了大量的重复代码，比如调用初始化等等</li>
</ul>
<h2 id="解释一下什么是-aop？"><a href="#解释一下什么是-aop？" class="headerlink" title="解释一下什么是 aop？"></a>解释一下什么是 aop？</h2><ul>
<li>AOP（Accept Oriented Programming）即面向切面编程，把编程看成是多个切面的实现，比如安全检查、日志打印、实际业务处理等，通过对方法进行拦截，按照需要的顺序，放入不同的切面代码</li>
<li>OOP（Object Oriented Programming）即面向对象编程，把编程看成是多个对象之间的交互，主要功能是继承、封装、多态</li>
<li>Java实现AOP的方式：<ul>
<li>编译器：编译器把切面代码编译进字节码</li>
<li>类加载器：在目标类被装在到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”</li>
<li>运行期：基于JVM的动态代理实现，Spring就是使用该方式实现的切面编程</li>
</ul>
</li>
</ul>
<h2 id="解释一下什么是-ioc？"><a href="#解释一下什么是-ioc？" class="headerlink" title="解释一下什么是 ioc？"></a>解释一下什么是 ioc？</h2><ul>
<li>IOC（Inversion of Control）即控制反转，又称DI（Dependency Injection）即依赖注入，目的是将组件的创建&amp;配置与组建的使用分离，spring当中使用极为广泛</li>
</ul>
<h2 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h2><h3 id="什么是Spring-bean"><a href="#什么是Spring-bean" class="headerlink" title="什么是Spring bean"></a>什么是Spring bean</h3><ul>
<li>bean时spring程序构成的基础之一，是被spring实例化、组装并由spring管理的java对象</li>
<li>默认情况下，spring中的bean都是以单利形式存在的</li>
</ul>
<h3 id="spring中的主要模块"><a href="#spring中的主要模块" class="headerlink" title="spring中的主要模块"></a>spring中的主要模块</h3><table>
<thead>
<tr>
<th>模块名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Core</td>
<td>框架基础部分，提供IOC功能实现和bean的创建、配置</td>
</tr>
<tr>
<td>Spring AOP</td>
<td>提供面向切面功能</td>
</tr>
<tr>
<td>Spring Context</td>
<td>是一个配置文件，向Spring框架提供上下文信息；<br />提供各种企业服务，比如JNDI、电子邮件、国际化、校验、调度等功能；<br />提供框架式bean访问方式，其他程序可以通过Context访问Spring的bean资源</td>
</tr>
<tr>
<td>Spring DAO</td>
<td>提供数据库相关的各种功能，对JDBC进行二次封装</td>
</tr>
<tr>
<td>Spring ORM（Object Relation Mapper）</td>
<td>Spring对多个ORM框架进行了封装，达成一致的编程风格，方便维护</td>
</tr>
<tr>
<td>Spring Web</td>
<td>Web层使用的Web框架式可选的，可以使用Spring的MVC，也可以使用Struts、Servlet等，该模块主要作用是管理web框架，方便使用web框架</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>Spring提供的一个MVC方式实现的web应用服务器</td>
</tr>
</tbody></table>
<h2 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h2><h3 id="相关名词解释"><a href="#相关名词解释" class="headerlink" title="相关名词解释"></a>相关名词解释</h3><ul>
<li>DI（Dependency Injection）即依赖注入：当Spring创建被调用者的实例时，会自动将其注入调用者的实例中，这个就是依赖注入</li>
<li>IOC（Inversion of Control）即控制反转：当一个java实例需要调用另一个java实例，且使用Spring框架的情况下，被调用者不再需要调用者来创建和配置，而是由Spring来完成，这就是控制反转<h3 id="三种依赖注入方式"><a href="#三种依赖注入方式" class="headerlink" title="三种依赖注入方式"></a>三种依赖注入方式</h3></li>
<li>setter注入：Spring会自行实现一个set+首字母大写+变变量名的方法，然后用反射调用该方法实现依赖注入</li>
<li>构造方法注入：通过在配置文件中标记好依赖关系，然后通过调用构造方法进行依赖注入</li>
<li>注解注入：Autowire，内部由三个constructor、byName、byType组成</li>
</ul>
<h2 id="spring-中的-bean-是线程安全的吗？"><a href="#spring-中的-bean-是线程安全的吗？" class="headerlink" title="spring 中的 bean 是线程安全的吗？"></a>spring 中的 bean 是线程安全的吗？</h2><ul>
<li>结论：不安全</li>
</ul>
<h2 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h2><ul>
<li>singleton：单例，默认作用域，有线程安全问题，不过spring中大多是无状态单例bean，也是线程安全的，对于有状态的，可以使用ThreadLcal来解决线程安全问题</li>
<li>prototype：原型，每次创建一个对象，线程之间没有共享，所以安全</li>
<li>request: 请求，每次http请求一个对象，参考单例bean</li>
<li>session：会话，每一个会话共享一个实例，不同会话使用不同实例，参考单例bean</li>
<li>global-session：全局会话，所有会话共享一个实例，参考单例bean</li>
</ul>
<h2 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h2><h3 id="自动装备定义"><a href="#自动装备定义" class="headerlink" title="自动装备定义"></a>自动装备定义</h3><ul>
<li>Spring IOC容易将创建和配置好的bean赋值到需要调用这些bean的调用者</li>
</ul>
<h3 id="自动装备方式"><a href="#自动装备方式" class="headerlink" title="自动装备方式"></a>自动装备方式</h3><ul>
<li>default：默认方式，与no相同</li>
<li>no：不自动装配，会根据ref参数完成装配</li>
<li>byName：根据名称进行装配</li>
<li>byType：根据类型进行装配</li>
<li>constructor：根据构造函数进行装配</li>
</ul>
<h2 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul>
<li>事务即一组需要执行的操作，这些操作作为一个整体，要么全都成功，要么全都失败</li>
<li>特性：原子性（Atomiciy）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），简称ACID</li>
</ul>
<h3 id="Spring事务实现方式"><a href="#Spring事务实现方式" class="headerlink" title="Spring事务实现方式"></a>Spring事务实现方式</h3><ul>
<li>声明式事务：<ul>
<li>基于XML配置文件的方式</li>
<li>基于注解（@Transaction）的方式</li>
</ul>
</li>
<li>手动编码实现事务</li>
</ul>
<h2 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h2><h3 id="事务隔离特性"><a href="#事务隔离特性" class="headerlink" title="事务隔离特性"></a>事务隔离特性</h3><table>
<thead>
<tr>
<th>特性</th>
<th>特性描述</th>
</tr>
</thead>
<tbody><tr>
<td>原子性</td>
<td>强调事务的不可分割</td>
</tr>
<tr>
<td>一致性</td>
<td>事务执行前后数据的完整性保持一致</td>
</tr>
<tr>
<td>隔离性</td>
<td>一个事务的执行不应受到其他事务的影响</td>
</tr>
<tr>
<td>持久性</td>
<td>事务执行结束，数据就持久化到数据库里</td>
</tr>
</tbody></table>
<h3 id="事务隔离为了解决的问题"><a href="#事务隔离为了解决的问题" class="headerlink" title="事务隔离为了解决的问题"></a>事务隔离为了解决的问题</h3><table>
<thead>
<tr>
<th>要解决的问题</th>
<th>问题描述</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>表示一个事务能读取到另一个未提交的事务中的数据</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务由于另一个事务insert数据造成多次查询数据不一致</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务由于另一个事务update导致多次查到的记录不一致</td>
</tr>
</tbody></table>
<h3 id="spring事务隔离级别"><a href="#spring事务隔离级别" class="headerlink" title="spring事务隔离级别"></a>spring事务隔离级别</h3><table>
<thead>
<tr>
<th>级别</th>
<th>级别描述</th>
<th>能否避免脏读</th>
<th>能否避免幻读</th>
<th>能否避免不可重复读</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT，默认</td>
<td>使用数据默认的隔离级别，mysql默认可重复读，oracle默认已提交读</td>
<td>mysql能，oracle能</td>
<td>mysql否，oracle否</td>
<td>mysql能，oracle否</td>
</tr>
<tr>
<td>READ UNCOMMITED 即未提交读</td>
<td>三种问题都有可能发生</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>READ COMMITED， 即已提交读</td>
<td>能避免脏读，但是不可重复读和幻读依然有可能发生</td>
<td>能</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>REPEATABLE READ， 即可重复读</td>
<td>可以避免脏读和不可重复读，但是幻读依然可以发生</td>
<td>能</td>
<td>否</td>
<td>能</td>
</tr>
<tr>
<td>SERIALIZABLE, 即串行化</td>
<td>避免所有问题</td>
<td>能</td>
<td>能</td>
<td>能</td>
</tr>
</tbody></table>
<h2 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h2><h3 id="核心部分："><a href="#核心部分：" class="headerlink" title="核心部分："></a>核心部分：</h3><table>
<thead>
<tr>
<th>组成部分</th>
<th>作用</th>
<th>对应类</th>
</tr>
</thead>
<tbody><tr>
<td>Model</td>
<td>业务模型：处理业务请求</td>
<td>Handler</td>
</tr>
<tr>
<td>View</td>
<td>视图：渲染视图</td>
<td>实现类、jsp等</td>
</tr>
<tr>
<td>Controller</td>
<td>前段控制器：接收请求，响应结果</td>
<td>DispatcherServlet</td>
</tr>
</tbody></table>
<h3 id="三大组件："><a href="#三大组件：" class="headerlink" title="三大组件："></a>三大组件：</h3><table>
<thead>
<tr>
<th>组件名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HandlerMapping（处理器映射器）</td>
<td>将URL和处理器进行映射，可以根据URL找到对应的处理器</td>
</tr>
<tr>
<td>HandlerAdapter（处理器适配器）</td>
<td>适配并执行响应的处理器</td>
</tr>
<tr>
<td>ViewResolver（视图解析器）</td>
<td>根据视图名称，解析成一个视图对象</td>
</tr>
</tbody></table>
<h2 id="说一下-spring-mvc-运行流程？"><a href="#说一下-spring-mvc-运行流程？" class="headerlink" title="说一下 spring mvc 运行流程？"></a>说一下 spring mvc 运行流程？</h2><ul>
<li>前端发出请求，DispatcherServlet收到请求</li>
<li>DispatcherServlet向HandlerMapping请求，获取到HandlerExecutionChan，该对象存储着处理器信息</li>
<li>DispatcherServlet使用HandlerExecutionChan向HandlerAdapter请求，让其适配处理器并让处理器完成请求处理</li>
<li>HandlerAdapter适配处理器，并告诉Handler完成请求处理</li>
<li>Handler处理完成后，返回ModelAndView给HandlerAdapter，然后返回给DispatcherServlet</li>
<li>DispatcherServlet使用ModelAndView向ViewResolve请求解析视图，ViewResolve返回视图对象</li>
<li>DispatcherServlet使用视图对象向View请求其完成渲染，View将渲染好的视图返回给DispatcherServlet</li>
<li>DispatcherServlet将响应返回给前端</li>
</ul>
<h2 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>作用：用来处理请求的映射</li>
<li>修饰对象：类、方法</li>
<li>特点：在类上使用时，表示所配置内容为该类中所有接口的父路径</li>
</ul>
<h3 id="包含属性"><a href="#包含属性" class="headerlink" title="包含属性"></a>包含属性</h3><ul>
<li>value：指定请求地址</li>
<li>method：指定请求类型，post或者get等</li>
<li>consumes：指定请求内容处理类型（Content-Type）</li>
<li>produces：指定返回的内容类型，请求方指定返回数据类型，返回数据类型与此项配置值相同时，参会返回成功</li>
<li>params：指定请求地址中包含的参数</li>
<li>headers：指定request中必须包含某些指定的header值，才允许请求</li>
</ul>
<h2 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h2><ul>
<li>作用：完成IOC或者ID的自动装配流程</li>
<li>修饰对象：类成员变量、方法、构造函数</li>
</ul>
<h1 id="Soring-boot"><a href="#Soring-boot" class="headerlink" title="Soring boot"></a>Soring boot</h1><h2 id="什么是spring-boot？"><a href="#什么是spring-boot？" class="headerlink" title="什么是spring boot？"></a>什么是spring boot？</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>是什么</td>
<td>一个框架</td>
</tr>
<tr>
<td>诞生目的</td>
<td>简化新spring应用的搭建以及开发过程</td>
</tr>
<tr>
<td>特点</td>
<td>使用了特定方式配置，使开发人员不再需要定义样板化的配置</td>
</tr>
</tbody></table>
<h2 id="为什么要用-spring-boot？或者说使用spring-boot的优势"><a href="#为什么要用-spring-boot？或者说使用spring-boot的优势" class="headerlink" title="为什么要用 spring boot？或者说使用spring boot的优势"></a>为什么要用 spring boot？或者说使用spring boot的优势</h2><ul>
<li>简化配置，不需要太多的xml配置文件</li>
<li>基于spring进行构建，是开发者快速入门，门槛低</li>
<li>spring boot可以独立创建应用，不需要依赖各种web应用容器</li>
<li>内置tomcat，不需要打成jar包，可以直接在tomcat中运行</li>
<li>提供maven极简配置，以及可视化的各种监控功能</li>
<li>为微服务spring cloud提供了基础，是微服务构建变得很简单</li>
<li>spring boot可以整合各种各样的框架，并可以很好地集成</li>
<li>活跃的社区论坛，以及丰富的开发文档</li>
</ul>
<h2 id="spring-boot-核心配置文件是什么？"><a href="#spring-boot-核心配置文件是什么？" class="headerlink" title="spring boot 核心配置文件是什么？"></a>spring boot 核心配置文件是什么？</h2><ul>
<li>application.yml</li>
<li>bootstrap.properties</li>
</ul>
<h2 id="spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="spring boot 配置文件有哪几种类型？它们有什么区别？"></a>spring boot 配置文件有哪几种类型？它们有什么区别？</h2><table>
<thead>
<tr>
<th></th>
<th>application.yml</th>
<th>bootstrap.properties</th>
</tr>
</thead>
<tbody><tr>
<td>加载方式</td>
<td>spring boot自动从classpath中加载</td>
<td>spring boot会自动从classspath中加载</td>
</tr>
<tr>
<td>文件内容格式</td>
<td>key：value</td>
<td>key=value</td>
</tr>
<tr>
<td>加载顺序</td>
<td>整体文件加载后于bootstrap，内部配置项加载也有先后顺序</td>
<td>先于application</td>
</tr>
<tr>
<td>可配置项功能</td>
<td>应用级别，是当前应用的配置文件</td>
<td>系统级别，用来加载外部配置，比如配置中心的配置信息</td>
</tr>
</tbody></table>
<h2 id="spring-boot-有哪些方式可以实现热部署？"><a href="#spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="spring boot 有哪些方式可以实现热部署？"></a>spring boot 有哪些方式可以实现热部署？</h2><ul>
<li>模板热部署</li>
<li>使用调试模式debug实现热部署</li>
<li>spring-boot-devtools</li>
<li>spring loaded</li>
<li>JRebel<table>
<thead>
<tr>
<th>热部署方式</th>
<th>部署方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>模板热部署</td>
<td>在application或者bootstrap中关闭模板引擎的缓存即可</td>
<td></td>
</tr>
<tr>
<td>debug模式</td>
<td>运行时使用debug模式即可</td>
<td>1、最简单快速；<br/>2、无法对配置文件、方法名称改变、在增加类及方法进行热部署，使用范围有限</td>
</tr>
<tr>
<td>spring-boot-devtools</td>
<td>在spring boot中添加依赖即可实现，在pom.xml添加spring-boot-devtools依赖</td>
<td>1、作用范围广；<br/>2、使用重启策略实现，相当于手动帮你点了手动重启；<br/>3、默认关闭模板缓存</td>
</tr>
<tr>
<td>Spring Loaded</td>
<td>在run configuration中配置</td>
<td>1、与debug类似，作用范围有限；<br/>2、不依赖debug模式，正常情况下即可生效</td>
</tr>
<tr>
<td>JRebel</td>
<td>通过插件安装支持</td>
<td>1、收费；<br/>2、最好的java热部署工具</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="jpa-和-hibernate-有什么区别？"><a href="#jpa-和-hibernate-有什么区别？" class="headerlink" title="jpa 和 hibernate 有什么区别？"></a>jpa 和 hibernate 有什么区别？</h2><table>
<thead>
<tr>
<th></th>
<th>JPA</th>
<th>Hibernate</th>
<th>Spring Data Jpa</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>全称Java Persistence API，是一套ORM（对象关系映射）规范，可以理解为是一套接口</td>
<td>是JPA的一种实现</td>
<td>是对JPA和Hibernate进行了二次封装，将Spring与JPA进行更好的结合</td>
</tr>
</tbody></table>
<h1 id="Spring-cloud"><a href="#Spring-cloud" class="headerlink" title="Spring cloud"></a>Spring cloud</h1><h2 id="什么是-spring-cloud？"><a href="#什么是-spring-cloud？" class="headerlink" title="什么是 spring cloud？"></a>什么是 spring cloud？</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>一系列框架的有序集合，提供了分布式系统开发的一站式解决方案</td>
</tr>
<tr>
<td>诞生目的</td>
<td>为开发者提供一套简单易懂、易部署、易维护的分布式系统开发工具包</td>
</tr>
<tr>
<td>特点</td>
<td>1、基于spring boot；<br/>2、没有重复造轮子，将各家成熟的、经得住考验的各种框架结合</td>
</tr>
</tbody></table>
<h2 id="spring-cloud-断路器的作用是什么？"><a href="#spring-cloud-断路器的作用是什么？" class="headerlink" title="spring cloud 断路器的作用是什么？"></a>spring cloud 断路器的作用是什么？</h2><ul>
<li>当某个服务单元发生故障后，通过断路器的监控，向调用方返回一个错误响应，而不是长时间的等待，避免线程因服务故障长时间占用资源不释放，避免故障蔓延</li>
</ul>
<h2 id="spring-cloud-的核心组件有哪些？"><a href="#spring-cloud-的核心组件有哪些？" class="headerlink" title="spring cloud 的核心组件有哪些？"></a>spring cloud 的核心组件有哪些？</h2><table>
<thead>
<tr>
<th>组件</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>微服务注册管理中心</td>
</tr>
<tr>
<td>Ribbon</td>
<td>客户端负载均衡</td>
</tr>
<tr>
<td>Hystrix</td>
<td>断路器，用来处理服务故障</td>
</tr>
<tr>
<td>Fegin</td>
<td>用于简化微服务之间的调用</td>
</tr>
<tr>
<td>Zuul</td>
<td>网关，一系列的过滤器</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/04/18/Q&A/Java/Spring/" data-id="cl3099fre0033qzd40r5qd2d1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/14/Q&A/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-04-14T08:46:21.000Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/14/Q&A/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="说一下你熟悉的设计模式？"><a href="#说一下你熟悉的设计模式？" class="headerlink" title="说一下你熟悉的设计模式？"></a>说一下你熟悉的设计模式？</h2><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/java">参考文章</a></li>
</ul>
<h3 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简介</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>抽象工厂模式</td>
<td>创建一系列对象时，无需指定具体类，工厂方法模式的改良</td>
<td>同一工厂生产的产品互相匹配；避免与某一具体产品的耦合；符合单一职责原则，代码易于维护；符合开闭原则，增加新产品变体时无需修改代码</td>
<td>需要编写的类较多，代码复杂度较高</td>
<td>同一类对象，但是表现不同时，比如同一个button，在不同系统上不一样</td>
</tr>
<tr>
<td>生成器模式</td>
<td>能够分步骤创建对象，该模式允许使用相同代码创建不同类型和形式的对象，是工厂方法模式的改良</td>
<td>可以分布创建对象，可以暂缓创建或者递归创建；生成不同对象也可以复用部分创建代码；符合单一职责原则，可以从业务逻辑中抽离创建部分</td>
<td>需要创建多个类，代码复杂度提升</td>
<td>适合构造具有众多参数的复杂对象，避免构造函数重叠</td>
</tr>
<tr>
<td>工厂方法模式</td>
<td>父类中提供创建对象方法，子类决定实例化对象类型</td>
<td>降低耦合；单一职责原则，只负责创建；开闭原则，拓展新产品容易</td>
<td>代码复杂度提高</td>
<td>无法预知对象具体类型及其依赖关系时；给他人提供拓展能力；复用现有对象节省资源</td>
</tr>
<tr>
<td>原型模式</td>
<td>复制已有对象，而无需使代码依赖他们所属的类</td>
<td>耦合度低；可以克隆预生成模型，避免反复初始化；更方便生成复杂对象；可以处理复杂对象的不同配置</td>
<td>如果有循环引用的话，会比较麻烦</td>
<td>复制对象，但代码独立于被复制对象所属类；提供一堆原型，方便其他逻辑进行克隆时</td>
</tr>
<tr>
<td>单例模式</td>
<td>一个类只有一个实例</td>
<td>一个类只有一个实例：全局访问方便；仅初始化创建一次</td>
<td>违反了单一职责原则；可能会导致不同部分耦合度较大；多线程环境容易出现问题</td>
<td>某个类只需要一个可用实例即可；控制全局变量</td>
</tr>
</tbody></table>
<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简介</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>适配器模式</td>
<td>使接口不兼容的对象能够互相协作，实现方式就是在中间做一层转化</td>
<td>单一职责原则，中间层与其他部分没有耦合；开闭原则，不影响其他适配器、两头的逻辑</td>
<td>代码复杂度增加</td>
<td>接口不兼容时</td>
</tr>
<tr>
<td>桥接模式</td>
<td>将一个大类或一系列紧密相关的类拆分成抽象和实现两个层次，从而实现分别使用</td>
<td>开闭原则，新增部分对原有没有影响；单一职责原则，抽象部分负责定义功能，实现部分负责功能实现</td>
<td>不适合高内聚的类，使用该模式会使其更加复杂</td>
<td>拆分功能复杂的类；拓展类功能；运行时切换不同实现方法</td>
</tr>
<tr>
<td>组合模式</td>
<td>使用该模式可以将对象组合成树状结构，该方式就是定义一个功能接口，然后希望具备这些功能的就实现一下</td>
<td>利用多态和递归可以方便的使用复杂树结构；开闭原则，无需更改已有代码</td>
<td>对于功能差异较大额类，实现某些接口难度较高</td>
<td>希望不同类型的类，有相同功能</td>
</tr>
<tr>
<td>装饰模式</td>
<td>允许通过将对象放入包含行为的特殊封装对象中来为原始对象提供新功能，由接口、原始类、装饰基类、装饰实现类</td>
<td>无需创建子类即可扩充功能；可以在运行时添加删除对象功能；单一职责原则，每个装饰类可以只实现一小部分功能</td>
<td>代码复杂度提升</td>
<td>无需修改某个类即可为其增加功能；替代继承方式给对象增加功能</td>
</tr>
<tr>
<td>外观模式</td>
<td>能为复杂模块提供简单接口</td>
<td>让自己的代码独立于复杂子系统</td>
<td>耦合度提高</td>
<td>需要使用复杂模块的一个简单功能；需要将子系统组织成多层结构</td>
</tr>
<tr>
<td>享元模式</td>
<td>共享多个对象的所共有的相同状态，让内存中可以载入更多对象，即众多对象引用了众多相同对象</td>
<td>节约内存</td>
<td>代码复杂度高</td>
<td>程序需要大量对象且内存吃紧</td>
</tr>
<tr>
<td>代理模式</td>
<td>提供对象的替代品，通过代理对对象进行控制访问处理</td>
<td>开闭原则，原始代码无需修改；原始代码运行无影响</td>
<td>代码复杂度提升</td>
<td>虚拟代理、保护代理、远程代理、日志代理、缓存代理等</td>
</tr>
</tbody></table>
<h4 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h4><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简介</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>责任链模式</td>
<td>允许将请求沿着处理者链进行发送，每个处理者都可以处理或者发送给下一个处理者</td>
<td>可以控制处理顺序； <br />单一这则原则，每个处理者的工作内容可以隔离以解耦；<br />开闭原则，新的处理者不影响已有处理者</td>
<td>部分请求可能未被处理</td>
<td>程序需要使用不同方式处理不同类型的请求，并且不知道这些请求的顺序时；<br />当一个事务需要多个处理者时；所需处理者和顺序在运行时会改变时</td>
</tr>
<tr>
<td>迭代器模式</td>
<td>能够在不知道集合底层数据结构（列表、栈、树）的情况下，对集合进行遍历</td>
<td>单一职责原则，迭代类与其他业务代码没有没有耦合；<br />开闭原则，新增集合和迭代器时，不需要更改已有代码；<br />可以方便的控制遍历状态</td>
<td>不适合简单遍历；<br />对于某些特殊集合，简单遍历会比迭代器遍历效率更高</td>
<td>当需要隐藏集合复杂性或者保证安全性时；<br />需要减少重复遍历代码时；<br />希望遍历不同的甚至无法预知的数据结构时</td>
</tr>
<tr>
<td>备忘录模式</td>
<td>允许在不暴露对象细节的情况下保存和回复对象状态</td>
<td>在不破坏对象封装的前提下，创建对象快照；<br />原发器状态记录维护的好的话，可以简化原发器代码</td>
<td>备忘录多会消耗更多内存；<br />负责人必须跟踪完整的原发器生命周期才能正确销毁弃用的备忘录；<br />大部分动态编程语言（PHP、Python等）不能保证备忘录状态不被修改</td>
<td>当需要创建对象状态快照来回复对象之前的状态时；<br />当访问对象会导致封装被突破时</td>
</tr>
<tr>
<td>状态模式</td>
<td>对象内部状态变化时能改变其行为，看上去就像是对象所属类发生变化一样</td>
<td>单一职责原则，特定状态的代码在特定类中；<br />开闭原则，新增状态不影响已有状态；<br />可以消除臃肿的条件语句</td>
<td>不适合状态机比较少的情况</td>
<td>对象在不同状态下有不同行为，同时状态多且频繁切换；<br />当相似状态和机遇条件的状态机转换中存在许多重复代码时</td>
</tr>
<tr>
<td>模板方法模式</td>
<td>超类中定义算法框架，子类在框架下可以重写算法的特定步骤</td>
<td>允许重写算法的某个部分；<br />可以将重复的算法步骤整合到超类中</td>
<td>维护困难；<br />如果子类抑制父类默认步骤，会违反里式替换原则（子类可拓展父类功能，但不能替换父类原有功能）</td>
<td>只调整算法的某个特定步骤时；<br />多个算法只有细微之处不一样时</td>
</tr>
<tr>
<td>命令模式</td>
<td>可以将请求装换为一个包含请求信息的独立对象·，然后利用该对象可以实现各种操作</td>
<td>单一职责原则，解耦触发和执行的代码；<br />开闭原则，不修改客户端代码的情况下创建新的命令；<br />可以实现操作的撤销、恢复、延迟执行、组合等需求</td>
<td>代码复杂度增加</td>
<td>通过操作来参数化对象；<br />将操作进行队列化管理、远程执行等擦搜做时；<br />实现操作回滚功能</td>
</tr>
<tr>
<td>中介者模式</td>
<td>使用中介者将对象之间的合作进行管理</td>
<td>单一职责原则，可以将耦合关系集中到中介者当中；<br />开闭原则，无需更改组建即可增加新中中介者；<br />减轻耦合；<br />更方便的复用组件</td>
<td>随着中介者内部逻辑的增多，可能会变得难以管理且功能过多</td>
<td>当一些对象与其他对象紧密结合以至难以修改时；<br />当某个对象由于与其他对象耦合度过高导致无法复用时；<br />替代一些仅具备简单功能的子类</td>
</tr>
<tr>
<td>观察者模式</td>
<td>定义一种订阅机制，当被订阅的内容发生变化时，会通知订阅该内容的对象</td>
<td>开闭原则，新订阅类不影响被订阅类；<br />在运行时建立对象之间的联系</td>
<td>订阅者通知顺序时随机的</td>
<td>当一个对象的某些行为需要收到监控时；<br />当某些逻辑需要依赖某个对象的一些内容的变化时</td>
</tr>
<tr>
<td>策略模式</td>
<td>定义一系列算法，并将其放入独立的类中，以使算法的对象可以相互替换</td>
<td>可以在运行时切换算法；<br />可以将算法的实现与使用剥离开；<br />可以使用组合代替继承；<br />开闭原则，新增策略不需要修改原有策略</td>
<td>不适合算法不变的情况；<br />代码复杂度提升</td>
<td>类中有多个算法变体，并能够在运行时切换算法时；<br />有许多尽在执行某些行为时略有不同的相似类时；<br />算法在上下文的实现中不失特别重要，可以使用该模式剥离业务逻辑与算法；<br />当类中使用了复杂的条件运算符以在同一算法的不同变体中切换时</td>
</tr>
<tr>
<td>访问者模式</td>
<td>将算法与访问者隔离开</td>
<td>开闭原则，不影响已有行为；<br />单一职责原则，可以将同一行为的不用版本放到同一个类中；<br />访问者对象可以在访问时可以收集一些有用的信息</td>
<td>每次在元素层次中添加或者移除时一个类时，都需要更新所有访问者；<br />访问者可能无法访问对象的私有变量、方法</td>
<td>对一个复杂对象结构的所有元素进行访问时；<br />清理辅助行为的业务逻辑；<br />当某个行为仅在类层次结构中有意义，在其他类中没有意义时</td>
</tr>
</tbody></table>
<h2 id="简单工厂和抽象工厂有什么区别？"><a href="#简单工厂和抽象工厂有什么区别？" class="headerlink" title="简单工厂和抽象工厂有什么区别？"></a>简单工厂和抽象工厂有什么区别？</h2><h3 id="三种模式介绍："><a href="#三种模式介绍：" class="headerlink" title="三种模式介绍："></a>三种模式介绍：</h3><ul>
<li>工厂模式；有实体类、创建对应实体的工厂类（一个实体类对应一个工厂类）组成，当增加新实体时，需要增加新的实体类和新的该实体类对应的工厂类即可</li>
<li>简单工厂模式：由实体类和一个工厂类组成，当新增实体类时，需要增加一个实体类，并且在唯一的工厂类里面进行修改，增加新实体的创建逻辑</li>
<li>抽象工厂模式：将一个产品进行更细致的划分，将该产品的共同点抽象成一个类，然后其细分特点单独实现实体类，且实现该实体类对应的工厂类<h3 id="三者特点"><a href="#三者特点" class="headerlink" title="三者特点"></a>三者特点</h3></li>
<li>常用简单工厂模式，工厂模式代码量较大，抽象工厂模式适合业务复杂、较大的情况</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/04/14/Q&A/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="cl3099frp004dqzd461wbfbzn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/12/Q&A/Java/%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2022-04-12T11:43:00.000Z" itemprop="datePublished">2022-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/12/Q&A/Java/%E7%BD%91%E7%BB%9C/">网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="常见的http响应码"><a href="#常见的http响应码" class="headerlink" title="常见的http响应码"></a>常见的http响应码</h3><ul>
<li><p>分类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>信息响应</td>
<td>100-199</td>
</tr>
<tr>
<td>成功响应</td>
<td>200-299</td>
</tr>
<tr>
<td>重定向</td>
<td>300-399</td>
</tr>
<tr>
<td>客户端错误</td>
<td>400-499</td>
</tr>
<tr>
<td>服务器错误</td>
<td>500-599</td>
</tr>
</tbody></table>
</li>
<li><p>常见http状态码：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>英文名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>表示当前内容可行，可以继续执行请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching protocol</td>
<td>响应客户端Upgrade，表示服务端正在切换协议</td>
</tr>
<tr>
<td>102</td>
<td>Processing</td>
<td>表示服务端已经收到病正在处理请求，但没有响应可用</td>
</tr>
<tr>
<td>103</td>
<td>Early Hints</td>
<td>用于与link链接头一起使用，以允许用户代理在服务器准备响应阶段开始预加载preloading资源</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功，一般用于GET和POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>请求成功，并因此创建资源成功，通常应用于post、put请求</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>请求已收到，还未响应，没有结果。意味着不会有一个异步响应回复请求，可能会有另外的进程或者服务去处理该请求，通常用于批处理或者转发请求给其他进程或服务处理</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative_Informatioin</td>
<td>服务器已经成功处理请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或第三方的拷贝。当前信息可能是原始版本的子集或者超集。即代理服务器对原始数组做了修改之后返回的状态码</td>
</tr>
<tr>
<td>204</td>
<td>No_Content</td>
<td>即成功响应，但是客户端当前状态不需要更新，比如put请求中进行资源更新，资源在服务端更新完成，但是客户端不需要更新页面的情况</td>
</tr>
<tr>
<td>205</td>
<td>Reset_Content</td>
<td>告诉客户端重置文档视图，比如清空表单内容、重置canvas状态或者刷新用户界面</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>请求某一部分资源，比如服务器成功响应了get请求，响应报文中包含由Content-Range制定范围内的内容</td>
</tr>
<tr>
<td>301</td>
<td>Moved_Permanently</td>
<td>永久性重定向。请求的资源已经被永久移动到新的URI，返回的信息包括新的URI，浏览器会自动定向到新的URI，今后任何新的请求都应使用新的URI请求</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时性重定向</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其他地址。与302类似，使用GET请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改，所请求的资源未修改，服务器返回此状态码时，不会返回任何资源，客户端会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在制定日期修改后的资源，即该状态码时服务端对客户端有缓存且该缓存有效时的一种返回</td>
</tr>
<tr>
<td>307</td>
<td>Temporary_Redirect</td>
<td>临时重定向，与302类似，使用get请求重定向，会按照浏览器标准，不会从post变成get（302会），即使用同样的请求方法和请求内容向新的URI发起请求，为了区分开302</td>
</tr>
<tr>
<td>400</td>
<td>Bad_Request</td>
<td>客户端报文中存在语法错误，服务端无法理解，浏览器会像200一样处理该状态码</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证，通过http认证（BASIC认证，DIGEST认证）的认证信息，若之前进行过一次请求，则表示用户认证失败</td>
</tr>
<tr>
<td>402</td>
<td>Payment_Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解客户端的请求，但是拒绝处理该请求</td>
</tr>
<tr>
<td>404</td>
<td>Not_Found</td>
<td>服务端无法根据客户端请求找到资源</td>
</tr>
<tr>
<td>500</td>
<td>Internal_Server_Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not_Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>503</td>
<td>Service_Unavailable</td>
<td>由于超载或系统维护，服务器暂时无法响应客户端请求</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http|响应码 301 和 302 代表的是什么？有什么区别？"></a>http|响应码 301 和 302 代表的是什么？有什么区别？</h3><ul>
<li>定义：301代表永久性重定向，302代表临时重定向</li>
<li>区别：301应该永久替换使用新的URI，302需要继续使用原有URI</li>
</ul>
<h3 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h3><table>
<thead>
<tr>
<th></th>
<th>forward</th>
<th>redirect</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>转发，服务端转发给另外的服务，服务端直接请求新的URL</td>
<td>重定向，即客户端访问新的URL</td>
</tr>
<tr>
<td>重新发请求对象</td>
<td>服务端</td>
<td>客户端</td>
</tr>
<tr>
<td>浏览器区别</td>
<td>浏览器地址无变化，浏览器不知道新的URL，此时是正向代理，浏览器啥也不知道，以为是正常的</td>
<td>浏览器会显示新的URL</td>
</tr>
<tr>
<td>请求次数</td>
<td>转发对于客户端来说只有一次请求</td>
<td>重定向需要客户端发两次请求</td>
</tr>
</tbody></table>
<h3 id="简述-tcp-和-udp的区别？"><a href="#简述-tcp-和-udp的区别？" class="headerlink" title="简述 tcp 和 udp的区别？"></a>简述 tcp 和 udp的区别？</h3><table>
<thead>
<tr>
<th></th>
<th>tcp</th>
<th>udp</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>tcp（Transmission Control Protocol）是面向连接的、可靠的字节流传输通信协议</td>
<td>udp（User Datagram Protocol）是一种无需连接就可以发送数据包的无连接传输协议</td>
</tr>
<tr>
<td>优点</td>
<td>可靠性高</td>
<td>速度快，操作简单，资源占用少</td>
</tr>
<tr>
<td>缺点</td>
<td>资源占用高、速度慢、操作复杂</td>
<td>不可靠</td>
</tr>
<tr>
<td>特点</td>
<td>注重可靠性，管发也尽量保证让对方收到</td>
<td>注重简单和速度，不注重可靠性，只管发，不管收</td>
</tr>
</tbody></table>
<h3 id="tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="tcp 为什么要三次握手，两次不行吗？为什么？"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h3><ul>
<li>两次不行，两次无法确定两端同时具备发送和接受数据的能力</li>
<li>三次握手的目的：<ul>
<li>client发送数据给server：client证明自己具备发送数据能力</li>
<li>server发送数据给client：server证明自己具备接收和发送数据能力</li>
<li>client发送数据给server：client证明自己具备接收数据能力</li>
</ul>
</li>
<li>四次挥手目的：<ul>
<li>client告诉server要关闭连接</li>
<li>server告诉client自己知道了，并等待数据传输完成</li>
<li>server主动告诉client，可以关闭了</li>
<li>client告诉server知道了，过一会就关闭</li>
</ul>
</li>
</ul>
<h3 id="说一下-tcp-粘包是怎么产生的？"><a href="#说一下-tcp-粘包是怎么产生的？" class="headerlink" title="说一下 tcp 粘包是怎么产生的？"></a>说一下 tcp 粘包是怎么产生的？</h3><ul>
<li>粘包定义：tcp在传输数据时会将数据拆分成多个数据报依次发送，当接收方收到之后解析完数据包之后的数据跟发送法发出的原始数据不一致的问题，解析的时候出现的数据包首尾连到一起导致的解析出错的问题，有可能消息解析出来后多了其他请求的消息的内容或者本身请求消息内容混乱</li>
<li>产生原因：<ul>
<li>发送方原因：TCP默认使用Nagle算法（作用是减少网络中数据段数量），Nagle的两种策略（收到确认发送下一个；收集多个数据段，收到确认后一起发出），Nagle会导致粘包问题，即一起发出的时候</li>
<li>接收方原因：没有即使从缓存中读取数据段</li>
</ul>
</li>
<li>产生的根本原因：消息边界的不确定</li>
<li>解决方法：<ul>
<li>加入特殊标志，标志消息头尾</li>
<li>加入消息长度信息</li>
</ul>
</li>
<li>UDP是直接发送完整消息，太长分片，所以不会有粘包问题</li>
</ul>
<h3 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39521554/article/details/79894501">参考文章</a></li>
<li>OSI（Open System Interconnect），即开放式系统互联</li>
<li>七层模型介绍：<table>
<thead>
<tr>
<th>层级</th>
<th>功能</th>
<th>TCP/IP四层概念模型</th>
<th>对应协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为应用软件提供接口，以实现与另一应用的通信</td>
<td>应用层</td>
<td>HTTP、FTP、DHCP</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式转化、数据加密</td>
<td>应用层</td>
<td>LPP、XDP、NBSSN</td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理、维护会话</td>
<td>应用层</td>
<td>SSL、TLS、RPC</td>
</tr>
<tr>
<td>传输层</td>
<td>建立、管理、维护端到端的连接</td>
<td>传输层</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>IP选址及路由选择</td>
<td>网络层</td>
<td>IP、ICMP、IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>提供网络成与物理层之间的通信</td>
<td>数据链路层</td>
<td>PPTP、L2TP、RARP</td>
</tr>
<tr>
<td>物理层</td>
<td>比特流传输，即各种实体设备，网线、路由器、交换机等</td>
<td>数据链路层</td>
<td>IEEE 802.2</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="get-和-post-请求有哪些区别？"><a href="#get-和-post-请求有哪些区别？" class="headerlink" title="get 和 post 请求有哪些区别？"></a>get 和 post 请求有哪些区别？</h3><ul>
<li>综述：两个本质上没有差别，由于浏览器与服务器的限制，导致产生了差别，不携带参数的时候几乎一样<table>
<thead>
<tr>
<th></th>
<th>get</th>
<th>post</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>http的一种请求方法，用于请求一个制定资源</td>
<td>http的一种请求方法，用于将实体提交到制定的资源</td>
</tr>
<tr>
<td>参数位置</td>
<td>http本身无限制，约定放在URL中，其实也可以有body</td>
<td>http本身无限制，约定放在body中，也可以放到URL中</td>
</tr>
<tr>
<td>参数长度</td>
<td>http本身无限制，浏览器会限制URL整个长度在2K左右</td>
<td>body理论上无限制，取决于浏览器限制</td>
</tr>
<tr>
<td>安全</td>
<td>较差，参数地址栏可见</td>
<td>较好，参数在body中，实际仅使用HTTP时都不安全，需要使用加解密才更安全</td>
</tr>
<tr>
<td>数据包</td>
<td>一个数据包</td>
<td>可能是两个数据包，也可能是一个，看浏览器</td>
</tr>
<tr>
<td>编码方式</td>
<td>只能进行URL编码</td>
<td>支持多种编码</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h3><ul>
<li>跨域：浏览器为了保证安全（比如防止XSS、CSRF攻击等），会限制仅能请求同一个域名地址下的服务</li>
<li>如何实现：<ul>
<li>JSONP：需要浏览器和服务都支持，</li>
<li>CORS：需要浏览器和服务都支持</li>
<li>postMessage</li>
<li>Websocket</li>
<li>Node中间件代理（两次跨域）</li>
<li>nginx反向代理（正反向代理如何判断，一方不知道另一方的存在，比如VPN，就是服务器不知道真实客户端的存在，就是正向代理，Nginx让客户端不知道真实服务器的存在，就是反向代理）</li>
<li>window.name + iframe</li>
<li>location.hash + iframe</li>
<li>document.domain + iframe</li>
</ul>
</li>
</ul>
<h3 id="说一下-JSONP-实现原理？"><a href="#说一下-JSONP-实现原理？" class="headerlink" title="说一下 JSONP 实现原理？"></a>说一下 JSONP 实现原理？</h3><ul>
<li>利用在&lt;script&gt;的漏洞，本质支持跨域，然后用回调接收json进行处理</li>
</ul>
<h3 id="浏览器输入链接请求的详细过程"><a href="#浏览器输入链接请求的详细过程" class="headerlink" title="浏览器输入链接请求的详细过程"></a>浏览器输入链接请求的详细过程</h3><ul>
<li>URL输入</li>
<li>DNS解析</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器响应请求</li>
<li>浏览器解析渲染页面</li>
<li>HTTP请求结束，断开TCP连接</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/04/12/Q&A/Java/%E7%BD%91%E7%BB%9C/" data-id="cl3099frq004iqzd4fonygb4b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/06/Q&A/Java/%E5%BC%82%E5%B8%B8/" class="article-date">
  <time datetime="2022-04-06T14:39:41.000Z" itemprop="datePublished">2022-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/06/Q&A/Java/%E5%BC%82%E5%B8%B8/">异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="系统抛异常的方式"><a href="#系统抛异常的方式" class="headerlink" title="系统抛异常的方式"></a>系统抛异常的方式</h3><ul>
<li>throw</li>
<li>throws</li>
<li>系统自动抛异常</li>
</ul>
<h3 id="throw-与-throws-的区别"><a href="#throw-与-throws-的区别" class="headerlink" title="throw 与 throws 的区别"></a>throw 与 throws 的区别</h3><table>
<thead>
<tr>
<th></th>
<th>throw</th>
<th>throws</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>表示当前代码块抛出的一个异常</td>
<td>表示当前方法可能抛出的一个或多个异常，声明要抛出的异常类型｜</td>
</tr>
<tr>
<td>使用位置</td>
<td>方法中</td>
<td>方法名中</td>
</tr>
<tr>
<td>处理位置</td>
<td>方法中、调用该方法的方法中</td>
<td>调用该方法的方法中</td>
</tr>
<tr>
<td>特点</td>
<td>执行到这一行，就是一定有异常，表示一定</td>
<td>不一定真的产生这些异常，表达可能行</td>
</tr>
</tbody></table>
<h3 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h3><table>
<thead>
<tr>
<th></th>
<th>final</th>
<th>finally</th>
<th>finalize</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>使修饰内容不发生变化，使被修饰的内容只读</td>
<td>配合try、catch完成异常处理的一部分流程，表示该部分最后且一定会执行，即使catch中return了，经常用来释放资源</td>
<td>是object的方法之一，作用是协助gcc释放资源</td>
</tr>
<tr>
<td>修饰内容</td>
<td>修饰变量、方法、类</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>修饰内容特点</td>
<td>被修饰内容不可变，类不能被继承、方法不能被重写，变量内容不能变（变量值不变或者引用不变）</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h3><ul>
<li>catch和finally都可以省略，但是不能同时省略</li>
</ul>
<h3 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><ul>
<li>return之前会先执行finally，具体执行情况如下<ul>
<li>finally中有return：此处会覆盖try与catch中的返回值</li>
<li>finally中没有return：<ul>
<li>返回值是基本数据类型：由于返回值已经存储在栈中了，所以finally中的改变是无效的</li>
<li>返回值是引用类型：finally中对引用的操作会生效</li>
</ul>
</li>
</ul>
</li>
<li>不会执行的情况： <ul>
<li>没有进入try</li>
<li>强制退出程序</li>
<li>守护线程被终止</li>
</ul>
</li>
</ul>
<h3 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h3><table>
<thead>
<tr>
<th>异常名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>NullPointerException</td>
<td>空指针</td>
</tr>
<tr>
<td>SQLException</td>
<td>数据库访问异常</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>数组越界</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>字符串转数值类型异常</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>打开文件失败</td>
</tr>
<tr>
<td>IOException</td>
<td>I/O异常</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>强制类型转换异常</td>
</tr>
<tr>
<td>ArrayStoreException</td>
<td>向数组中存入错误类型对象时的异常</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>无效参数</td>
</tr>
<tr>
<td>ArithmeticException</td>
<td>运算异常</td>
</tr>
<tr>
<td>NegativeArraySizeException</td>
<td>创建长度为负的数组异常</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>找不到方法</td>
</tr>
<tr>
<td>SecurityException</td>
<td>存在安全侵犯</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>不支持的操作</td>
</tr>
<tr>
<td>RuntimeException</td>
<td>运行时异常父类</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/04/06/Q&A/Java/%E5%BC%82%E5%B8%B8/" data-id="cl3099frn0047qzd4cunxcyjp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Q&amp;A/Java/javaWeb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/28/Q&A/Java/javaWeb/" class="article-date">
  <time datetime="2022-03-28T08:25:19.000Z" itemprop="datePublished">2022-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Q-A/">Q&A</a>►<a class="article-category-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/28/Q&A/Java/javaWeb/">javaWeb</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="servlet是什么？"><a href="#servlet是什么？" class="headerlink" title="servlet是什么？"></a>servlet是什么？</h3><ul>
<li>是一个java web应用服务器，servlet就是一个java官方封装好的HTTP应用服务器功能集合（也可以说规范，比如实现了识别http请求，复用TCP连接等底层操作），即是一个Java官方提供的HTTP服务器功能集合或者规范，方便我们基于此进行应用服务的开发，将精力集中在业务层的编码中即可</li>
<li>诞生的原因或者目的：方便开发者快速开发java web服务，为java web服务提供一套规范</li>
</ul>
<h3 id="jsp是什么？"><a href="#jsp是什么？" class="headerlink" title="jsp是什么？"></a>jsp是什么？</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266262958498784">参考文章</a></li>
<li>是一个java web应用服务器，全称Java server Pages</li>
<li>样子是一个html文件，然后里面内嵌着java代码，用来实现动态网页的开发，这种方式更适合前后端融合的形式，一个人编写比较方便</li>
<li>用来开发动态网页应用的一种方式，静态网页之中包含java代码，以实现动态响应能力</li>
<li>实际运行时会被编译成servlet，本质是servlet的另一种形式</li>
</ul>
<h3 id="Tomcat是什么？"><a href="#Tomcat是什么？" class="headerlink" title="Tomcat是什么？"></a>Tomcat是什么？</h3><ul>
<li>Tomcat是集合了Servlet、JSP、Java WebSocket等多种网络服务功能的一个更大的java web 服务器，并且还具有可视化配置页面等功能</li>
</ul>
<h3 id="struts是什么"><a href="#struts是什么" class="headerlink" title="struts是什么"></a>struts是什么</h3><ul>
<li>即struts web，是一个开源框架，对java servlet API进行了拓展，增加了model、view、controller层，提高java web应用开发效率</li>
</ul>
<h3 id="Apache是什么？"><a href="#Apache是什么？" class="headerlink" title="Apache是什么？"></a>Apache是什么？</h3><ul>
<li>是一个web服务功能集合，全称Apache HTTP Server，只支持HTTP服务</li>
</ul>
<h3 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h3><ul>
<li>一款轻量级web服务器，跟Apache核心功能类似，都是HTTP服务器，特点是更适合高并发场景等</li>
</ul>
<h3 id="正向代理、反向代理"><a href="#正向代理、反向代理" class="headerlink" title="正向代理、反向代理"></a>正向代理、反向代理</h3><ul>
<li>正向代理：VPN即正向代理，即代理会真的替代客户端发请求，而非转发，此时客户端的请求是被整整替代的，所以正向代理，代理的是客户端</li>
<li>反向代理：即代理只是转发请求，并没有代理客户端发请求，然后服务器响应，此时服务器被代理</li>
<li>总结：正向代理，即客户端被代理的情况，反向代理是服务端被代理的情况</li>
</ul>
<h3 id="jsp-和-servlet-有什么区别？"><a href="#jsp-和-servlet-有什么区别？" class="headerlink" title="jsp 和 servlet 有什么区别？"></a>jsp 和 servlet 有什么区别？</h3><table>
<thead>
<tr>
<th></th>
<th>jsp</th>
<th>servlet</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>jsp本质就是servlet，是servlet的一种简易实现方式，或者说是servlet的拓展，JVM只能识别java代码，是web服务器将jsp代码编译成java代码</td>
<td>servlet是java官方提供你的一套http服务器功能集合，或者说一种http服务器规范，方便开发者快速开发应用服务，将精力集中在业务上</td>
</tr>
<tr>
<td>适用场景</td>
<td>jsp是在HTML中包含了java代码，所以本身包含可视化页面，更容易实现动态网页应用</td>
<td>servlet内部更多地是各种逻辑层，没有可视化相关的内容，更适合做逻辑层、控制层等</td>
</tr>
<tr>
<td>特点</td>
<td>jsp侧重于可视化部分</td>
<td>servlet侧重于逻辑控制部分</td>
</tr>
<tr>
<td>诞生目的</td>
<td>简化servlet的使用，使servlet跟HTML更好的结合起来，更好的实现java web应用</td>
<td>为开发者提供java web应用服务开发的规范或者工具，提高开发者效率</td>
</tr>
</tbody></table>
<h3 id="jsp-有哪些内置对象？作用分别是什么？"><a href="#jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="jsp 有哪些内置对象？作用分别是什么？"></a>jsp 有哪些内置对象？作用分别是什么？</h3><table>
<thead>
<tr>
<th>jsp内置对象名称</th>
<th>对应servlet类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>javax.servlet.http.HttpServletRequest</td>
<td>client请求信息，http协议头信息、cookie、请求参数等</td>
</tr>
<tr>
<td>response</td>
<td>javax.servlet.http.HttpServletResponse</td>
<td>server响应client请求，返回信息</td>
</tr>
<tr>
<td>pageContent</td>
<td>javax.servlet.jsp.PageContext</td>
<td>页面上下文</td>
</tr>
<tr>
<td>session</td>
<td>javax.servlet.http.HttpSession</td>
<td>client与server之间的会话</td>
</tr>
<tr>
<td>application</td>
<td>javax.servlet.ServletContext</td>
<td>获取服务端应用生命周期信息</td>
</tr>
<tr>
<td>out</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>server给client传输内容的输出流</td>
</tr>
<tr>
<td>config</td>
<td>javax.servlet.ServletConfig</td>
<td>初始化是，jsp引擎向jsp页面传递的信息</td>
</tr>
<tr>
<td>page</td>
<td>java.lang.Object</td>
<td>指向jsp页面本身</td>
</tr>
<tr>
<td>exception</td>
<td>java.lang.Throwable</td>
<td>页面异常对象</td>
</tr>
</tbody></table>
<h3 id="说一下-jsp-的-4-种作用域？"><a href="#说一下-jsp-的-4-种作用域？" class="headerlink" title="说一下 jsp 的 4 种作用域？"></a>说一下 jsp 的 4 种作用域？</h3><ul>
<li>作用域：即信息共享范围，类似于public、private这种</li>
<li>四种作用域介绍：<table>
<thead>
<tr>
<th>作用域范围</th>
<th>信息传递类</th>
</tr>
</thead>
<tbody><tr>
<td>application：即服务启动到停止的时间</td>
<td>ServletContext</td>
</tr>
<tr>
<td>session：http会话开始到结束的时间</td>
<td>session</td>
</tr>
<tr>
<td>request：http请求到结束的时间</td>
<td>request</td>
</tr>
<tr>
<td>page：当前页面打开到关闭的时间</td>
<td>pageContext</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="session-和-cookie-有什么区别？"><a href="#session-和-cookie-有什么区别？" class="headerlink" title="session 和 cookie 有什么区别？"></a>session 和 cookie 有什么区别？</h3><table>
<thead>
<tr>
<th></th>
<th>cookie</th>
<th>session</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>是放在client上给server端做相关逻辑使用的，server会在response中返给client，server可以对cookie进行读写，比如可以使用cookie来保存用户信息，以便于server端校验用户信息</td>
<td>是放在server上，可以用来跟cookie的搭配做一些比如用户信息校验的逻辑</td>
</tr>
<tr>
<td>存放位置</td>
<td>client</td>
<td>server</td>
</tr>
<tr>
<td>容易</td>
<td>较小</td>
<td>较大</td>
</tr>
<tr>
<td>安全性</td>
<td>较差</td>
<td>较强</td>
</tr>
</tbody></table>
<h3 id="说一下-session-的工作原理？"><a href="#说一下-session-的工作原理？" class="headerlink" title="说一下 session 的工作原理？"></a>说一下 session 的工作原理？</h3><ul>
<li>简要说明：用户注册之后生成session，然后保存到内存或者硬盘中，供cookie过来之后的校验</li>
<li>举例：比如用户登录校验这种，用户登录成功后，server将待seesionId的cookie返回给client，当client发起新的请求时，将cookie发送给server，然后server使用cookie和seesion进行用户登录校验，比如可以匹配一下seesionId这种方式验证</li>
</ul>
<h3 id="如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="如果客户端禁止 cookie 能实现 session 还能用吗？"></a>如果客户端禁止 cookie 能实现 session 还能用吗？</h3><ul>
<li>当然能用，cookie只是一个保存信息的数据结构而已，我们可以自己设计另一个跟cookie功能一致的东西，办法很多，根据场景选择即可，比如此时client只保存一个sessionid给server做用户登录校验即可</li>
</ul>
<h3 id="spring-mvc-和-struts-的区别是什么？"><a href="#spring-mvc-和-struts-的区别是什么？" class="headerlink" title="spring mvc 和 struts 的区别是什么？"></a>spring mvc 和 struts 的区别是什么？</h3><table>
<thead>
<tr>
<th></th>
<th>spring mvc</th>
<th>struts</th>
</tr>
</thead>
<tbody><tr>
<td>简介</td>
<td>spring MVC是一个web开发框架，本质上相当于servlet，方便开发者更高效的开发web应用</td>
<td>是一个web开发框架，基于servlet与MVC设计模式实现</td>
</tr>
<tr>
<td>机制</td>
<td>spring mvc的入口是servlet</td>
<td>入口是filter</td>
</tr>
<tr>
<td>性能</td>
<td>较好，基于方法设计，粒度更细</td>
<td>较差，基于类设计，每收到一个请求，都会实例一个action</td>
</tr>
<tr>
<td>参数传递</td>
<td>形参传递，方法之间是独立的</td>
<td>可以使用属性接收参数</td>
</tr>
<tr>
<td>设计思想</td>
<td>在servlet上进行拓展，AOP</td>
<td>OOP</td>
</tr>
<tr>
<td>开发效率</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>配置量</td>
<td>接近0</td>
<td>较多</td>
</tr>
<tr>
<td>拦截器实现机制</td>
<td>AOP方式，方法级别拦截</td>
<td>自己的interceptor机制，类级别拦截</td>
</tr>
<tr>
<td>Ajax支持</td>
<td>继承了Ajax，使用@ResponseBody即可实现</td>
<td>拦截器中继承了Ajax，在action中处理时必须安装插件或者写代码集成进去，使用较为不方便</td>
</tr>
<tr>
<td>验证机制</td>
<td>支持JSR303（一种参数校验规范），处理简单</td>
<td>繁琐</td>
</tr>
</tbody></table>
<h3 id="如何避免-sql-注入？"><a href="#如何避免-sql-注入？" class="headerlink" title="如何避免 sql 注入？"></a>如何避免 sql 注入？</h3><ul>
<li>定义：输入数据中包含非法sql语句，且此sql语句被非法执行</li>
<li>避免策略：<ul>
<li>过滤输入内容，校验字符串</li>
<li>参数化查询</li>
<li>安全测试、安全审计（CR）</li>
<li>避免使用动态sql</li>
<li>数据库重要数据加密</li>
<li>数据库权限控制</li>
<li>避免数据库直接跟用户产生交互</li>
</ul>
</li>
</ul>
<h3 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h3><ul>
<li>定义：又称CSS，全称Cross Site Script（跨站脚本攻击），即输入一段HTML来攻击应用</li>
<li>避免策略：<ul>
<li>对输入、输出进行过滤、转义处理</li>
<li>对HTML标签、CSS属性复制的地方进行校验</li>
</ul>
</li>
</ul>
<h3 id="什么是-CSRF-攻击，如何避免？"><a href="#什么是-CSRF-攻击，如何避免？" class="headerlink" title="什么是 CSRF 攻击，如何避免？"></a>什么是 CSRF 攻击，如何避免？</h3><ul>
<li>定义：全称Cross Site Request Forgery（跨站请求伪造），即攻击者盗用身份，发送恶意请求</li>
<li>避免策略：<ul>
<li>阻止不明外域访问，比如验证请求地址等策略</li>
<li>关键操作添加验证码</li>
<li>增加token、cookie校验策略</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liquangang.github.io/2022/03/28/Q&A/Java/javaWeb/" data-id="cl3099frj003oqzd41jva8cze" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/">Q&A</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Q-A/Q-A-java/">Q&A-java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/codeStyle/">codeStyle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">mac使用技巧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BD%BF%E7%94%A8/">区块链使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8/">工具应用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/">工具脚本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%84%E4%BB%B6/">组件</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Q-A/" rel="tag">Q&A</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" rel="tag">博客搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="tag">电脑使用技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/" rel="tag">脚本工具</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Q-A/" style="font-size: 16.67px;">Q&A</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" style="font-size: 13.33px;">博客搭建</a> <a href="/tags/%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">电脑使用技巧</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 20px;">编程</a> <a href="/tags/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">脚本工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/10/Q&A/Java/Zookeeper/">Zookeeper</a>
          </li>
        
          <li>
            <a href="/2022/05/09/Q&A/Java/Kafka/">Kafka</a>
          </li>
        
          <li>
            <a href="/2022/05/06/Q&A/Java/RabbitMQ/">RabbitMQ</a>
          </li>
        
          <li>
            <a href="/2022/04/27/Q&A/Java/MyBatis/">MyBatis</a>
          </li>
        
          <li>
            <a href="/2022/04/24/Q&A/Java/Hibernate/">Hibernate</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 帝王之心<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>